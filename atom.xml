<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汪震|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aaronyard.github.io/"/>
  <updated>2022-01-04T14:55:36.208Z</updated>
  <id>https://aaronyard.github.io/</id>
  
  <author>
    <name>汪震</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MMORPG手游项目优化分享总结</title>
    <link href="https://aaronyard.github.io/2022/01/03/MMORPG/"/>
    <id>https://aaronyard.github.io/2022/01/03/MMORPG/</id>
    <published>2022-01-03T14:01:12.000Z</published>
    <updated>2022-01-04T14:55:36.208Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了全面提升沉淀自己的项目经验，以及想吸收其它优秀MMOPRG项目的技术，观看了一系列UWA讲座，大佬云集，技术以及思维的碰撞产生了大量的灵感，也促使我加深了对MMORPG游戏有了更深的理解，在此针对大世界MMO手游《剑侠世界3》优化分享的讲座进行总结。</p><h2 id="讲座详细信息"><a href="#讲座详细信息" class="headerlink" title="讲座详细信息"></a>讲座详细信息</h2><p>主办单位：UWA<br>讲座：大世界MMO手游《剑侠世界3》优化分享<br>主讲人：江志强 — 西山居《剑侠世界3》项目组 客户端主程<br>如有侵犯，请联系我。</p><a id="more"></a><h3 id="MMORPG手游现状"><a href="#MMORPG手游现状" class="headerlink" title="MMORPG手游现状"></a>MMORPG手游现状</h3><p>大世界、实时天气、上天入地、捏脸易容、超远视距、布料模拟、大规模植被、多人群战、高精度渲染、适配机型广、体积渲染、内存占用小。</p><h3 id="剑世3项目基础参数"><a href="#剑世3项目基础参数" class="headerlink" title="剑世3项目基础参数"></a>剑世3项目基础参数</h3><p>引擎：Unity 2019.4.x 源码编译<br>管线：基于URP7.x改造<br>发布平台：Android/iOS/Windows/Mac M1<br>API:OPGLES3.0或以上，vukan版本制作种<br>内存要求：2G或以上<br>机型：OPPO A5/华为 mate 9/iPhone 6S/以上<br>分辨率：移动端最高画质默认960p<br>包体：首包1.4G，整包2.6G，后台边下边玩补充下载</p><h3 id="1-场景相关"><a href="#1-场景相关" class="headerlink" title="1.场景相关"></a>1.场景相关</h3><h4 id="一、场景相关优化"><a href="#一、场景相关优化" class="headerlink" title="一、场景相关优化"></a>一、场景相关优化</h4><p>1.场景静态处理<br>2.场景流式加载机制<br>3.取代LODGroup，独立LOD线程<br>4.光照烘培&amp;TextureStreaming<br>5.PVS遮挡剔除<br>6.地形&amp;植被<br>7.移动逻辑体素格子<br>8.远景优化思路</p><h4 id="场景基础数据（以主城-江南道场景为例）"><a href="#场景基础数据（以主城-江南道场景为例）" class="headerlink" title="场景基础数据（以主城-江南道场景为例）"></a>场景基础数据（以主城-江南道场景为例）</h4><p>主体大小2K，外围远景4K<br>总制作面数2000万面以上（3级LOD，不含植被Instanceing）<br>4万个以上Render<br>50万棵以上植被<br>手机最高可视距离3.5公里以上<br>模型Mesh制作3级LOD（按1/0.6/0.3面数比例制作）</p><h5 id="1-场景静态处理"><a href="#1-场景静态处理" class="headerlink" title="1.场景静态处理"></a>1.场景静态处理</h5><h6 id="分层分块分LOD相同材质静态合并Mesh"><a href="#分层分块分LOD相同材质静态合并Mesh" class="headerlink" title="分层分块分LOD相同材质静态合并Mesh"></a>分层分块分LOD相同材质静态合并Mesh</h6><p>相同层（远景/地形/植被/建筑框架/地砖/中景/近景/其它）<br>相同区域（32*32米格子内，不同层的分块大小不一样）<br>相同参数（是否参与烘培，是否投射阴影，是否接受阴影，相同材质，相同LOD数量）<br>自动合并&amp;手动合并</p><h6 id="不可见面剔除"><a href="#不可见面剔除" class="headerlink" title="不可见面剔除"></a>不可见面剔除</h6><p>背面剔除（可移动区域外）<br>地下剔除（地形以下）<br>闭合模型重叠面剔除（石头堆叠）</p><h6 id="带顶点动画物体合并"><a href="#带顶点动画物体合并" class="headerlink" title="带顶点动画物体合并"></a>带顶点动画物体合并</h6><p>质心坐标合并到UV3</p><h6 id="合并后同步源参数"><a href="#合并后同步源参数" class="headerlink" title="合并后同步源参数"></a>合并后同步源参数</h6><p>Layer，Tag，ContriGI，LightmapScale，Shadow Caster…<br>未参与合并的Renderer保持不变<br>打组机制，A和B存在子集renderer被合并，那么要保持A，B同时显示或隐藏</p><h6 id="导出Mesh-Prefab文件供后面使用"><a href="#导出Mesh-Prefab文件供后面使用" class="headerlink" title="导出Mesh/Prefab文件供后面使用"></a>导出Mesh/Prefab文件供后面使用</h6><p>—未完待续—</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近为了全面提升沉淀自己的项目经验，以及想吸收其它优秀MMOPRG项目的技术，观看了一系列UWA讲座，大佬云集，技术以及思维的碰撞产生了大量的灵感，也促使我加深了对MMORPG游戏有了更深的理解，在此针对大世界MMO手游《剑侠世界3》优化分享的讲座进行总结。&lt;/p&gt;
&lt;h2 id=&quot;讲座详细信息&quot;&gt;&lt;a href=&quot;#讲座详细信息&quot; class=&quot;headerlink&quot; title=&quot;讲座详细信息&quot;&gt;&lt;/a&gt;讲座详细信息&lt;/h2&gt;&lt;p&gt;主办单位：UWA&lt;br&gt;讲座：大世界MMO手游《剑侠世界3》优化分享&lt;br&gt;主讲人：江志强 — 西山居《剑侠世界3》项目组 客户端主程&lt;br&gt;如有侵犯，请联系我。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="沉淀总结" scheme="https://aaronyard.github.io/tags/%E6%B2%89%E6%B7%80%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>薄弱处总结</title>
    <link href="https://aaronyard.github.io/2021/12/19/problem/"/>
    <id>https://aaronyard.github.io/2021/12/19/problem/</id>
    <published>2021-12-19T14:01:12.000Z</published>
    <updated>2021-12-31T10:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小阶段沉淀及总结"><a href="#小阶段沉淀及总结" class="headerlink" title="小阶段沉淀及总结"></a>小阶段沉淀及总结</h1><p>近期发现了一些自己知识点的薄弱之处，利用加班的工作之余零碎的时间提升自己，顺便将其总结为本篇文章。（连续上半个月的班，每天还加班到深夜甚至凌晨，脑瓜子真的是嗡嗡的！！！）</p><p>大纲<br>1.算法总结<br>2.四叉树</p><h1 id="（一）五大算法总结"><a href="#（一）五大算法总结" class="headerlink" title="（一）五大算法总结"></a>（一）五大算法总结</h1><h2 id="1）分治算法"><a href="#1）分治算法" class="headerlink" title="1）分治算法"></a>1）分治算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>分而治之，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><a id="more"></a><h3 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h3><p>①该问题缩小到一定程度就可以容易的解决。</p><p>②该问题可以分解为若干规模较小的相同问题，即该问题具有最优子结构。</p><p>③利用该问题分解出的子问题的解可以合并为该问题的解。</p><p>④该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p><p>因为问题的计算复杂性一般是随着问题规模的增加而增加，所以①是满足的。②是应用分治法的前提，也是递归思想的应用。是否应用分治法完全取决于③，若不满足该条件，则可以考虑用贪心法或动态规划法。④涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p><h3 id="基本的步骤"><a href="#基本的步骤" class="headerlink" title="基本的步骤"></a>基本的步骤</h3><p>step1分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p>step2解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</p><p>step3合并：将各个子问题的解合并为原问题的解。</p><h3 id="思维过程（类似于数学归纳法）"><a href="#思维过程（类似于数学归纳法）" class="headerlink" title="思维过程（类似于数学归纳法）"></a>思维过程（类似于数学归纳法）</h3><p>1、一定是先找到最小问题规模时的求解方法</p><p>2、然后考虑随着问题规模增大时的求解方法</p><p>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p><h2 id="2）动态规划"><a href="#2）动态规划" class="headerlink" title="2）动态规划"></a>2）动态规划</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>其与分治法最大的差别：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><h3 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h3><p>①最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>②无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响，也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>③有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><h3 id="基本的步骤-1"><a href="#基本的步骤-1" class="headerlink" title="基本的步骤"></a>基本的步骤</h3><p>动态规划的设计都有着一定的模式，一般要经历以下几个步骤：</p><p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态<br>①划分阶段：按照问题的时间特征，把问题分为若干个阶段，在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>②确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来，当然，状态的选择要满足无后效性。</p><p>③确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>④寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><h3 id="思维过程"><a href="#思维过程" class="headerlink" title="思维过程"></a>思维过程</h3><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程。实际应用中可以按以下几个简化的步骤进行设计：<br>①分析最优解的性质，并刻画其结构特征。</p><p>②递归的定义最优解。</p><p>③以自底向上或自顶向下的记忆化方式（备忘录法 dptable）计算出最优值。</p><p>④根据计算最优值时得到的信息，构造问题的最优解。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：<br>①问题的阶段 </p><p>②每个阶段的状态</p><p>③从前一个阶段转化到后一个阶段之间的递推关系。</p><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><h2 id="3）贪心算法"><a href="#3）贪心算法" class="headerlink" title="3）贪心算法"></a>3）贪心算法</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>贪心算法不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（某个状态以后的过程不会影响以前的状态，只与当前状态有关。）</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>①建立数学模型来描述问题。</p><p>②把求解的问题分成若干个子问题。</p><p>③对每一子问题求解，得到子问题的局部最优解。</p><p>④把子问题的解局部最优解合成原来解问题的一个解。</p><h3 id="需要满足的条件-1"><a href="#需要满足的条件-1" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h3><p>局部最优策略能导致产生全局最优解。一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h3 id="例题分析——背包问题"><a href="#例题分析——背包问题" class="headerlink" title="例题分析——背包问题"></a>例题分析——背包问题</h3><p>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p><pre><code>物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30</code></pre><p>分析：</p><p>目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p><p>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p><p>（2）每次挑选所占重量最小的物品装入是否能得到最优解？</p><p>（3）每次选取单位重量价值最大的物品，成为解本题的策略。</p><p>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：</p><p>（1）贪心策略：选取价值最大者。反例：</p><pre><code>W=30   物品：A B C      重量：28 12 12      价值：30 20 20</code></pre><p>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</p><p>（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</p><p>（3）贪心策略：选取单位重量价值最大的物品。反例：</p><pre><code>W=30   物品：A B C      重量：28 20 10      价值：28 20 10</code></pre><p>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p><h2 id="四）回溯法（DFS）"><a href="#四）回溯法（DFS）" class="headerlink" title="四）回溯法（DFS）"></a>四）回溯法（DFS）</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。而满足回溯条件的某个状态的点称为“回溯点”。若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>①针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解；</p><p>②确定结点的扩展搜索规则；</p><p>③以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p><h4 id="非递归回溯框架"><a href="#非递归回溯框架" class="headerlink" title="非递归回溯框架"></a>非递归回溯框架</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  int a[n],i;</span><br><span class="line">  初始化数组a[];</span><br><span class="line">  i = 1;</span><br><span class="line">  <span class="keyword">while</span> (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i &gt; n)                                              // 搜索到叶结点</span><br><span class="line">&#123;   </span><br><span class="line">             搜索到一个解，输出；</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span>                                                   // 处理第i个元素</span><br><span class="line">&#123; </span><br><span class="line">            a[i]第一个可能的值；</span><br><span class="line">            <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line">           &#123;</span><br><span class="line">                a[i]下一个可能的值；</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]在搜索空间内)</span><br><span class="line">           &#123;</span><br><span class="line">                标识占用的资源；</span><br><span class="line">                i = i+1;                              // 扩展下一个结点</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">                清理所占的状态空间；            // 回溯</span><br><span class="line">                i = i –1; </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归的算法框架"><a href="#递归的算法框架" class="headerlink" title="递归的算法框架"></a>递归的算法框架</h5><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int a[n];</span><br><span class="line">   try(int i)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">         输出结果;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span>(fun(j))                 // 满足限界函数和约束条件</span><br><span class="line">               &#123;</span><br><span class="line">                  a[i] = j;</span><br><span class="line">                ...                         // 其他操作,如回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">                  try(i+1);</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五）分支限界法（BFS）"><a href="#五）分支限界法（BFS）" class="headerlink" title="五）分支限界法（BFS）"></a>五）分支限界法（BFS）</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>在问题的解空间树T上搜索问题解的算法，分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><p>分支限界法的搜索策略：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p><h3 id="回溯法和分支限界法的区别"><a href="#回溯法和分支限界法的区别" class="headerlink" title="回溯法和分支限界法的区别"></a>回溯法和分支限界法的区别</h3><p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解。</p><p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解。</p><h1 id="（二）四叉树"><a href="#（二）四叉树" class="headerlink" title="（二）四叉树"></a>（二）四叉树</h1><p>四叉树及其变种常用在碰撞检测以及地图块加载的案例中。近期看了一个技术分享，一款MMO开放大世界的手游，在玩家跳转场景时，把跳转的时间压制在1秒，大大的减少了玩家等待的时间。他们是怎么做到的呢？首先是根据玩家身上的跨场景任务进行预加载，其次，他们把场景地图分为一个个的小块tile，通过四叉树，同步加载玩家坐标周边的地块以及NPC，异步加载场景中的其它物体。这样玩家的就不会长时间进行等待，而是一秒后便可以进入场景，游戏体验极好。</p><h4 id="插入、更新、删除、查询的过程"><a href="#插入、更新、删除、查询的过程" class="headerlink" title="插入、更新、删除、查询的过程"></a>插入、更新、删除、查询的过程</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入一个物体，插入时分割空间直到能容纳改物体的最小空间，插入该物体到结点</span><br><span class="line"><span class="keyword">if</span> 这个节点是能容纳该物体的最小节点，放入这个节点</span><br><span class="line"><span class="keyword">else</span> 分割这个节点，找到合适的子节点执行插入操作</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找到该物体的所属的结点，删除该物体，如果结点不再包含物体并且不含有叶子节点，删除该节点</span><br><span class="line">获取给定物体在节点中的空间划分</span><br><span class="line">获取给定物体在当前节点的空间信息，即4象限信息</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>查询是否包含给定物体</p><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当物体的位置、大小发生变化，更新4叉树中该物体的信息</span><br><span class="line">一般是删除该物体后重新插入</span><br><span class="line">获取某节点下所有物体</span><br></pre></td></tr></table></figure><h4 id="单个空间节点为什么要设置成超过8个元素才往下继续划分空间？"><a href="#单个空间节点为什么要设置成超过8个元素才往下继续划分空间？" class="headerlink" title="单个空间节点为什么要设置成超过8个元素才往下继续划分空间？"></a>单个空间节点为什么要设置成超过8个元素才往下继续划分空间？</h4><p>因为要平衡查询、与更新的性能</p><h4 id="为什么要设置一个looseness松散值让空间节点之间有重合？"><a href="#为什么要设置一个looseness松散值让空间节点之间有重合？" class="headerlink" title="为什么要设置一个looseness松散值让空间节点之间有重合？"></a>为什么要设置一个looseness松散值让空间节点之间有重合？</h4><p>因为要防止边缘元素频繁进更换空间节点，加大更新的性能消耗</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小阶段沉淀及总结&quot;&gt;&lt;a href=&quot;#小阶段沉淀及总结&quot; class=&quot;headerlink&quot; title=&quot;小阶段沉淀及总结&quot;&gt;&lt;/a&gt;小阶段沉淀及总结&lt;/h1&gt;&lt;p&gt;近期发现了一些自己知识点的薄弱之处，利用加班的工作之余零碎的时间提升自己，顺便将其总结为本篇文章。（连续上半个月的班，每天还加班到深夜甚至凌晨，脑瓜子真的是嗡嗡的！！！）&lt;/p&gt;
&lt;p&gt;大纲&lt;br&gt;1.算法总结&lt;br&gt;2.四叉树&lt;/p&gt;
&lt;h1 id=&quot;（一）五大算法总结&quot;&gt;&lt;a href=&quot;#（一）五大算法总结&quot; class=&quot;headerlink&quot; title=&quot;（一）五大算法总结&quot;&gt;&lt;/a&gt;（一）五大算法总结&lt;/h1&gt;&lt;h2 id=&quot;1）分治算法&quot;&gt;&lt;a href=&quot;#1）分治算法&quot; class=&quot;headerlink&quot; title=&quot;1）分治算法&quot;&gt;&lt;/a&gt;1）分治算法&lt;/h2&gt;&lt;h3 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h3&gt;&lt;p&gt;分而治之，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法提升" scheme="https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="沉淀总结" scheme="https://aaronyard.github.io/tags/%E6%B2%89%E6%B7%80%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（四）</title>
    <link href="https://aaronyard.github.io/2021/05/30/LeetCode-4/"/>
    <id>https://aaronyard.github.io/2021/05/30/LeetCode-4/</id>
    <published>2021-05-30T15:02:26.000Z</published>
    <updated>2021-05-30T16:09:17.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串（中等）"><a href="#5-最长回文子串（中等）" class="headerlink" title="5. 最长回文子串（中等）"></a>5. 最长回文子串（中等）</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"babad"</span></span><br><span class="line">输出：<span class="string">"bab"</span></span><br><span class="line">解释：<span class="string">"aba"</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cbbd"</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br></pre></td></tr></table></figure><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：<span class="string">"a"</span></span><br></pre></td></tr></table></figure><h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ac"</span></span><br><span class="line">输出：<span class="string">"a"</span></span><br></pre></td></tr></table></figure><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由数字和英文字母（大写和/或小写）组成</span><br></pre></td></tr></table></figure><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：880 ms, 在所有 C++ 提交中击败了19.07%的用户</span><br><span class="line">内存消耗：378.1 MB, 在所有 C++ 提交中击败了5.34%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。</span><br></pre></td></tr></table></figure><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="keyword">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。</p><p>空间复杂度：O(n^2)，即存储动态规划状态需要的空间。</p><h1 id="方法二：中心扩展算法"><a href="#方法二：中心扩展算法" class="headerlink" title="方法二：中心扩展算法"></a>方法二：中心扩展算法</h1><h3 id="通过-1"><a href="#通过-1" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：20 ms, 在所有 C++ 提交中击败了91.51%的用户</span><br><span class="line">内存消耗：6.8 MB, 在所有 C++ 提交中击败了99.04%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</span><br><span class="line"></span><br><span class="line">边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1) 扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</span><br><span class="line"></span><br><span class="line">「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</span><br></pre></td></tr></table></figure><h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; expandAroundCenter(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：O(n^2)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 O(n) 次。</p><p>空间复杂度：O(1)。</p><h2 id="方法三：Manacher-算法"><a href="#方法三：Manacher-算法" class="headerlink" title="方法三：Manacher 算法"></a>方法三：Manacher 算法</h2><p>不做要求，具体的可以去官网上看。</p><h3 id="思路来源"><a href="#思路来源" class="headerlink" title="思路来源"></a>思路来源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="代码如下-2"><a href="#代码如下-2" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t += <span class="string">'#'</span>;</span><br><span class="line">        s = t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arm_len;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_arm_len;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">int</span> i_sym = j * <span class="number">2</span> - i;</span><br><span class="line">                <span class="keyword">int</span> min_arm_len = min(arm_len[i_sym], right - i);</span><br><span class="line">                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_arm_len = expand(s, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            arm_len.push_back(cur_arm_len);</span><br><span class="line">            <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                right = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">                start = i - cur_arm_len;</span><br><span class="line">                end = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                ans += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：O(n)，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n) 步，因此算法的复杂度为 O(n)。</p><p>空间复杂度：O(n)，我们需要 O(n) 的空间记录每个位置的臂长。</p>]]></content>
    
    <summary type="html">
    
      空闲时间刷算法，培养思维。
    
    </summary>
    
    
      <category term="算法提升" scheme="https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="LeetCode" scheme="https://aaronyard.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="https://aaronyard.github.io/2021/05/29/Development2020To2021/"/>
    <id>https://aaronyard.github.io/2021/05/29/Development2020To2021/</id>
    <published>2021-05-29T15:35:14.000Z</published>
    <updated>2021-05-29T16:45:11.869Z</updated>
    
    <content type="html"><![CDATA[<p>如今已经是2021年了，时光如梭，不禁想起前几天看到的一则新闻，老友记的演员们时隔十几年又聚到了一起。本来是件挺欢喜的事情，但是当我看到他们时，当年的花花公子乔伊如今已是头发花白，当年的冷笑话担当钱德勒也瘦成了一个小老头……十年老友记，时今老友人。当年都是风华正茂的一群人，没有生活大爆炸那样的高智商群体，有的只是如你我一般的普通人，会因为各种事情喜悦或忧愁，但是都能自我调节，或是有朋友的陪伴一路走过来。他们时一群有趣的人，我觉得他们这一辈子值了，有这样一群朋友，有自己的事业、家庭，经济财富也达到了常人难及的地步。</p><p>不禁反问自己，我需要做什么才会等到老了之后不后悔？小时候看着各种各样的海报和杂志，觉得长大之后有风花雪月、碧海蓝天、四处走走瞧瞧，这样的生活才是想要追求的。</p><a id="more"></a><p>越长大越觉得做什么事最重要的都是靠自己，父母会老，小时候父母会督促我做这做那，帮我们矫正错误的事情。但是父母也有他们的认知壁垒，他们只会在自己的认知里给予我一些有限的支持和引导，长大之后我才发现原来有些引导是不对的，这就需要我自己不停的学习和开阔视野，走出独属于自己的一条路。</p><p>从上个博客至今，除了日常上班，这段时间我做了什么呢？</p><h2 id="自律且努力"><a href="#自律且努力" class="headerlink" title="自律且努力"></a>自律且努力</h2><h3 id="坚持运动锻炼"><a href="#坚持运动锻炼" class="headerlink" title="坚持运动锻炼"></a>坚持运动锻炼</h3><p>我做了一个减脂的食谱，在妈妈的帮助下，日复一日的吃着，戒糖戒辣，这一坚持就是大半年。光吃不运动怎么能行？我深知养成习惯的重要性，趁着晚上有时间，我就去楼下跳绳，跟着keep锻炼，再然后去健身房跟着健身教练练。每当我想放弃的时候，我就让自己再坚持坚持，想想当初为什么开始。就这样，一天两天、一周两周、一个月两个月，直到现在，我减掉了二十多斤。现在已是标准体重，体脂率也从23降到15……</p><p>这段时间，我收获最大的就是自律，别人吃各种美食的时候我也馋，但是我知道我需要控制热量摄入，忍着不吃。这一忍就是大半年，我现在可以自信的说我对自己的身体负责了。</p><p>身为吃货，我连好吃的都可以坚持不吃，还有什么是坚持不下来的？</p><h3 id="读书百遍-其意自现"><a href="#读书百遍-其意自现" class="headerlink" title="读书百遍 其意自现"></a>读书百遍 其意自现</h3><p>一开始我也做了一个书单，但是渐渐的发现看书的速度太慢了，索性也就慢慢看，每天看一点，居然也把曼昆写的五百多页的微观经济学原理给啃完了。当看完的那一刻，我发现原来我行的，我可以！</p><p>到现在为止，看完了微观经济学，游戏优化，正在啃产业区块链，只是为了拓宽视野，为将来储备知识。看书这个习惯我会一直持续下去，真挺好的，站在前人的肩膀上，才能站的更高，看的更远。</p><h3 id="尤克里里和画画"><a href="#尤克里里和画画" class="headerlink" title="尤克里里和画画"></a>尤克里里和画画</h3><p>生活很多，但是我可以创造甜头。我有两大乐趣，音乐和绘画。</p><p>从小就是个音乐迷，听到音乐就会摇头晃脑的跟着哼，但是我只能满足于跟着哼吗？那必不能啊，所以我把尤克里里拾了起来，跟着视频弹唱，也挺有乐趣的，时常会高兴的手舞足蹈。</p><p>虽然我画画不怎么样，但是扛不住我喜欢啊！慢慢画，总有一天能画出来自己满意的图画，再者说了，未来做独立游戏说不定还需要自己画呢。</p><h2 id="寻开心"><a href="#寻开心" class="headerlink" title="寻开心"></a>寻开心</h2><p>有时候周末在家实在坐不住呀，那就跟着同事们出去玩嘛，爬山，徒步，逛街，在这个城市长大的，但是一直都没有好好逛过这座城市，趁着这个机会好好逛逛，了解了解它。</p><h2 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h2><p>想做一个可以上架steam的独立游戏，已经构思了一阵，最近着手做了才发现还有很多没有考虑到的地方，但好歹也启动了，等将来某一天也许大家就能玩到。</p><h4 id="大家要一起继续加油哦"><a href="#大家要一起继续加油哦" class="headerlink" title="大家要一起继续加油哦~"></a>大家要一起继续加油哦~</h4><h4 id="放弃很容易-但坚持-一定很酷"><a href="#放弃很容易-但坚持-一定很酷" class="headerlink" title="放弃很容易 但坚持 一定很酷"></a>放弃很容易 但坚持 一定很酷</h4>]]></content>
    
    <summary type="html">
    
      放弃很容易 但坚持 一定很酷
    
    </summary>
    
    
      <category term="个人随笔" scheme="https://aaronyard.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Fighting" scheme="https://aaronyard.github.io/tags/Fighting/"/>
    
  </entry>
  
  <entry>
    <title>自省和展望</title>
    <link href="https://aaronyard.github.io/2020/08/17/ConclusionAndProspect/"/>
    <id>https://aaronyard.github.io/2020/08/17/ConclusionAndProspect/</id>
    <published>2020-08-17T14:40:27.000Z</published>
    <updated>2020-08-17T23:54:14.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="链表的存储反转"><a href="#链表的存储反转" class="headerlink" title="链表的存储反转"></a>链表的存储反转</h2><p>定义一个方法（函数），实现输入一个链表的头结点，然后可以反转这个链表的方向，并输出反转之后的链表的头结点。</p><h2 id="链表结点的结构："><a href="#链表结点的结构：" class="headerlink" title="链表结点的结构："></a>链表结点的结构：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; Node, *List;</span><br></pre></td></tr></table></figure><p>两种方法：遍历法、递归法</p><a id="more"></a><h2 id="遍历法"><a href="#遍历法" class="headerlink" title="遍历法"></a>遍历法</h2><h3 id="主要包括如下4步："><a href="#主要包括如下4步：" class="headerlink" title="主要包括如下4步："></a>主要包括如下4步：</h3><p>1）如果head为空，或者只有head这一个节点，return head即可；</p><p>2）从头到尾遍历链表，把reversedHead赋值给当前节点的next；</p><p>3）当前节点赋值给reversedHead；</p><p>4）遍历结束，return reversedHead。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">reverseList</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node* reversedHead = <span class="literal">NULL</span>;</span><br><span class="line">    Node* p = head;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* q = p;</span><br><span class="line">        q-&gt;next = reversedHead;</span><br><span class="line">        reversedHead = q;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h2><h3 id="递归的实现方式主要有4步："><a href="#递归的实现方式主要有4步：" class="headerlink" title="递归的实现方式主要有4步："></a>递归的实现方式主要有4步：</h3><p>1）如果head为空，或者只有head这一个节点，return head即可；</p><p>2）先遍历head-&gt;next为首的链表，得到一个头结点newHead；</p><p>3）把head赋值给head-&gt;next-&gt;next， head-&gt;next为空；</p><p>4）返回newHead。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">reverseList2</span><span class="params">(node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">     </span><br><span class="line">    node* newHead = reversedList2(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开放题"><a href="#开放题" class="headerlink" title="开放题"></a>开放题</h1><h2 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h2><p><a href="https://www.pianshen.com/article/5717909966/" target="_blank" rel="noopener">https://www.pianshen.com/article/5717909966/</a></p>]]></content>
    
    <summary type="html">
    
      老生常谈：自我反省和展望未来。
    
    </summary>
    
    
      <category term="自我提升" scheme="https://aaronyard.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="个人发展" scheme="https://aaronyard.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（三）</title>
    <link href="https://aaronyard.github.io/2020/07/08/LeetCode-3/"/>
    <id>https://aaronyard.github.io/2020/07/08/LeetCode-3/</id>
    <published>2020-07-08T15:23:31.000Z</published>
    <updated>2020-07-08T16:16:31.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-寻找两个正序数组的中位数（困难）"><a href="#4-寻找两个正序数组的中位数（困难）" class="headerlink" title="4. 寻找两个正序数组的中位数（困难）"></a>4. 寻找两个正序数组的中位数（困难）</h1><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = []</span><br><span class="line">nums2 = [1]</span><br><span class="line">则中位数是 1.0</span><br></pre></td></tr></table></figure><h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = []</span><br><span class="line">nums2 = [1,2]</span><br><span class="line">则中位数是 1.5</span><br></pre></td></tr></table></figure><h2 id="类似递归的二分法（java）"><a href="#类似递归的二分法（java）" class="headerlink" title="类似递归的二分法（java）"></a>类似递归的二分法（java）</h2><h3 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3  ms, 在所有 java 提交中击败了60.78%的用户</span><br><span class="line">内存消耗：41 MB, 在所有 java 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用了类似递归的方法</span><br></pre></td></tr></table></figure><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftLength = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> rightLength = nums2.length;</span><br><span class="line">        <span class="comment">// 为了保证第一个数组比第二个数组小(或者相等)</span></span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数</span></span><br><span class="line">        <span class="comment">//的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (leftLength + rightLength + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = leftLength;</span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j]</span></span><br><span class="line">        <span class="comment">//  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// 循环条件结束的条件为指针重合，即分割线已找到</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置</span></span><br><span class="line">            <span class="comment">// 此处+1首先是为了不出现死循环，即left永远小于right的情况</span></span><br><span class="line">            <span class="comment">// left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right</span></span><br><span class="line">            <span class="comment">// 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界（此处 +1 是首先为了避免出现死循环，同时 +1 以后，还不会出现下标越界的情况），因为+1之后向上取整，保证了</span></span><br><span class="line">            <span class="comment">// i不会取到0值，即i-1不会小于0</span></span><br><span class="line">            <span class="comment">// 此时i也代表着在一个数组中左边的元素的个数</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和</span></span><br><span class="line">            <span class="comment">// 此时j就是第二个元素中左边的元素的个数</span></span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="comment">// 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值</span></span><br><span class="line">            <span class="comment">// 说明又指针应该左移，即-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环时left一定等于right，所以此时等于left和right都可以</span></span><br><span class="line">        <span class="comment">// 为什么left一定不会大于right?因为left=i。</span></span><br><span class="line">        <span class="comment">// 此时i代表分割线在第一个数组中所在的位置</span></span><br><span class="line">        <span class="comment">// nums1[i]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums[i-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">// 此时j代表分割线在第二个数组中的位置</span></span><br><span class="line">        <span class="comment">// nums2[j]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums2[j-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">        <span class="comment">// 当i=0时，说明第一个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="comment">// 当j=0时，说明第二个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        <span class="comment">// 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可</span></span><br><span class="line">        <span class="keyword">if</span> (((leftLength + rightLength) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一</span></span><br><span class="line">            <span class="comment">// 此处不能被向下取整，所以要强制转换为double类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度O(log(m+n))，空间复杂度O(1)。</p><p>建议先看懂上题的注解。</p><h1 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h1><h2 id="出处："><a href="#出处：" class="headerlink" title="出处："></a>出处：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei<span class="_">-s</span>-114/</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h2 id="方法一：二分查找（C-）"><a href="#方法一：二分查找（C-）" class="headerlink" title="方法一：二分查找（C++）"></a>方法一：二分查找（C++）</h2><h3 id="通过-1"><a href="#通过-1" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：16  ms, 在所有 C++ 提交中击败了84.80%的用户</span><br><span class="line">内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="line">这里的 <span class="string">"/"</span> 表示整除</span><br><span class="line">nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="line">nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="line">取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="line">这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="line">如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 <span class="string">"删除"</span>，剩下的作为新的 nums1 数组</span><br><span class="line">如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 <span class="string">"删除"</span>，剩下的作为新的 nums2 数组</span><br><span class="line">由于我们 <span class="string">"删除"</span> 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br></pre></td></tr></table></figure><h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment"> * 这里的 "/" 表示整除</span></span><br><span class="line"><span class="comment"> * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment"> * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment"> * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment"> * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment"> * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment"> * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment"> * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = nums1.size();</span><br><span class="line"><span class="keyword">int</span> n = nums2.size();</span><br><span class="line"><span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 边界情况</span></span><br><span class="line"><span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line"><span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line"><span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> min(nums1[index1], nums2[index2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="keyword">int</span> newIndex1 = min(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> newIndex2 = min(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line"><span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line"><span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> totalLength = nums1.size() + nums2.size();</span><br><span class="line"><span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getKthElement(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (getKthElement(nums1, nums2, totalLength / <span class="number">2</span>) + getKthElement(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1 = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> myanswer = findMedianSortedArrays(nums1,nums2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myanswer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。</p><p>空间复杂度：O(1)。</p><h2 id="方法二：划分数组（C-）"><a href="#方法二：划分数组（C-）" class="headerlink" title="方法二：划分数组（C++）"></a>方法二：划分数组（C++）</h2><h3 id="通过-2"><a href="#通过-2" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：24 ms, 在所有 C++ 提交中击败了35.62%的用户</span><br><span class="line">内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析-2"><a href="#思路解析-2" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在统计中，中位数被用来：</span><br><span class="line">将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</span><br><span class="line">当一个数组不出现在前一部分时，对应的值为负无穷，就不会对前一部分的最大值产生影响；当一个数组不出现在后一部分时，对应的值为正无穷，就不会对后一部分的最小值产生影响。</span><br></pre></td></tr></table></figure><h3 id="代码如下-2"><a href="#代码如下-2" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = nums1.size();</span><br><span class="line"><span class="keyword">int</span> n = nums2.size();</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = m, ansi = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// median1：前一部分的最大值</span></span><br><span class="line"><span class="comment">// median2：后一部分的最小值</span></span><br><span class="line"><span class="keyword">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line"><span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line"><span class="keyword">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line"><span class="keyword">int</span> nums_im1 = (i == <span class="number">0</span> ? INT_MIN : nums1[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> nums_i = (i == m ? INT_MAX : nums1[i]);</span><br><span class="line"><span class="keyword">int</span> nums_jm1 = (j == <span class="number">0</span> ? INT_MIN : nums2[j - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> nums_j = (j == n ? INT_MAX : nums2[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">ansi = i;</span><br><span class="line">median1 = max(nums_im1, nums_jm1);</span><br><span class="line">median2 = min(nums_i, nums_j);</span><br><span class="line">left = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">right = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1 = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> myanswer = findMedianSortedArrays(nums1,nums2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myanswer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：O(log min(m,n)))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。查找的区间是 [0,m]，而该区间的长度在每次循环之后都会减少为原来的一半。所以，只需要执行 log m 次循环。由于每次循环中的操作次数是常数，所以时间复杂度为 O(log m)。由于我们可能需要交换 nums1 和 nums2 使得 m≤n，因此时间复杂度是 O(log min(m,n)))。</p><p>空间复杂度：O(1)。</p>]]></content>
    
    <summary type="html">
    
      空闲时间刷算法，培养思维。
    
    </summary>
    
    
      <category term="算法提升" scheme="https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="LeetCode" scheme="https://aaronyard.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（二）</title>
    <link href="https://aaronyard.github.io/2020/07/07/LeetCode-2/"/>
    <id>https://aaronyard.github.io/2020/07/07/LeetCode-2/</id>
    <published>2020-07-07T15:39:12.000Z</published>
    <updated>2020-07-07T16:20:22.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串（中等）"><a href="#3-无重复字符的最长子串（中等）" class="headerlink" title="3. 无重复字符的最长子串（中等）"></a>3. 无重复字符的最长子串（中等）</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><h3 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：20  ms, 在所有 C++ 提交中击败了71.14%的用户</span><br><span class="line">内存消耗：7 MB, 在所有 C++ 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设立左指针a和右指针b</span><br><span class="line">b指针向右侧伸缩｛</span><br><span class="line">    对每个A[b]判断是否在之前的数组出现过；</span><br><span class="line">    如果出现，指针a指向出现过的位置的下一个位置；</span><br><span class="line">    更新右指针和最大长度；</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">int</span> size = s.size();</span><br><span class="line">    <span class="keyword">while</span> (end &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> end_word = s[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == end_word) &#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                length = end - start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = length &gt; result ? length : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> input = <span class="string">"abcabcbb"</span>;</span><br><span class="line">    <span class="keyword">int</span> Maxlength = lengthOfLongestSubstring(input);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Maxlength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度O(n^2)，空间复杂度O(1)。</p><h2 id="解法二：hashmap优化时间"><a href="#解法二：hashmap优化时间" class="headerlink" title="解法二：hashmap优化时间"></a>解法二：hashmap优化时间</h2><p>注：map的key存字符，但是value不存什么0或1了。直接存当前的有序下标，解决了多个字母出现的问题。</p><h3 id="通过-1"><a href="#通过-1" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：36  ms, 在所有 C++ 提交中击败了60.40%的用户</span><br><span class="line">内存消耗：8.7 MB, 在所有 C++ 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否出现过时，利用hashmap优化时间。</span><br></pre></td></tr></table></figure><h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s[start,end) 前面包含 后面不包含</span></span><br><span class="line">int start(0), end(0), length(0), result(0);</span><br><span class="line"><span class="keyword">int</span> sSize = <span class="keyword">int</span>(s.size());</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"><span class="keyword">while</span> (end &lt; sSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> tmpChar = s[end];</span><br><span class="line"><span class="comment">//仅当s[start,end) 中存在s[end]时更新start</span></span><br><span class="line"><span class="keyword">if</span> (hash.find(tmpChar) != hash.end() &amp;&amp; hash[tmpChar] &gt;= start)</span><br><span class="line">&#123;</span><br><span class="line">start = hash[tmpChar] + <span class="number">1</span>;</span><br><span class="line">length = end - start;</span><br><span class="line">&#125;</span><br><span class="line">hash[tmpChar] = end;</span><br><span class="line"></span><br><span class="line">end++;</span><br><span class="line">length++;</span><br><span class="line">result = length &gt; result ? length : result;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> input = <span class="string">"abcabcbb"</span>;</span><br><span class="line">    <span class="keyword">int</span> Maxlength = lengthOfLongestSubstring(input);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Maxlength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度O(n)，空间复杂度O(n)。</p><h2 id="解法三：利用数组（桶）代替hashmap"><a href="#解法三：利用数组（桶）代替hashmap" class="headerlink" title="解法三：利用数组（桶）代替hashmap"></a>解法三：利用数组（桶）代替hashmap</h2><h3 id="通过-2"><a href="#通过-2" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：4 ms, 在所有 C++ 提交中击败了99.09%的用户</span><br><span class="line">内存消耗：7.9 MB, 在所有 C++ 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="思路解析-2"><a href="#思路解析-2" class="headerlink" title="思路解析"></a>思路解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否出现过时，利用桶来代替hashmap优化时间。</span><br></pre></td></tr></table></figure><h3 id="代码如下-2"><a href="#代码如下-2" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s[start,end) 前面包含 后面不包含</span></span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="keyword">int</span>(s.size());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">128</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (end &lt; sSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpChar = s[end];</span><br><span class="line">        <span class="comment">//仅当s[start,end) 中存在s[end]时更新start</span></span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="keyword">int</span>(tmpChar)] &gt;= start)</span><br><span class="line">        &#123;</span><br><span class="line">            start = vec[<span class="keyword">int</span>(tmpChar)] + <span class="number">1</span>;</span><br><span class="line">            length = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[<span class="keyword">int</span>(tmpChar)] = end;</span><br><span class="line"></span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = length &gt; result ? length : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> input = <span class="string">"abcabcbb"</span>;</span><br><span class="line">    <span class="keyword">int</span> Maxlength = lengthOfLongestSubstring(input);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Maxlength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度O(n)，空间复杂度O(n)。</p>]]></content>
    
    <summary type="html">
    
      空闲时间刷算法，培养思维。
    
    </summary>
    
    
      <category term="算法提升" scheme="https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="LeetCode" scheme="https://aaronyard.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题（一）</title>
    <link href="https://aaronyard.github.io/2020/07/06/LeetCode-1/"/>
    <id>https://aaronyard.github.io/2020/07/06/LeetCode-1/</id>
    <published>2020-07-06T14:58:26.000Z</published>
    <updated>2020-07-06T15:52:22.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和（简单）"><a href="#1-两数之和（简单）" class="headerlink" title="1. 两数之和（简单）"></a>1. 两数之和（简单）</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回[0, 1]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：12 ms, 在所有 C++ 提交中击败了87.82 %的用户</span><br><span class="line">内存消耗：8.3 MB, 在所有 C++ 提交中击败了100.00 %的用户</span><br></pre></td></tr></table></figure><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m_hash;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_hash.count(nums[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">            result = &#123; i,m_hash[nums[i]] &#125;;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_hash[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123; <span class="number">11</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">7</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b = twoSum(a, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>我们可以通过遍历一次哈希表完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>– 时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p><p>– 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p><h1 id="2-两数相加（中等）"><a href="#2-两数相加（中等）" class="headerlink" title="2. 两数相加（中等）"></a>2. 两数相加（中等）</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h2 id="代码如下（解法一）"><a href="#代码如下（解法一）" class="headerlink" title="代码如下（解法一）"></a>代码如下（解法一）</h2><h3 id="通过-1"><a href="#通过-1" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：36 ms, 在所有 C++ 提交中击败了55.53 %的用户</span><br><span class="line">内存消耗：9.3 MB, 在所有 C++ 提交中击败了100.00 %的用户</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    ListNode* result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    result-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* cur = result-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span> || carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>)l1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)l2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        cur-&gt;val = (l1-&gt;val + l2-&gt;val+ carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l1-&gt;val + l2-&gt;val + carry) / <span class="number">10</span>;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span> || carry) &#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* a1 =  <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    a1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    a1-&gt;next-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode* a2 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    a2-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">    a2-&gt;next-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode* b = addTwoNumbers(a1,a2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码如下（解法二）"><a href="#代码如下（解法二）" class="headerlink" title="代码如下（解法二）"></a>代码如下（解法二）</h2><h3 id="通过-2"><a href="#通过-2" class="headerlink" title="通过"></a>通过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：24 ms, 在所有 C++ 提交中击败了97.43 %的用户</span><br><span class="line">内存消耗：8.6 MB, 在所有 C++ 提交中击败了100.00 %的用户</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers2</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    ListNode* t1 = l1, * t2 = l2;</span><br><span class="line">    <span class="keyword">while</span> (t1-&gt;next != <span class="literal">NULL</span> &amp;&amp; t2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = (t1-&gt;val + t2-&gt;val + c) / <span class="number">10</span>;</span><br><span class="line">        t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % <span class="number">10</span>;</span><br><span class="line">        c = temp;</span><br><span class="line">        t1 = t1-&gt;next;</span><br><span class="line">        t2 = t2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1-&gt;next == <span class="literal">NULL</span> &amp;&amp; t2-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = t1-&gt;val + t2-&gt;val + c;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">9</span>)</span><br><span class="line">            t1-&gt;next = <span class="keyword">new</span> ListNode(temp / <span class="number">10</span>);</span><br><span class="line">        t1-&gt;val = temp % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            t1-&gt;next = t2-&gt;next;</span><br><span class="line">        temp = (t1-&gt;val + t2-&gt;val + c) / <span class="number">10</span>;</span><br><span class="line">        t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % <span class="number">10</span>;</span><br><span class="line">        c = temp;</span><br><span class="line">        t1 = t1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span> &amp;&amp; t1-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = t1-&gt;val + c;</span><br><span class="line">            t1-&gt;val = temp % <span class="number">10</span>;</span><br><span class="line">            c = temp / <span class="number">10</span>;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1-&gt;val + c &gt; <span class="number">9</span>)</span><br><span class="line">                t1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            t1-&gt;val = (t1-&gt;val + c) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* a1 =  <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    a1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    a1-&gt;next-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode* a2 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    a2-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">    a2-&gt;next-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode* b = addTwoNumbers(a1,a2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><p>就像在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。</p><p>伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 将当前结点初始化为返回列表的哑结点。</span><br><span class="line">- 将进位 carry 初始化为 0。</span><br><span class="line">- 将 p 和 q 分别初始化为列表 l1 和 l2 的头部。</span><br><span class="line">- 遍历列表 l1 和 l2 直至到达它们的尾端。</span><br><span class="line">--- 将 xx 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。</span><br><span class="line">--- 将 yy 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。</span><br><span class="line">--- 设定 sum = x + y + carry。</span><br><span class="line">--- 更新进位的值，carry = sum / 10。</span><br><span class="line">--- 创建一个数值为 (sum mod 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</span><br><span class="line">--- 同时，将 pp 和 qq 前进到下一个结点。</span><br><span class="line">- 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。</span><br><span class="line">- 返回哑结点的下一个结点。</span><br></pre></td></tr></table></figure><p>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><h4 id="注意陷阱：若只考虑三位数相加，那么会出现val-l1-gt-val-l2-gt-val-carry-10，但这样是错的，还要考虑5-5-10以及99-1-100等情况，则val-l1-gt-val-l2-gt-val-carry-10才是对的。"><a href="#注意陷阱：若只考虑三位数相加，那么会出现val-l1-gt-val-l2-gt-val-carry-10，但这样是错的，还要考虑5-5-10以及99-1-100等情况，则val-l1-gt-val-l2-gt-val-carry-10才是对的。" class="headerlink" title="注意陷阱：若只考虑三位数相加，那么会出现val = (l1-&gt;val +l2-&gt;val) + carry / 10，但这样是错的，还要考虑5 + 5 = 10以及99 + 1 = 100等情况，则val = (l1-&gt;val +l2-&gt;val + carry) / 10才是对的。"></a>注意陷阱：若只考虑三位数相加，那么会出现val = (l1-&gt;val +l2-&gt;val) + carry / 10，但这样是错的，还要考虑5 + 5 = 10以及99 + 1 = 100等情况，则val = (l1-&gt;val +l2-&gt;val + carry) / 10才是对的。</h4><h3 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>– 时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n) 次。</p><p>– 空间复杂度：O(max(m, n))， 新列表的长度最多为 max(m,n)+1。</p>]]></content>
    
    <summary type="html">
    
      空闲时间刷算法，培养思维。
    
    </summary>
    
    
      <category term="算法提升" scheme="https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="LeetCode" scheme="https://aaronyard.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>游戏项目中的AI</title>
    <link href="https://aaronyard.github.io/2020/04/13/GameAI/"/>
    <id>https://aaronyard.github.io/2020/04/13/GameAI/</id>
    <published>2020-04-13T04:52:53.000Z</published>
    <updated>2020-07-05T02:47:53.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目中的AI"><a href="#项目中的AI" class="headerlink" title="项目中的AI"></a>项目中的AI</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在游戏开发中实现怪物AI逻辑的主要技术有两种：1、状态机 2、行为树。他们两者的实现机制不一样，其中状态机是“事件”机制，行为树是“轮询”机制。在项目开发中可以根据具体情况合理的选择两者来处理AI编写问题。</p><p>接下来将分两个部分对游戏中的AI进行讲解，1、状态机，2、行为树。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。</p><p>知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。</p><a id="more"></a><p>在行为系统中，有限状态机（FSM，Finite State Machine）最为经典，FSM模型的优势之一是简单。但是FSMs需要用转换（Transition）连接状态（State），因此，状态（State）失去了模块性（Modularity）。</p><p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构：</p><p>对于FSM，每个节点表示一个状态，而对于BT，每个节点表示一个行为。同样是由节点连接而成，BT有什么优势呢？</p><p>在BT中，节点是有层次（Hierarchical）的，子节点由其父节点来控制。每个节点的执行都有一个结果（成功Success，失败Failure或运行Running），该节点的执行结果都由其父节点来管理，从而决定接下来做什么，父节点的类型决定了不同的控制类型。节点不需要维护向其他节点的转换，节点的模块性（Modularity）被大大增强了。实际上，在BT里，由于节点不再有转换，它们不再是状态（State），而是行为（Behavior）。</p><h3 id="第一种-有限状态机"><a href="#第一种-有限状态机" class="headerlink" title="第一种-有限状态机"></a>第一种-有限状态机</h3><p>1、有限状态机（FSM）的实现方式有三种：</p><p>面向过程的方式的if else<br>用枚举配合switch case语句。<br>用多态与虚函数（也就是状态模式）</p><p>2、状态模式的经典定义：允许对象在当内部状态改变是改变其行为，就好像对象改变了自己的类一样。</p><p>3、状态模式的实现分为三个要点：</p><ul><li>为状态定义一个接口</li><li>为每个状态定义一个类</li><li>恰当地进行状态委托</li></ul><p>4、通常来说，状态模式中状态对象的存放有两种实现存放思路:</p><p>静态状态。初始化时把所有可能的状态都new好，状态切换时通过赋值改变当前的状态<br>实例化状态。每次切换状态时动态new出新的状态。</p><p>关于FSM的具体案例如下：</p><p>1、Unity的Mecanim动画系统就是通过状态模式来实现的</p><p>2、一个简单的战斗过程的状态机，如果用状态模式实现他的攻击逻辑就非常的方便，而且支持后期状态的扩展。</p><p>总结：状态模式暂时没有找到好的开源框架，但是状态模式不仅仅在AI方面使用，在游戏的框架中也被广泛使用，比如：UI框架，游戏主逻辑状态框架等等。</p><h3 id="第二种-行为树"><a href="#第二种-行为树" class="headerlink" title="第二种-行为树"></a>第二种-行为树</h3><h4 id="什么是行为树"><a href="#什么是行为树" class="headerlink" title="什么是行为树"></a>什么是行为树</h4><p>如果了解过状态机，会知道在行为树之前，在实现AI用得比较多的技术是状态机，状态机理解起来是比较简单的，即一个状态过渡到另一个状态，通过判断将角色的状态改变即可，如果学习过Unity的Mecanim动画系统，会更加直观的理解。但是状态机在状态较多的情况下会使状态之间的切换变得异常繁琐，同时状态之间很难复用。在这种情况下，行为树被发明出来，行为树的优点如下：</p><p>1、行为树提供大量的流程控制方法，使得状态之间的改变更加直观；</p><p>2、整个游戏AI使用树型结构，方便查看与编辑；</p><p>3、方便调试和代码编写；</p><p>4、更好的封装性和模块性，让游戏逻辑更直观，开发者不会被那些复杂的连线绕晕。</p><p>5、最重要的：行为树方便制作编辑器，可以交由策划人员使用；</p><h4 id="行为树的基本概念："><a href="#行为树的基本概念：" class="headerlink" title="行为树的基本概念："></a>行为树的基本概念：</h4><p>1、执行每个节点都会有一个结果（成功，失败或运行）</p><p>2、子节点的执行结果由其父节点控制和管理</p><p>3、返回运行结果的节点被视作处于运行状态，处于运行状态的节点将被持续执行一直到其返回结束（成功或失败）。在其结束前，其父节点不会把控制转移到后续节点。</p><h4 id="行为树原理"><a href="#行为树原理" class="headerlink" title="行为树原理"></a>行为树原理</h4><p>行为树是一种树形结构，所以其可以分成3种节点类型：</p><p>1、红色的节点：根节点，没有父节点的节点；</p><p>2、蓝色的节点：组合节点，有父节点和子节点的节点；</p><p>3、白色的节点：叶节点，没有子节点的节点；</p><h4 id="节点的返回"><a href="#节点的返回" class="headerlink" title="节点的返回"></a>节点的返回</h4><p>每个节点都会有一个返回值，可能出现的返回值有3个，如下：</p><p>1、运行中：表示当前节点还在运行中，下一次调用行为树时任然运行当前节点；</p><p>2、失败：表示当前节点运行失败；</p><p>3、成功：表示当前节点运行成功；</p><p>下面我们来细说一下这几个节点：</p><h5 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h5><p>行为树的入口节点，可以是任意类型的节点；</p><h5 id="组合节点"><a href="#组合节点" class="headerlink" title="组合节点"></a>组合节点</h5><p>行为树的组合节点是由下面几种类型来组成的：</p><h6 id="1、选择节点-优先选择节点（Selector）"><a href="#1、选择节点-优先选择节点（Selector）" class="headerlink" title="1、选择节点/优先选择节点（Selector）"></a>1、选择节点/优先选择节点（Selector）</h6><p>该节点会从左到右的依次执行其子节点，只要子节点返回“失败”，就继续执行后面的节点，直到有一个节点返回“运行中”或“成功”时，会停止后续节点的运行，并且向父节点返回“运行中”或“成功”，如果所有子节点都返回“失败”则向父节点返回“失败”。</p><h6 id="2、随机选择节点（Random-Selector）"><a href="#2、随机选择节点（Random-Selector）" class="headerlink" title="2、随机选择节点（Random Selector）"></a>2、随机选择节点（Random Selector）</h6><p>之前的选择节点是有优先级顺序的，而随机选择节点的执行顺序是随机的。但每个节点只会执行一次，比如包含子节点：A、B、C、D、E；使用随机选择节点，执行顺序可能是：D、E、A、C、B或其他组合。其它规则同选择节点一致。</p><h6 id="3、顺序节点（Sequence）"><a href="#3、顺序节点（Sequence）" class="headerlink" title="3、顺序节点（Sequence）"></a>3、顺序节点（Sequence）</h6><p>该节点会从左到右的依次执行其子节点，只要子节点返回“成功”，就继续执行后面的节点，直到有一个节点返回“运行中”或“失败”时，会停止后续节点的运行，并且向父节点返回“运行中”或“失败”，如果所有子节点都返回“成功”则向父节点返回“成功”。</p><h6 id="4、修饰节点（Decorator）"><a href="#4、修饰节点（Decorator）" class="headerlink" title="4、修饰节点（Decorator）"></a>4、修饰节点（Decorator）</h6><p>修饰节点只包含一个子节点，用来以某种方式来改变这个子节点的行为。修饰节点的类型比较多，这里我们说一些比较常见的修饰节点：</p><p>① Until Success和Until Failure</p><p>循环执行子节点，直到返回“成功”或“失败”为止。</p><p>比如Until Success在子节点返回“运行中”和“失败”时都会向父节点返回“运行中”，返回“成功”时向父节点返回“成功”。</p><p>Until Failure在子节点返回“运行中”和“成功”时都会向父节点返回“运行中”，返回“失败”时向父节点返回“成功”。</p><p>② Limit</p><p>执行子节点一定次数后强制返回“失败”。当子节点运行指定次数后还没有返回“失败”则该节点向父节点返回失败。</p><p>③ Timer</p><p>子节点不会立即执行，而会在指定的时间到达后才开始执行。</p><p>④ TimeLimit</p><p>指定子节点的最长运行时间，如果子节点在指定时间到达后还在运行则强制返回“失败”。</p><p>⑤ Invert</p><p>对子节点的返回结果取“非”，即子节点返回“成功”则该节点返回“失败”，子节点返回“失败”则该节点返回成功。</p><h6 id="5、并行节点（Parallel）"><a href="#5、并行节点（Parallel）" class="headerlink" title="5、并行节点（Parallel）"></a>5、并行节点（Parallel）</h6><p>不同于选择和顺序节点依次执行每个节点，并行节点是“同时”执行所有的节点，然后根据所有节点的返回值判断最终返回的结果。</p><p>这里的“同时”会迷惑住不少人，实际上，行为树是运行在单一线程上的，并不会在并行节点上开多个线程来进行真正的同时执行，那么“同时”的含义是什么？</p><p>我们知道选择或顺序节点会依次执行所有的子节点，当子节点返回“成功”或“失败”后就会停止后续节点的执行，而并行节点也会依次执行所有的子节点，无论子节点返回“成功”或“失败”都会继续运行后续节点，保证所有子节点都得到运行后在根据每个子节点的返回值来确定最终的返回结果。</p><p>并行节点一般可以设定退出该节点的条件，比如：</p><p>1、当全部节点都返回成功时退出；</p><p>2、当某一个节点返回成功时退出；</p><p>3、当全部节点都返回成功或失败时退出；</p><p>4、当某一个节点返回成功或失败时退出；</p><p>5、当全部节点都返回失败时退出；</p><p>6、当某一个节点返回失败时退出；</p><h4 id="叶节点"><a href="#叶节点" class="headerlink" title="叶节点"></a>叶节点</h4><h5 id="1、条件节点（Condition）"><a href="#1、条件节点（Condition）" class="headerlink" title="1、条件节点（Condition）"></a>1、条件节点（Condition）</h5><p>条件节点可以理解为一个if判断语句，当条件的测试结果为true时向父节点传递success，结果为false时向父节点传递failure；</p><p>该节点搭配一些组合节点可以完成各种判断跳转，比如搭配顺序节点，可以做出“是否看见敌人”-&gt;“向敌人开火”的AI；</p><h5 id="2、行为节点（Action）"><a href="#2、行为节点（Action）" class="headerlink" title="2、行为节点（Action）"></a>2、行为节点（Action）</h5><p>行为节点用来完成具体的操作，比如，移动到目标点，执行开火等代码逻辑，多种情况下行为节点会返回running和success；行为节点也可能会使用多帧来完成；</p><h4 id="子树的复用"><a href="#子树的复用" class="headerlink" title="子树的复用"></a>子树的复用</h4><p>我们设计好的行为树可以在其他树中作为一颗子树来进行使用，最大可能的复用子树可以减少开发量。</p><p>总结：行为树的框架，网上有比较好的案例，如腾讯开源的behaviac。</p><p>Github地址：github.com/Tencent</p>]]></content>
    
    <summary type="html">
    
      带领你了解已上线的3D游戏项目
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="3D Client" scheme="https://aaronyard.github.io/tags/3D-Client/"/>
    
  </entry>
  
  <entry>
    <title>游戏项目中的事件系统</title>
    <link href="https://aaronyard.github.io/2020/04/11/GameEventSys/"/>
    <id>https://aaronyard.github.io/2020/04/11/GameEventSys/</id>
    <published>2020-04-11T13:52:53.000Z</published>
    <updated>2020-04-13T11:13:10.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目中的事件系统"><a href="#项目中的事件系统" class="headerlink" title="项目中的事件系统"></a>项目中的事件系统</h2><p>成熟的项目中对自己的事件都会进行封装，使得过程透明，使用者不必去了解其构成，只需要关心分发出来的事件，而事件的发出者也不关心谁会用到，只需要将事件发出即可。事件系统维系着项目中所有事件的分发，将游戏逻辑解耦，使得项目逻辑清晰，代码简单易懂。</p><p>通常事件系统并不复杂，反而很简单，包含了三个核心的方法：</p><ul><li><p>注册 AddHander</p></li><li><p>注销 RemoveHander</p></li><li><p>发送 SendEvent</p></li></ul><a id="more"></a><p>使用枚举来作为事件类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EEventType&#123;&#125;</span><br></pre></td></tr></table></figure><p>事件是基于委托的，一个事件对应于多个委托delegate，利用委托的性质，事件系统将更加的简单明了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//委托 事件的回调 对应于事件的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventSysCallBack</span>(<span class="params">EEventType eventId, <span class="keyword">object</span> param1, <span class="keyword">object</span> param2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventSysCallBack_</span>(<span class="params"><span class="keyword">uint</span> eventId, <span class="keyword">object</span> param1, <span class="keyword">object</span> param2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EmptyCallBack</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>事件类的数据结构定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventParamData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> EEventType m_eventId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">object</span> m_param1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">object</span> m_param2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventParamData</span>(<span class="params">EEventType eventId, <span class="keyword">object</span> param1, <span class="keyword">object</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_eventId = eventId;</span><br><span class="line">m_param1 = param1;</span><br><span class="line">m_param2 = param2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EEventType <span class="title">GetEventId</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> m_eventId; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">GetParam1</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> m_param1; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">GetParam2</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> m_param2; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是对于事件系统类EventSys的实现，整个系统继承于ISystem，ISystem继承于MonoBehaviour。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ISystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BaseReset</span>(<span class="params"></span>)</span> &#123; Reset(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SysUpdate</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SysLateUpdate</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SysFixedUpdate</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">bool</span> m_isControlUpdate = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> _m_randomNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> m_randomNum</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123; <span class="keyword">return</span> _m_randomNum; &#125;</span><br><span class="line"><span class="keyword">set</span>&#123; _m_randomNum = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ISystem类中有两个虚方法需要在EventSys中实现，这两个虚方法分别是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SysUpdate</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>事件系统中的事件是一个队列Queue，对列中存放的是一个EventParamData类型的数据，在每次执行SysUpdate的时候对队列中的所有元素执行出队操作，及时向其它系统发送事件，有新事件的时候执行入队操作，在注销事件时删除队列内相关的事件。为确保同一时间内能完整的运行完同一套事件，故而对事件加锁Lock，保证线程安全。</p><h2 id="具体的代码如下"><a href="#具体的代码如下" class="headerlink" title="具体的代码如下"></a>具体的代码如下</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSys</span> : <span class="title">ISystem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String ms_lock = <span class="string">"lock"</span>;</span><br><span class="line"><span class="keyword">private</span> List&lt;EventSysCallBack&gt; m_allHander = <span class="keyword">new</span> List&lt;EventSysCallBack&gt; ();</span><br><span class="line">    <span class="keyword">private</span> List&lt;EventSysCallBack&gt;[] m_eventArray = <span class="keyword">new</span> List&lt;EventSysCallBack&gt;[(<span class="keyword">int</span>)EEventType.Count];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m_eventNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Queue m_eventQueue = <span class="keyword">new</span> Queue();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventSys Instance = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">bool</span> m_hasInit = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_hasInit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_hasInit = <span class="literal">true</span>;</span><br><span class="line">m_eventQueue.Clear();</span><br><span class="line">Instance = <span class="keyword">this</span>;</span><br><span class="line">        m_eventNum = (<span class="keyword">int</span>)EEventType.Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SysUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">lock</span> (ms_lock) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (m_eventQueue.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">EventParamData data = m_eventQueue.Dequeue() <span class="keyword">as</span> EventParamData;</span><br><span class="line">EEventType eventId = data.GetEventId();</span><br><span class="line">SendEvent(eventId, data.GetParam1(), data.GetParam2());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAllHander</span>(<span class="params">EventSysCallBack callBack</span>)</span> &#123;</span><br><span class="line"><span class="keyword">lock</span> (ms_lock) &#123;</span><br><span class="line">m_allHander.Add (callBack);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUintHander</span>(<span class="params"><span class="keyword">uint</span> eventid, <span class="keyword">object</span> instance, EventSysCallBack_ callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddHander((EEventType)eventid, (EEventType eventType, <span class="keyword">object</span> param1, <span class="keyword">object</span> param2) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            callBack((<span class="keyword">uint</span>)eventType, param1, param2);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddHander</span>(<span class="params">EEventType eventId, EventSysCallBack callBack</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">lock</span> (ms_lock)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)eventId &lt; m_eventNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> eventList = m_eventArray[(<span class="keyword">int</span>)eventId];</span><br><span class="line">                <span class="keyword">if</span> (eventList != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = eventList.Count;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(callBack == eventList[i])</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventList.Add(callBack);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">List&lt;EventSysCallBack&gt; t = <span class="keyword">new</span> List&lt;EventSysCallBack&gt;();</span><br><span class="line">t.Add(callBack);</span><br><span class="line">            m_eventArray[(<span class="keyword">int</span>)eventId] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveHander</span>(<span class="params"><span class="keyword">object</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">lock</span> (ms_lock)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m_eventNum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> eventList = m_eventArray[i];</span><br><span class="line">                <span class="keyword">if</span> (eventList != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> eventCount = eventList.Count;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = eventCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(target == eventList[j].Target)</span><br><span class="line">                        &#123;</span><br><span class="line">                            eventList.RemoveAt(j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEvent</span>(<span class="params">EEventType eventId, <span class="keyword">object</span> param1=<span class="literal">null</span>, <span class="keyword">object</span> param2=<span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">lock</span> (ms_lock) </span><br><span class="line">&#123;</span><br><span class="line">m_eventQueue.Enqueue( <span class="keyword">new</span> EventParamData(eventId, param1, param2 ) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUintEvent</span>(<span class="params"><span class="keyword">uint</span> eventId, <span class="keyword">object</span> param1 = <span class="literal">null</span>, <span class="keyword">object</span> param2 = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddEvent((EEventType)eventId, param1, param2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数只能在主线程调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEventNow</span>(<span class="params">EEventType eventId, <span class="keyword">object</span> param1=<span class="literal">null</span>, <span class="keyword">object</span> param2=<span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SendEvent (eventId, param1, param2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUintEventNow</span>(<span class="params"><span class="keyword">uint</span> eventId, <span class="keyword">object</span> param1 = <span class="literal">null</span>, <span class="keyword">object</span> param2 = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddEventNow((EEventType)eventId, param1, param2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SendEvent</span>(<span class="params">EEventType eventId, <span class="keyword">object</span> param1, <span class="keyword">object</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_allHander.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_allHander[i](eventId, param1, param2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                CNetSys.Instance.SendImportantLogWithBugly(<span class="literal">true</span>, <span class="string">"[Exception]"</span> + e.ToString());</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetIndex = (<span class="keyword">int</span>)eventId;</span><br><span class="line">        <span class="keyword">if</span>(targetIndex &lt; m_eventNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> eventList = m_eventArray[targetIndex];</span><br><span class="line">            <span class="keyword">if</span>(eventList != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = eventList.Count;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(eventList != <span class="literal">null</span> &amp;&amp; i &lt; eventList.Count)</span><br><span class="line">                        &#123;</span><br><span class="line">                            eventList[i](eventId, param1, param2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (System.Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        CNetSys.Instance.SendImportantLogWithBugly(<span class="literal">true</span>, <span class="string">"[Exception]"</span> + e.ToString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>业务逻辑需要发事件时，调用AddEvent(…)接口，当下一帧到来，sysupdata(…)方法执行，事件被SendEvent(…)发送出去，设置了AddHander(…)的业务逻辑回调就会触发，进行相关的逻辑操作。</p>]]></content>
    
    <summary type="html">
    
      带领你了解已上线的3D游戏项目
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="3D Client" scheme="https://aaronyard.github.io/tags/3D-Client/"/>
    
  </entry>
  
  <entry>
    <title>游戏项目中的全自动打包机制</title>
    <link href="https://aaronyard.github.io/2020/04/06/AutomaticPackaging/"/>
    <id>https://aaronyard.github.io/2020/04/06/AutomaticPackaging/</id>
    <published>2020-04-06T07:27:18.000Z</published>
    <updated>2020-04-06T12:08:51.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目中的全自动打包机制"><a href="#项目中的全自动打包机制" class="headerlink" title="项目中的全自动打包机制"></a>项目中的全自动打包机制</h2><p>大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。</p><p>实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。</p><p>商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。</p><p>由此，抽象出了一整套自动化打包流程。</p><a id="more"></a><h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><p>1、各个渠道的sdk资源按渠道分类至各个渠道文件夹中，包括这个渠道打包所需要的【AndroidManife.xml、res、so、jar包、java代码】（Android）或【framework、.a文件、InfoPlisst、蕴含生命周期的UnityAppController.mm/AppDelegate.m文件】（ios）等资源文件。</p><p>2、一台单独打包机器（资金充足的话建议单独配打包机器），建议用MAC机，因为ios包只能用MAC机来打，而MAC机还能打安卓apk。</p><p>3、Jenkins，一个开源的可拓展的自动化服务器，关于Jenkins可以单独拿出来将一篇文章了，再此简单的说一下Jenkins的持续集成流程：提交代码–&gt;拉取代码–&gt;编译–&gt;打包–&gt;测试–&gt;反馈问题–&gt;开发处理–&gt;提交代码，从这一流程就可以窥探到Jenkins的便利。</p><p>4、打包所用的脚本：build.bat或者build.sh脚本。</p><p>5、unity项目代码中可供打包脚本调用的打包相关静态方法。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>1、Jenkins中Build with Parameters里输入相应的打包参数，坐等打包完成，打包过程对你来说是透明的，完毕…哈哈，开个玩笑，接下用最通俗的语言带你揭秘打包流程。</p><p>2、全自动化打包流程最重要的在于打包脚本，接收到你的输入参数后开始工作，首先覆盖平台相关资源，其次拉取svn到指定版本，然后再将将指定平台写入代码中，最后关闭打包机上unity和资源管理器窗口。关闭unity尤为重要，不然unity会以进程被占用为由告诉你打包失败。</p><p>3、设置Unity宏定义，表明这个包是某个渠道的宏定义。</p><p>4、设置游戏版本号，便于后期维护发热更新。</p><p>5、构建游戏Aesstbundle资源：调用打包代码，构建资源输出到指定目录，将资源打成压缩包输出到resource目录下。</p><p>6、构建游戏安装包。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>build.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define var</span></span><br><span class="line"></span><br><span class="line">UnityCmd=/Applications/Unity/Unity.app/Contents/MacOS/Unity </span><br><span class="line">CurrentPath=$(cd `(dirname $0)`; pwd)</span><br><span class="line">PROJECTHOME=$&#123;CurrentPath&#125;/../</span><br><span class="line">FUNCTION_NAME=""</span><br><span class="line">BUILDHOME=""</span><br><span class="line">APP_NAME=""</span><br><span class="line"></span><br><span class="line">cmdBuildAB="$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod BuildEditor.BuildAndroidAB"</span><br><span class="line"><span class="meta">$</span><span class="bash">cmdBuildAB</span></span><br><span class="line"></span><br><span class="line">cmd="$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod AutoBuild.$&#123;FUNCTION_NAME&#125; -outPath $&#123;BUILDHOME&#125;/$&#123;APP_NAME&#125; -logFile"</span><br><span class="line"><span class="meta">$</span><span class="bash">cmd</span></span><br></pre></td></tr></table></figure><p>C#静态方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打AssetBundle</span></span><br><span class="line"><span class="comment">//state  0:apk 1: ios: 2: editor 3:iOS不压缩ab 4:不挪动UI 5:GOOGLE OBB</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAssetBundle</span>(<span class="params"><span class="keyword">int</span> state</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DirectoryInfo direc = <span class="keyword">new</span> DirectoryInfo(Application.streamingAssetsPath + <span class="string">"/AssetsBundle"</span>);</span><br><span class="line"><span class="keyword">if</span> (direc.Exists)</span><br><span class="line">&#123;</span><br><span class="line">direc.Delete(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_abDataLs.list.Clear();</span><br><span class="line"></span><br><span class="line">m_options  = BuildAssetBundleOptions.CollectDependencies;</span><br><span class="line"><span class="keyword">if</span>(state == <span class="number">0</span> || state == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle;</span><br><span class="line">m_target = BuildTarget.Android;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle;</span><br><span class="line"><span class="keyword">if</span>(state == <span class="number">1</span> || state == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_target = BuildTarget.iPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_target = BuildTarget.StandaloneWindows;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">0</span> || state == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//移动打包资源</span></span><br><span class="line">AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName);</span><br><span class="line">AutoBuild.MoveUIResToTemp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//移除一部分资源去打obb包</span></span><br><span class="line">AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileNameObb, AutoBuild.DirecPrefabFileNameObb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">3</span> || state == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只移动Resource/Prefab</span></span><br><span class="line">AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打AssetBundle</span></span><br><span class="line">BuildAB(state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//压缩AssetBundle</span></span><br><span class="line">AssetBundleCompress();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打apk</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Build_Apk</span>(<span class="params"><span class="keyword">int</span> XXqudao</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, <span class="string">"PLAT_SDK_XXqudao"</span>);</span><br><span class="line">PlayerSettings.bundleIdentifier = <span class="string">"com.xxx.xxx.xxx"</span>;</span><br><span class="line">BuildAndroid(XXqudao);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动相关的资源</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAndroid</span>(<span class="params"><span class="keyword">int</span> XXqudao</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//移动相关平台sdk资源文件夹</span></span><br><span class="line">MovePluginDir(XXqudao);</span><br><span class="line"><span class="comment">//替换一些DLL文件</span></span><br><span class="line">ReplaceDll(<span class="string">"Android"</span>, <span class="string">"DLL"</span>);</span><br><span class="line"><span class="comment">//替换一些包体内需要用到的图片icon文件</span></span><br><span class="line">ReplaceLoadingImage(XXqudao);</span><br><span class="line"><span class="comment">//开始build</span></span><br><span class="line">BuildPlayerOptions buildPlayerOptions = <span class="keyword">new</span> BuildPlayerOptions();</span><br><span class="line">buildPlayerOptions.scenes = <span class="keyword">new</span>[] &#123; <span class="string">"Assets/Scene1.unity"</span>, <span class="string">"Assets/Scene2.unity"</span> &#125;;</span><br><span class="line">buildPlayerOptions.locationPathName = m_outPath;</span><br><span class="line">buildPlayerOptions.target = BuildTarget.Android;</span><br><span class="line">buildPlayerOptions.options = BuildOptions.None;</span><br><span class="line"></span><br><span class="line">BuildReport report = BuildPipeline.BuildPlayer(buildPlayerOptions);</span><br><span class="line">BuildSummary summary = report.summary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (summary.result == BuildResult.Succeeded)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">"Build succeeded: "</span> + summary.totalSize + <span class="string">" bytes"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (summary.result == BuildResult.Failed)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">"Build failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将editor使用的DLL恢复</span></span><br><span class="line">RecoveryDll(<span class="string">"DLL"</span>);</span><br><span class="line"><span class="comment">//恢复sdk资源文件夹</span></span><br><span class="line">RecoveryPluginDir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这里只是提供一个大体的思路，实际上在自动化流程中还是有很多大大小小的坎坷的，比如一些已经成形的项目，其项目目录结构需要单独进行适配，一些渠道打包需要单独进行调整等，这些都是要考虑到的。</p><p>关于sdk：建议单独分出一个集成sdk的部门，用于将各个渠道的sdk集成到一个主的sdk上，游戏项目只需要接入一个sdk即可，使得sdk接入工作透明化，游戏开发人员专注于游戏业务逻辑的开发，更加高效。</p>]]></content>
    
    <summary type="html">
    
      带领你了解已上线的3D游戏项目
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="3D Client" scheme="https://aaronyard.github.io/tags/3D-Client/"/>
    
  </entry>
  
  <entry>
    <title>游戏项目中的小包更新机制</title>
    <link href="https://aaronyard.github.io/2020/04/05/AssetsPackage/"/>
    <id>https://aaronyard.github.io/2020/04/05/AssetsPackage/</id>
    <published>2020-04-05T12:21:28.000Z</published>
    <updated>2020-04-07T04:21:52.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目中的小包更新机制"><a href="#项目中的小包更新机制" class="headerlink" title="项目中的小包更新机制"></a>项目中的小包更新机制</h2><p>大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。</p><p>如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\sdk\tools\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。</p><p>另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考：</p><a id="more"></a><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>没有一个官方的名字，姑且叫它强制小包法叭。</p><p>在打apk的时候，将游戏用到的代码、闪屏图、loading图、主场景、登录场景、表格、开场动画等最基本的资源提前准备好，在打包时替换进去，这样包体不会很大，玩家所需的拓展资源则通过项目里的热更新机制加载。</p><p>这个方法有一个缺点，由于包体内所携带的资源并不完整，只能保证游戏可以运行不会崩溃，更多的功能资源包则需要在登录游戏之前下载。若热更新较大则会“吓跑”一些新玩家（不成文规定：新发布游戏的热更新包体宜小于30M），为了减少这一影响，第二种补充方案应运而生了。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>游戏内小包资源法，作为方案一的补充，它对玩家更友好。</p><p>将项目内容分为必须功能和非必须功能，如玩家信息系统、公告系统、技能系统、排行榜系统、基本的新手任务系统以及主城场景等游戏正常运行所必须的或占资源不多的功能系统可以统一将预制图集资源打进包里。但是类似宠物系统、武将系统、野怪系统等占用较多预制资源分类打进AB小包中，用一个json文件来管理资源列表。</p><p>在loading主场景的时候，异步检测线上小包资源的json配置是否存在，若存在且为wifi环境则异步下载资源并解压预加载，主界面也会显示相应的窗口。若玩家当前网络环境不满足下载资源的要求，则会在非必须的功能入口处做出限制，告知需要加载资源包才能体验完整的游戏功能，并且会在加载完毕资源后给予一定的奖励。</p><p>这样玩家在初始阶段流失的相应较少，体验更佳，对玩家更为友好。</p><h2 id="热更新机制"><a href="#热更新机制" class="headerlink" title="热更新机制"></a>热更新机制</h2><p>热更新机制已经在另一篇文章中详细阐述了，再此就不重复介绍了。–&gt;<a href="https://www.aaronyard.top/2019/11/30/GameUpdate/" target="_blank" rel="noopener">热更新机制</a></p><h2 id="游戏内小包资源法"><a href="#游戏内小包资源法" class="headerlink" title="游戏内小包资源法"></a>游戏内小包资源法</h2><p>1、小包有对应的资源版本号，在游戏打包前设定相应的资源版本号，而在拉取小包资源的时候也是以资源版本号作为索引去寻找相应的json配置文件。</p><p>2、商业游戏最重要的是游戏安全，可以在写入json配置文件列表的脚本中加入相应的文件大小及MD5等信息作为校验，这样就不会轻易被第三方非法修改。</p><p>3、在小包解压时，有概率会出现一些文件解压失败，损失一部分资源，或者玩家不小心删掉了一些资源文件，这个时候在重新下载所有小包资源就不明智了。在游戏中给玩家提供一个主动校验资源的功能，根据现有资源文件名遍历json配置资源列表来寻找需要缺失的文件，异步下载并解压。</p><p>4、游戏内小包资源法与热更新机制在本质上是一样的，都是通过unity的AssetBundle加载机制来实现的。</p><h4 id="小包资源的加载状态"><a href="#小包资源的加载状态" class="headerlink" title="小包资源的加载状态"></a>小包资源的加载状态</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AssetsPackageState</span><br><span class="line">&#123;</span><br><span class="line">    None,<span class="comment">//初始状态，最初的未加载状态</span></span><br><span class="line">    ReadFileEnd,<span class="comment">//读取完json配置文件</span></span><br><span class="line">    DownLoadStart,<span class="comment">//开始下载josn文件列表中的小包资源文件</span></span><br><span class="line">    DownLoadStop,<span class="comment">//暂停下载josn文件列表中的小包资源文件，并保存当前的下载进度</span></span><br><span class="line">    DownLoadComplete,<span class="comment">//小包资源下载完成</span></span><br><span class="line">    DecompressStart,<span class="comment">//小包资源开始解压</span></span><br><span class="line">    DecompresFail,<span class="comment">//小包资源解压失败</span></span><br><span class="line">    AssetsReady,<span class="comment">//资源校验已准备好</span></span><br><span class="line">    AssetsCheck,<span class="comment">//资源校验中（成功时会通过回调告知玩家校验结果）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无感知下载小包资源"><a href="#无感知下载小包资源" class="headerlink" title="无感知下载小包资源"></a>无感知下载小包资源</h4><p>在加载进入主主场景时，检测是否需要加载资源，根据网络环境并自动加载,代码流程大致如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化检测功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CheckInitDownLoad</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//不是初始化状态，说明进入主场景后已经检查过了，不必再走下面的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (m_curAssetsPackageState != AssetsPackageState.None)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IsAssetsPackageReady())</span><br><span class="line">&#123;</span><br><span class="line">m_isDecompressSuc = <span class="literal">true</span>;</span><br><span class="line">m_isDownLoadSuc = <span class="literal">true</span>;</span><br><span class="line">m_curAssetsPackageState = AssetsPackageState.AssetsReady;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_curAssetsPackageState == AssetsPackageState.None)</span><br><span class="line">&#123;</span><br><span class="line">LoginCheckDownLoadInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  资源包是否下载解压好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsAssetsPackageReady</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_data.assetPackage != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_data.assetPackage.isAssetsPackageReady;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于登录检查下载资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoginCheckDownLoadInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//创建下载目录</span></span><br><span class="line">m_availablePath = GetPathForPlatform(platform, TargetAssetsBundlPath);</span><br><span class="line"><span class="keyword">if</span> (!Directory.Exists(m_availablePath))</span><br><span class="line">&#123;</span><br><span class="line">Directory.CreateDirectory(m_availablePath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_updateStruct == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">GetUpdateStructForSvr(InitUpateFileInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">InitUpateFileInfo();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拉取下载文件清单信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetUpdateStructForSvr</span>(<span class="params">Action succCB = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"...."</span>;<span class="comment">//json文件的url</span></span><br><span class="line">DownloadSmallFileTask(url, (<span class="keyword">string</span> text) =&gt;<span class="comment">//下载并解析json文件</span></span><br><span class="line">&#123;</span><br><span class="line">m_updateStruct = JsonMapper.ToObject&lt;UpdateStruct&gt;(text);<span class="comment">//将json数据转为C#结构</span></span><br><span class="line"><span class="keyword">if</span> (m_updateStruct != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (succCB != <span class="literal">null</span>)</span><br><span class="line">succCB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//succCB批次任务执行成功回调,failCB批次任务执行失败回调,netConnectCheckCB网络连接检查回调,tryTimeLimit任务失败后尝试次数上限,value=0默认没有上限，不为0时，超过上限后结束任务执行</span></span><br><span class="line">StartDownloadSmallFile(succCB, failCB, netConnectCheckCB, tryTimeLimit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> md5;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> desize;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> demd5;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UpdateInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name = <span class="string">""</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">md5 = <span class="string">""</span>;</span><br><span class="line">desize = <span class="number">0</span>;</span><br><span class="line">demd5 = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化更新文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUpateFileInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//遍历json中的下载信息，统计已下载，总下载，初始化需要下载文件列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_updateInfo.Count; i++)<span class="comment">//遍历json数据转换后的list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> updateInfo = m_updateInfo[i];</span><br><span class="line">InitFileReadTask(m_updateInfo[i], m_availablePath);<span class="comment">//添加异步下载任务</span></span><br><span class="line">m_needDeleteFileList.Add(m_availablePath + m_updateInfo[i].name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化文件读取任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitFileReadTask</span>(<span class="params">UpdateInfo updateInfo, <span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">string</span> fileName = <span class="string">"ABC.ab"</span>;</span><br><span class="line"><span class="keyword">string</span> url = <span class="string">"https://www.AAA.com/ABC.ab"</span>;</span><br><span class="line"><span class="keyword">string</span> decompressFileName = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载文件读取</span></span><br><span class="line">m_totalSize += updateInfo.size;</span><br><span class="line">AddReadFileTask(fileName, updateInfo.md5, updateInfo.size,</span><br><span class="line"><span class="comment">//读取成功回调</span></span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_curSize += updateInfo.size;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//读取失败回调</span></span><br><span class="line">(TaskWorkStatus status) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AddDownloadBigFileTask(fileName, url, updateInfo.md5,</span><br><span class="line">updateInfo.size,</span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_childDownSize = <span class="number">0</span>;</span><br><span class="line">m_curSize += updateInfo.size;</span><br><span class="line">&#125;, </span><br><span class="line">(TaskWorkStatus downStatus) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_childDownSize = <span class="number">0</span>;</span><br><span class="line">&#125;, </span><br><span class="line">(<span class="keyword">long</span> curSize) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_childDownSize = curSize;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解压后文件读取</span></span><br><span class="line"><span class="keyword">var</span> unDecompressFile = <span class="keyword">new</span> CUnzipFile(fileName, decompressFileName, updateInfo.desize);</span><br><span class="line">m_totalDecompressSize += updateInfo.desize;</span><br><span class="line"></span><br><span class="line">AddReadFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize,</span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_curDecompressSize += updateInfo.desize;</span><br><span class="line">&#125;, </span><br><span class="line">(TaskWorkStatus status) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">AddDecompressFileTask(decompressFileName, updateInfo.demd5, </span><br><span class="line">updateInfo.desize, unDecompressFile, </span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">m_curDecompressSize += updateInfo.desize;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      带领你了解已上线的3D游戏项目
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="3D Client" scheme="https://aaronyard.github.io/tags/3D-Client/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试指南</title>
    <link href="https://aaronyard.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://aaronyard.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2020-04-01T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:20.428Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588671383833&di=aedab16ee0534bbc8ff91a797d4db90d&imgtype=0&src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2017-10-14%2F59e1d22411640.png" alt="img"></p><br><h1 id="一、数据库基础知识"><a href="#一、数据库基础知识" class="headerlink" title="一、数据库基础知识"></a>一、数据库基础知识</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><p><strong>数据保存在内存</strong></p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p><a id="more"></a><p><strong>数据保存在文件</strong></p><p>优点： 数据永久保存</p><p>缺点：</p><ul><li>速度比内存操作慢，频繁的IO操作。</li><li>查询数据不方便</li></ul><p><strong>数据保存在数据库</strong></p><ul><li>数据永久保存</li><li>使用SQL语句，查询方便效率高。</li><li>管理数据方便</li></ul><h2 id="2-数据库的三级模式结构"><a href="#2-数据库的三级模式结构" class="headerlink" title="2. 数据库的三级模式结构"></a>2. 数据库的三级模式结构</h2><ul><li><p><strong>内模式</strong>：也称存储模式。数据物理结构和存储方式的描述，是数据在数据库中的组织方式</p></li><li><p><strong>模式</strong>：也称逻辑模式。是数据库中全体数据成员的逻辑结构和特征的描述</p></li><li><p><strong>外模式</strong>：也称用户模式。是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200417121609.png" alt=""></p></li></ul><h2 id="3-什么是-SQL"><a href="#3-什么是-SQL" class="headerlink" title="3. 什么是 SQL"></a>3. 什么是 SQL</h2><p><code>结构化查询语言(Structured Query Language)</code> 简称 SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h2 id="4-什么是MySQL"><a href="#4-什么是MySQL" class="headerlink" title="4. 什么是MySQL?"></a>4. 什么是MySQL?</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h2 id="5-MySql-有哪些数据类型"><a href="#5-MySql-有哪些数据类型" class="headerlink" title="5. MySql 有哪些数据类型"></a>5. MySql 有哪些数据类型</h2><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200430215846.png" alt=""></p><h3 id="varchar-和-char-的区别"><a href="#varchar-和-char-的区别" class="headerlink" title="varchar 和 char 的区别"></a>varchar 和 char 的区别</h3><ul><li>CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR存储的内容超出设置的长度时，内容会被截断。</li><li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。VARCHAR存储的内容超出设置的长度时，内容同样会被截断。</li><li>对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。</li><li>对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。</li></ul><h2 id="6-超键、候选键、主键、外键"><a href="#6-超键、候选键、主键、外键" class="headerlink" title="6. 超键、候选键、主键、外键"></a>6. 超键、候选键、主键、外键</h2><ul><li><strong>超键</strong>：<u>在关系中能唯一标识元组的属性集称为关系模式的超键</u>。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li><strong>候选键</strong>：即最小超键，即没有冗余元素的超键。候选键中的元素称为<strong>主属性</strong></li><li><strong>主键</strong>：候选键中选出一个作为主键，一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="7-什么是数据字典"><a href="#7-什么是数据字典" class="headerlink" title="7. 什么是数据字典"></a>7. 什么是数据字典</h2><p>数据字典是关系数据库管理系统内部的一组系统表，它<strong>记录了数据库中所有的定义信息</strong>，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。<strong>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典中的相应信息</strong></p><h2 id="8-关系型数据库和非关系型数据库比较-⭐"><a href="#8-关系型数据库和非关系型数据库比较-⭐" class="headerlink" title="8. 关系型数据库和非关系型数据库比较 ⭐"></a>8. 关系型数据库和非关系型数据库比较 ⭐</h2><p><strong>关系型数据库</strong>：</p><ul><li>采用了关系模型来组织数据的数据库，以行和列形式存储数据，以便于用户理解。</li><li>通用的 SQL 语言使得操作关系型数据库非常方便。</li><li>关系型数据库遵循 ACID 原则。</li><li>常见的关系型数据库比如 MySQL，Oracle</li></ul><p><strong>关系型数据库存在的问题</strong>：</p><ul><li>网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘 I/O 是一个很大的瓶颈</li><li>网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。因此，关系型数据不适合持久存储海量数据</li><li>很难进行<u>横向扩展</u>（增加服务器），也就是说想要提高数据处理能力，要使用性能更好的计算机（<u>纵向扩展</u>）</li><li>性能欠佳：导致关系型数据库性能欠佳的最主要原因就是多表的关联查询，为了保证数据库的ACID特性，必须尽量按照范式要求设计数据库，关系数据库中的表存储的往往是一个固定的、格式化的数据结构</li></ul><p>而非关系型数据库就可以很好的解决关系型数据库很难解决的大数据问题</p><p><strong>非关系型数据库 NoSQL</strong>：</p><ul><li>非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</li><li>支持分布式存储，容易进行横向扩展</li><li>不遵循 ACID 特性（不提供对事务的处理）</li><li>常见的非关系型数据库比如 Redis、MongoDB、Elasticsearch</li></ul><h2 id="9-数据库连接池"><a href="#9-数据库连接池" class="headerlink" title="9. 数据库连接池"></a>9. 数据库连接池</h2><h3 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h3><p>数据库连接池是负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接</strong>，而不是每次访问数据库的时候都需要重新建立一次连接。</p><h3 id="②-为什么要使用连接池"><a href="#②-为什么要使用连接池" class="headerlink" title="② 为什么要使用连接池"></a>② 为什么要使用连接池</h3><p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p><p>数据库连接池的解决方案是<strong>在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放</strong>。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p><p>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p><h3 id="③-传统的连接机制与连接池运行机制区别"><a href="#③-传统的连接机制与连接池运行机制区别" class="headerlink" title="③ 传统的连接机制与连接池运行机制区别"></a>③ 传统的连接机制与连接池运行机制区别</h3><p>执行一个SQL命令</p><p><strong>不使用数据库连接池的步骤</strong>：</p><ul><li><p>TCP建立连接三次握手</p></li><li><p>MySQL认证三次握手</p></li><li><p>真正的SQL执行</p></li><li><p>MySQL关闭</p></li><li><p>TCP四次握手关闭</p></li></ul><p>可以看到，为了执行一条SQL，却多了非常多网络交互，应用需要频繁的创建连接和关闭连接。</p><p><strong>使用数据库连接池的步骤</strong>：</p><p>第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。</p><br><h1 id="二、关系数据库，SQL语句"><a href="#二、关系数据库，SQL语句" class="headerlink" title="二、关系数据库，SQL语句"></a>二、关系数据库，SQL语句</h1><p>更多详见：</p><ul><li><a href="https://xinxiban.gitee.io/cs-wiki/#/数据库/【二】关系数据库" target="_blank" rel="noopener">【二】关系数据库</a></li><li><a href="https://xinxiban.gitee.io/cs-wiki/#/数据库/[三]关系数据库标准语言SQL" target="_blank" rel="noopener">【三】关系数据库标准语言SQL</a></li></ul><h2 id="1-SQL-语句主要分为哪几类"><a href="#1-SQL-语句主要分为哪几类" class="headerlink" title="1. SQL 语句主要分为哪几类"></a>1. SQL 语句主要分为哪几类</h2><ul><li><strong>数据定义语言 DDL（Data Definition Language）</strong>：CREATE、DROP、ALTER，主要是对表结构、视图、索引等的操作</li><li><strong>数据查询语言：DQL（Data Query Language）</strong>：SELECT</li><li><strong>数据操纵语言：DML（Data Manipulation Language）</strong>：INSERT、DELETE、UPDATE</li><li><strong>数据控制语言：DCL（Data Control Language）</strong>：GRANT、REVOKE、COMMIT、ROLLBACK</li></ul><h2 id="2-in-和-exists-的区别"><a href="#2-in-和-exists-的区别" class="headerlink" title="2. in 和 exists 的区别"></a>2. in 和 exists 的区别</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> SC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> Stduent</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> SC);</span><br></pre></td></tr></table></figure><ul><li><p>in 先进行子查询 select id from SC，再进行外查询 select id from Student</p><p>exists 先执行外查询，再执行子查询</p></li><li><p>in 语句是把外表和内表作连接</p><p>而 exists 语句是对外表作循环，每次循环再对内表进行查询</p></li><li><p>exists 适合子查询的表比外查询大的查询语句</p><p>如果内表和外表差不多大，那么 in 和 exists 的效率差别不大</p></li></ul><h2 id="3-多表连接的查询方式"><a href="#3-多表连接的查询方式" class="headerlink" title="3. 多表连接的查询方式"></a>3. 多表连接的查询方式</h2><ul><li><p><strong>内连接 inner join:</strong> 只连接匹配的行（默认）</p></li><li><p><strong>左外连接 left outer join:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接 right outer join:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p><strong>全外连接 outer join:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p></li><li><p><strong>交叉连接 cross join:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p></li></ul><h2 id="4-MySql-分页-limit"><a href="#4-MySql-分页-limit" class="headerlink" title="4. MySql 分页 limit"></a>4. MySql 分页 limit</h2><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。</p><p>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。</p><ul><li><p>如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">10</span>; // 检索记录行 6-15</span><br></pre></td></tr></table></figure></li><li><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">95</span>,<span class="number">-1</span>; // 检索记录行 96-last.</span><br></pre></td></tr></table></figure></li><li><p>如果只给定一个参数，它表示返回最大的记录行数目：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">5</span>; //检索前 5 个记录行</span><br></pre></td></tr></table></figure></li><li><p>limit 和 offset 连用</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">limit</span> <span class="number">2</span> <span class="keyword">offset</span> <span class="number">1</span>; //跳过前面1条数据，检索2条数据</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-什么是视图，视图的优缺点"><a href="#5-什么是视图，视图的优缺点" class="headerlink" title="5. 什么是视图，视图的优缺点"></a>5. 什么是视图，视图的优缺点</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立计算机系学生视图，并要求插入/修改/删除操作时，保证该视图只有计算机系学生</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CS_Student</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept = <span class="string">'CS'</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure><p>视图是从一个或几个基本表（或视图）导出的表。</p><p>它与基本表不同，是一个虚表。</p><p><strong>数据库中只存放视图的定义，不存放视图对应的数据，这些数据任然存放在原来的基本表中。所以一旦基本表中的数据变化，那么视图中的数据也会相应变化。</strong></p><p>其实视图就好像一个窗口，透过它可以看到自己想要看到的数据及其变化</p><br><p><strong>视图的优点：</strong></p><ul><li><p>视图能够<strong>简化用户的操作</strong></p></li><li><p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而<strong>提高了数据库中数据的安全性</strong></p></li><li><p>适当利用视图可以更清晰的表达查询</p></li><li><p>视图使用户能以多种角度看待同一数据</p></li><li><p>视图对重构数据库提供了一定<strong>数据的逻辑独立性</strong></p><p>数据的逻辑独立性是指当数据库数据库构造时，如增加新的关系或对原来关系增加新的字段等，用户的应用程序不会受到影响</p></li></ul><p><strong>视图的缺点：</strong></p><ul><li>查询视图时，必须把对视图的查询转化为对基本表的查询。如果这个视图是由一个复杂的多表查询所定义，那么即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li><li>当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改，如果视图涉及多个表的话，由于完整性约束，可能是无法修改的</li></ul><br><h1 id="三、数据库安全性和完整性"><a href="#三、数据库安全性和完整性" class="headerlink" title="三、数据库安全性和完整性"></a>三、数据库安全性和完整性</h1><h2 id="1-安全性和完整性的区别-⭐"><a href="#1-安全性和完整性的区别-⭐" class="headerlink" title="1. 安全性和完整性的区别 ⭐"></a>1. 安全性和完整性的区别 ⭐</h2><p><strong>数据库的安全性：</strong>保护数据库防止不合法使用造成的数据泄露、更改或破坏</p><p><strong>数据库的完整性：</strong>防止数据库中存在不符合语义 / 不正确的数据信息</p><h2 id="2-数据库安全性控制机制"><a href="#2-数据库安全性控制机制" class="headerlink" title="2. 数据库安全性控制机制"></a>2. 数据库安全性控制机制</h2><ul><li><p><strong>用户身份鉴别</strong></p></li><li><p><strong>存取控制</strong></p><ul><li><p><code>GRANT</code> 授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把查询Student表的权限授给用户User1，并允许他将此权限授予其他用户</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> Student</span><br><span class="line"><span class="keyword">to</span> User1</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>REVOKE</code> 收回权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收回用户User1对Student表的查询权限，并级联收回User1授予的其他用户的该权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> Student</span><br><span class="line"><span class="keyword">from</span> User1 <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>视图机制 VIEW</strong></p></li><li><p><strong>审计 / 跟踪审查</strong></p><ul><li><p><code>AUDIT</code> 设置审计功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对修改Student表结构和修改Student表数据的操作进行审计</span></span><br><span class="line">AUDIT <span class="keyword">alter</span>,<span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> Student;</span><br></pre></td></tr></table></figure></li><li><p><code>NOAUDIT</code> 取消审计功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消取Student 表的一切审计</span></span><br><span class="line">noaudit <span class="keyword">alter</span>,<span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> Student;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据加密</strong></p></li></ul><h2 id="3-完整性约束"><a href="#3-完整性约束" class="headerlink" title="3. 完整性约束"></a>3. 完整性约束</h2><ul><li><p><strong>实体完整性约束</strong></p><p>主键必须存在且不为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key (Sno,Cno)</span><br></pre></td></tr></table></figure></li><li><p><strong>参照完整性约束</strong></p><p>外键要么不存在，要么存在且不为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreign key(Sno) references Student(Sno)</span><br></pre></td></tr></table></figure></li><li><p><strong>用户自定义完整性约束</strong></p><ul><li><p><code>NOT NULL</code>：字段的内容不能为空</p></li><li><p><code>UNIQUE</code>：字段内容不能重复，一个表允许有多个 Unique 约束</p></li><li><p><code>PRIMARY KEY</code>：主键</p></li><li><p><code>FOREIGN KEY</code>：外键</p></li><li><p><code>CHECK</code>：控制字段的取值范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sex char(2) <span class="keyword">check</span>(Sex <span class="keyword">in</span>(<span class="string">'男'</span>,<span class="string">'女'</span>)), //性别属性只能取男或女</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4. 触发器"></a>4. 触发器</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程，可用于保证数据库的完整性。</p><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>触发器仅限于数据库中增 删 改三种操作</p><p>在MySQL数据库中有如下六种触发器：</p><ul><li><strong>Before Insert</strong></li><li><strong>After Insert</strong></li><li><strong>Before Update</strong></li><li><strong>After Update</strong></li><li><strong>Before Delete</strong></li><li><strong>After Delete</strong></li></ul><p>触发器示例：cource表中删除一个元组，若该元组的主键是sc表中的外键，则卷回删除该元组的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger </span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> cource  </span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="keyword">as</span> o </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">when</span> (<span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> sc</span><br><span class="line">             <span class="keyword">where</span> cno = o.cno))</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><br><h1 id="四、关系数据库设计理论"><a href="#四、关系数据库设计理论" class="headerlink" title="四、关系数据库设计理论"></a>四、关系数据库设计理论</h1><h2 id="1-关系模式设计中的四种数据语义问题-异常"><a href="#1-关系模式设计中的四种数据语义问题-异常" class="headerlink" title="1. 关系模式设计中的四种数据语义问题  / 异常"></a>1. 关系模式设计中的四种数据语义问题  / 异常</h2><ul><li><p><strong>数据冗余</strong>：比如选课表（教师，学生）一个教师需对选他课的所有学生都重复一次</p><p>教师A 学生A</p><p>教师A 学生B</p><p>教师A 学生C</p></li><li><p><strong>更新异常</strong>：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。比如修改了第一个元组的教师A的工号，但是下面元组教师A的信息并没有得到修改</p></li><li><p><strong>删除异常</strong>：删除一个信息，那么也会丢失其它信息。比如删除第一个元组，那么学生A的信息也会丢失</p></li><li><p><strong>插入异常</strong>：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</p></li></ul><h2 id="2-函数依赖-三大范式-BCNF"><a href="#2-函数依赖-三大范式-BCNF" class="headerlink" title="2. 函数依赖 - 三大范式 + BCNF"></a>2. 函数依赖 - 三大范式 + BCNF</h2><p><strong>函数依赖：</strong></p><p>比如关系模式 S(<u>Sno, Cno</u>,  Name, Grade)</p><p>假设 主键是（Sno，Cno)，有如下关系模式</p><ul><li><p>(Sno, Cno) ——&gt; Grade：Grade <strong>完全依赖</strong>于主键</p></li><li><p>Sno ——&gt; Name：Name <strong>部分依赖</strong>于主键</p></li></ul><p>范式理论：（解决四种数据语义问题 / 四种异常）</p><ul><li><p><strong>第一范式 1 NF：</strong>属性不可分。<strong>可以认为任何表都属于第一范式</strong>，因为每个表的最小单位为表中的各个属性。</p></li><li><p><strong>第二范式 2 NF：</strong>在满足 1 NF 的条件下，消除非主属性对主键的部分函数依赖</p></li><li><p><strong>第三范式 3 NF：</strong>在满足 2 NF 的条件下，消除非主属性对主键的传递函数依赖</p></li><li><p><strong>修正的第三范式 BCNF：</strong>在满足第二范式的条件下，消除所有属性对主属性的传递依赖。即如果一个属性/属性组 A 决定其他属性/属性组B，则 A 必须包含主键</p><p>满足 BCNF 则一定满足 3NF，反之不一定</p></li></ul><h2 id="3-E-R-图的表示方法"><a href="#3-E-R-图的表示方法" class="headerlink" title="3. E-R 图的表示方法"></a>3. E-R 图的表示方法</h2><p><strong>实体之间的联系：</strong></p><ul><li><code>1：1 关系</code>：比如一个班级对应一个班长，一个班长只对应一个班级</li><li><code>1：n 关系</code>：比如一个老师教授多门课程，一门课程只对应一个老师</li><li><code>n：n 关系</code>：比如一门课程由若干个学生选修，一个学生可选修若干门课程</li></ul><p><strong>E-R 图基本表示方法：</strong></p><ul><li><strong>实体型</strong>用矩形表示</li><li><strong>属性</strong>用椭圆表示</li><li><strong>联系</strong>用菱形表示</li></ul><h2 id="4-E-R-图如何转换为数据库表"><a href="#4-E-R-图如何转换为数据库表" class="headerlink" title="4. E-R 图如何转换为数据库表"></a>4. E-R 图如何转换为数据库表</h2><p>E-R 图转换为数据库表，就是要把 E-R 图转换为对应的关系模式，转换的一般原则如下：</p><ul><li><p><strong>一个实体型转换为一个关系模式</strong></p><ul><li>关系的属性就是实体的属性</li><li>关系的码就是实体的码</li></ul></li><li><p>一个 1：1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</p></li><li><p>一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并</p></li><li><p>一个 m：n 联系可以转换为一个独立的关系模式</p><ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体型码的组合</li></ul></li><li><p>三个或三个以上实体间的一个多元联系可以转换为一个关系模式</p><ul><li>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合 </li></ul></li><li><p>具有相同码的关系模式可合并</p><p>目的：减少系统中的关系个数</p></li></ul><br><h1 id="五、查询处理和优化-⭐"><a href="#五、查询处理和优化-⭐" class="headerlink" title="五、查询处理和优化 ⭐"></a>五、查询处理和优化 ⭐</h1><h2 id="1-查询处理的具体流程"><a href="#1-查询处理的具体流程" class="headerlink" title="1. 查询处理的具体流程"></a>1. 查询处理的具体流程</h2><ul><li><p><strong>查询分析</strong></p><p>对 sql 语句进行扫描，词法分析+语法分析，判断查询语句是否符合 SQL 语法规则</p></li><li><p><strong>查询检查</strong></p><p>语义检查，即检查数据库对象，如关系名、属性名是否存在且有效</p></li><li><p><strong>查询优化</strong></p><p>优化器选择一个高效执行的查询处理策略，以达到最好的查询优化效果</p></li><li><p><strong>查询执行</strong></p><p>代码生成器生成执行这个查询计划的代码，然后加以执行，并返回查询结果</p></li></ul><h2 id="2-多表连接时的处理算法"><a href="#2-多表连接时的处理算法" class="headerlink" title="2. 多表连接时的处理算法"></a>2. 多表连接时的处理算法</h2><p>以下面这条 SQL 语句为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student,SC <span class="keyword">where</span> Student.Sno = SC.Sno;</span><br></pre></td></tr></table></figure><h3 id="①-嵌套循环算法-nested-loop"><a href="#①-嵌套循环算法-nested-loop" class="headerlink" title="① 嵌套循环算法 nested loop"></a>① 嵌套循环算法 nested loop</h3><p>最简单可行的算法。</p><ul><li>取 Student 表的一个元组，与 SC 表的所有元组进行比较，凡满足连接条件的元组就进行连接并且作为结果输出。</li><li>然后再取 Student 表的下一个元组，与 S 的所有元组比较，直至 Student 表的所有元组与 SC 表的所有元组比较完毕为止。</li></ul><h3 id="②-排序-归并算法-sort-merge"><a href="#②-排序-归并算法-sort-merge" class="headerlink" title="② 排序-归并算法 sort-merge"></a>② 排序-归并算法 sort-merge</h3><p>等值连接常用的算法，如果 Student 表和 SC 表<strong>已经按连接属性排好序</strong>了，则可按序比较两个表的连接属性，找出匹配的所有元组。</p><p>核心思想：分别从两个表中取出一行元组进行比较，如果匹配就连接起来放入结果集；<strong>如果不匹配，将较小的那个元组丢弃，继续匹配这个表的下一行</strong>，依次处理直到将两表的数据取完。</p><blockquote><p>如果 Student 表 和 SC 表在做连接操作之前没有按连接属性进行排序，则我们需要事先为之排序，由于排序是开销很大的操作，在此情况下是否值得使用排序归并法，那就需要权衡了。</p></blockquote><h3 id="③-索引连接算法-index-join"><a href="#③-索引连接算法-index-join" class="headerlink" title="③ 索引连接算法 index join"></a>③ 索引连接算法 index join</h3><ul><li>在 SC 表上已经建立了 Sno 的索引</li><li>对 Student 中的每一个元组，在 SC 表中通过 Sno 的索引查找对应的 SC 元组，把相匹配的两个表中的元组连接起来。循环执行，直到 Student 表扫描结束</li></ul><h3 id="④-散列连接算法-hash-join"><a href="#④-散列连接算法-hash-join" class="headerlink" title="④ 散列连接算法 hash join"></a>④ 散列连接算法 hash join</h3><blockquote><p>🚨 Oracle 支持 hash join，MySQL 不支持</p></blockquote><p>用来处理等值连接。把连接属性作为 hash 的 value，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。</p><ul><li><strong>创建阶段</strong>：创建 hash 表。对包含较少元组的表进行处理，把他的元组按 hash 函数分散到 hahs 桶中（采用拉链法）</li><li><strong>连接阶段</strong>：对另一个表进行 hash。并把这个表中元组和上一个表中相匹配的元组（同义词）连接起来。如果一个桶中只有 Student 或者 SC 的元组，则不进行连接。</li></ul><h2 id="3-查询优化的方法"><a href="#3-查询优化的方法" class="headerlink" title="3. 查询优化的方法"></a>3. 查询优化的方法</h2><h3 id="Ⅰ-代数优化"><a href="#Ⅰ-代数优化" class="headerlink" title="Ⅰ 代数优化"></a>Ⅰ 代数优化</h3><p>代数优化就是通过对关系代数式的等价变换来提高查询效率</p><p>代数优化改变的是查询语句中操作的次序和组合，但不涉及底层的存取路径</p><br><p>最常用的优化原则是尽量缩减查询过程中的中间结果。由于选择、投影等一元操作分别从水平或垂直方向减少关系的大小，而连接、并等二元操作不但操作本身的开销较大，而且很可能产生大的中间结果。因此，再做查询优化时，总是让选择和投影先做，再做连接等二元操作。在连接时，也是先做小关系之间的连接，再做大关系之间的连接。</p><br><p><strong>常见的对关系表达式进行查询优化的方法有</strong>：</p><ul><li>选择运算尽可能先做</li><li>若投影运算和选择运算都是对同一个关系进行操作，则将投影运算和选择运算同时进行</li><li>把投影同其前或后的双目运算符结合起来</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个来连接运算（连接，特别是等值连接，要比同样关系上的笛卡尔积省很多时间）</li><li>找出公共子表达式（比如查询视图的时候，定义视图的表达式就是公共子表达式）</li></ul><h3 id="Ⅱ-物理优化"><a href="#Ⅱ-物理优化" class="headerlink" title="Ⅱ 物理优化"></a>Ⅱ 物理优化</h3><p>物理优化就是选择高效合理的操作算法或者存取路径来达到查询优化的目标</p><p>选择的方法如下</p><ul><li>基于规则的启发式优化</li><li>基于代价估算的优化：选择代价最小的执行计划</li><li>两者结合的优化方法</li></ul><h4 id="①-基于规则的启发式优化"><a href="#①-基于规则的启发式优化" class="headerlink" title="① 基于规则的启发式优化"></a>① 基于规则的启发式优化</h4><p>🚩 <u>启发式优化：指的是在大部分情况下使用，但不是在所有情况下都是最好的规则</u></p><p><strong>1）对于选择操作的启发式规则</strong>：</p><ul><li>对于小关系，使用全表顺序扫描，即使选择列上有索引</li><li>对于大关系，启发式规则有：<ul><li>选择条件是 <code>主键 = 值</code>，采用主键索引</li><li>选择条件是 <code>非主属性 = 值</code>，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描</li><li>选择条件是 <code>非等值查询或范围查询</code>，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描</li><li>使用 <code>AND</code> 连接的合取选择条件，如果有涉及这些属性的组合索引，则优先使用索引，否则使用全表顺序扫描</li><li>对于 <code>OR</code> 连接的析取选择条件，一般使用全表顺序扫描</li></ul></li></ul><p><strong>2）对于连接操作的启发式规则</strong>：</p><ul><li>如果两个表都已经按照连接属性排序，则使用排序-合并算法</li><li>如果一个表在连接属性上有索引，则使用索引连接算法</li><li>如果上面两个规则不适用，且其中一个表较小，则使用 hash join 算法</li><li>最后可以使用嵌套循环算法</li></ul><h4 id="②-基于代价估算的优化"><a href="#②-基于代价估算的优化" class="headerlink" title="② 基于代价估算的优化"></a>② 基于代价估算的优化</h4><p>基于代价的优化方法要计算各种操作算法的执行代价，它与数据库的状态密切相关。为此在数据字典中存储了优化器需要的统计信息，主要包括以下几个方面：</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200512224228.png" alt=""></p><br><h1 id="六、事务处理-数据库恢复技术-⭐"><a href="#六、事务处理-数据库恢复技术-⭐" class="headerlink" title="六、事务处理 - 数据库恢复技术 ⭐"></a>六、事务处理 - 数据库恢复技术 ⭐</h1><h2 id="1-什么是数据库事务？"><a href="#1-什么是数据库事务？" class="headerlink" title="1. 什么是数据库事务？"></a>1. 什么是数据库事务？</h2><p><strong>事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</strong>。</p><p>一个程序包含多个事务。</p><br><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。</p><p>万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。<strong>事务就是保证这两个关键操作要么都成功，要么都要失败</strong>。</p><h2 id="2-事务的-ACID-特性"><a href="#2-事务的-ACID-特性" class="headerlink" title="2. 事务的 ACID 特性"></a>2. 事务的 ACID 特性</h2><ul><li><code>原子性（Atomicity）</code><br><strong>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</strong> </li><li><code>一致性（Consistency）</code><br><strong>数据库在事务执行前后都保持一致性状态</strong>。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。<br>例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的.</li><li><code>隔离性（Isolation）</code><br><strong>一个事务的执行不能被其他事务干扰</strong>，即一个事务的内部操作即使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><code>持久性（Durability）</code><br><strong>一旦事务提交，则其所做的修改将会永远保存到数据库中</strong>。接下来的操作和故障不应该对其执行结果有任何影响</li></ul><h2 id="3-事务的ACID特性遭到破坏的因素"><a href="#3-事务的ACID特性遭到破坏的因素" class="headerlink" title="3. 事务的ACID特性遭到破坏的因素"></a>3. 事务的ACID特性遭到破坏的因素</h2><ul><li>多个事务并发执行，互相干扰</li><li>事务在运行过程中被强行终止</li></ul><h2 id="4-数据库恢复技术"><a href="#4-数据库恢复技术" class="headerlink" title="4. 数据库恢复技术"></a>4. 数据库恢复技术</h2><p><u>数据库恢复技术就是把数据库从错误状态恢复到某一已知的正确状态。</u></p><p>恢复的基本原理十分简单。可以用一个词来概括，<strong>冗余</strong>。就是说数据库中任何一部分被破坏或者不正确的数据都可以根据存储在系统别处的冗余数据来重建。</p><ul><li><p><strong>数据转储</strong>：数据转储就是管理员定期的将整个数据库复制到磁带、磁盘或其他存储介质上。这些备用的数据称为<strong>后备副本 backup</strong></p><p>重装后备副本只能将数据库恢复到转储时的状态，其之后的事务操作都必须重新执行一遍才能恢复到故障发生时的状态。</p></li><li><p><strong>登记日志文件</strong>：日志文件中需要登记的内容包括：</p><ul><li>各个事务的开始标记</li><li>各个事务的结束标记</li><li>各个事务的更新操作</li></ul><p>登记日志文件时必须遵循两条原则</p><ul><li>登记的次序必须严格按照并发事务执行的时间次序</li><li><strong>必须先写日志文件，后进行数据库操作</strong></li></ul></li></ul><h2 id="5-数据库如何保证事务的-ACID-特性"><a href="#5-数据库如何保证事务的-ACID-特性" class="headerlink" title="5. 数据库如何保证事务的 ACID 特性"></a>5. 数据库如何保证事务的 ACID 特性</h2><ul><li><p><strong>原子性实现原理 - Undo Log</strong></p><p><strong>为了实现原子性，需要通过日志</strong>：将所有对数据更新操作都写入日志，如果一个事务中的一部分已经操作成功，但以后的操作由于断电/系统崩溃/其他软硬件错误或者用户提交了rollback 导致无法进行，则通过回溯日志，<strong>将已经执行成功的操作撤销 undo</strong>，从而达到全部操作失败的目的，使得数据库恢复到一致性的状态，可以继续被使用。</p></li><li><p><strong>持久性实现原理 - Redo Log</strong></p><p>和Undo Log 相反，<strong>Redo（重做） Log 记录的是新数据的备份</strong>。在事务提交前，只是将Redo Log 持久化即可，不需要数据持久化。当系统崩溃时，虽然数据没有持久化，但Redo Log 已经持久化了。<strong>系统可以根据Redo Log 将数据更新到最新的状态。</strong></p></li><li><p><strong>隔离性实现原理 - 锁</strong></p><p>当然，保证事务的隔离性，即并发控制不止可用封锁协议，还有时间戳、多版本控制等等。</p></li></ul><br><h1 id="七、事务处理-并发控制-⭐"><a href="#七、事务处理-并发控制-⭐" class="headerlink" title="七、事务处理 - 并发控制 ⭐"></a>七、事务处理 - 并发控制 ⭐</h1><h2 id="1-并发事务带来的问题"><a href="#1-并发事务带来的问题" class="headerlink" title="1. 并发事务带来的问题"></a>1. 并发事务带来的问题</h2><ul><li><strong>脏读</strong>：事务T1修改了一份数据，还没有提交操作，这时事务T2读取了这份数据，由于某些原因事务T1回滚了他的修改操作使得数据恢复到原来，这样事务T2读取的数据就是脏数据</li><li><strong>丢失修改</strong>：事务T1修改了一份数据，还没有提交操作，这时事务T2也修改了这份数据，这样就导致事务T1 的修改结果丢失了</li><li><strong>不可重复读</strong>：事务 T1 读取一份数据，然后 事务 T2 修改了该数据，事务 T1 再一次读取了该数据，这样，事务 T1 两次读取的这份数据的结果是不一样的，称为不可重复读</li><li><strong>幻读</strong>：幻读与不可重读类似，不过<strong>幻读侧重于数据的增加和删除，不可重读侧重于修改</strong>。事务 T1 读取了一份数据，然后事务 T2 给这个数据添加了几条记录，事务 T1 再一次读取该数据，发现多了一些原本不存在的数据，就好像发生了幻觉一样。</li></ul><h2 id="2-事务的隔离级别"><a href="#2-事务的隔离级别" class="headerlink" title="2. 事务的隔离级别"></a>2. 事务的隔离级别</h2><p>SQL 标准为事务定义了四个不同的隔离级别以满足事务的 ACID 特性，由低到高依次为</p><ul><li><p><code>READ-UNCOMMITTED(读取未提交)</code>：</p><p>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p><code>READ-COMMITTED(读取已提交)</code>：</p><p>允许读取并发事务已经提交的数据，<strong>可以阻止脏读</strong>，但是幻读或不可重复读仍有可能发生。</p></li><li><p><code>REPEATABLE-READ(可重复读)</code>：</p><p>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读</strong>，但幻读仍有可能发生。</p></li><li><p><code>SERIALIZABLE(可串行化)</code>：</p><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读。</strong><br> （该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。）</p></li></ul><p>这四个级别可以<strong>逐个解决</strong>脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>Mysql InnoDB 存储引擎 默认采用的 REPEATABLE_READ 可重读 隔离级别 </li><li>Oracle 默认采用的 READ_COMMITTED 读取已提交 隔离级别</li></ul><h2 id="3-乐观锁和悲观锁"><a href="#3-乐观锁和悲观锁" class="headerlink" title="3. 乐观锁和悲观锁"></a>3. 乐观锁和悲观锁</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时，不破坏事务的 ACID 特性。<strong>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</strong></p><p>🚨 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。</p><ul><li><p><strong>悲观锁</strong>：<u>假定会发生并发冲突</u>，屏蔽一切可能违反数据完整性的操作。<u>在修改数据之前先锁定，再修改。</u>实现方式：<strong>悲观锁主要是 共享锁 或 排他锁</strong>（见下文）</p></li><li><p><strong>乐观锁</strong>：乐观锁是相对悲观锁而言的，<u>乐观锁假设数据一般情况下不会造成冲突</u>，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是<strong>记录数据版本</strong>。</p></li></ul><h2 id="4-什么是锁"><a href="#4-什么是锁" class="headerlink" title="4. 什么是锁"></a>4. 什么是锁</h2><p>当数据库有并发事务的时候，可能会相互干扰，这时候需要一些机制来保证事务访问的次序，锁机制就是这样的一个机制。</p><p>所谓封锁就是事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁，在事务 T释放它的锁之前，其他事务不更新此对象。</p><h2 id="5-锁的类别"><a href="#5-锁的类别" class="headerlink" title="5. 锁的类别"></a>5. 锁的类别</h2><ul><li><p><strong>排他锁 / 写锁 X 锁</strong><br>  一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和修改。<br>  <strong>加X锁期间其它事务不能对 A 加任何锁</strong>。这就保证了其他事务在该事务释放X锁之前不能读取和修改A</p></li><li><p><strong>共享锁 / 读锁 S 锁</strong></p><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。</p><p><strong>加S锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</strong>这就保证了其他事务可以读A，但在该事务释放S锁之前不能对A进行修改</p></li><li><p><strong>意向锁</strong>（意向锁的引入是为了解决多粒度封锁时，检查封锁冲突效率低下问题）</p><ul><li><p><strong>IS 锁</strong></p><p>如果对一个数据对象加 IS 锁，则表示它的后裔结点想要加 S 锁</p></li><li><p><strong>IX 锁</strong></p><p>如果对一个数据对象加 IX 锁，则表示它的后裔结点想要加 X 锁</p></li><li><p><strong>SIX 锁</strong></p><p>如果对一个数据对象加 SIX 锁，则表示对他加 S 锁，再加 IX 锁</p></li></ul></li></ul><h2 id="6-多粒度封锁"><a href="#6-多粒度封锁" class="headerlink" title="6. 多粒度封锁"></a>6. 多粒度封锁</h2><p>封锁对象的大小称为 <code>封锁粒度 granularity</code></p><p>MySQL 中提供了两种封锁粒度：<code>行级锁</code> 以及 <code>表级锁</code> 。</p><ul><li><p><strong>行级锁 row-level locking</strong> 行级锁是Mysql中锁定粒度最细的一种锁，<strong>表示只针对当前操作的行进行加锁</strong>。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li><li><p><strong>表级锁 table-level locking</strong> 表级锁是MySQL中锁定粒度最大的一种锁，<strong>表示对当前操作的整张表加锁</strong>，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p></li></ul><p>因此如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为 <code>多粒度封锁 multiple granularity locking</code></p><p>首先我们需要知道<code>多粒度树</code>：多粒度树的根节点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度</p><p>下图给出了一个三级粒度树</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420141411.png" style="zoom:80%;" /><p>多粒度封锁协议允许多粒度树中的每个结点被独立的加锁，<strong>对一个结点加锁意味着这个结点的所有后裔结点都被加以同样的锁</strong></p><ul><li><code>显示封锁</code>：应事务的要求直接加到数据对象上的锁</li><li><code>隐式封锁</code>：该数据对象没有被独立加锁，继承上级结点的锁</li></ul><p>系统检查封锁冲突时不仅要检查显示封锁，还要检查隐式封锁。</p><p>显然，这样的检查方法效率很低，为此人们引进了<strong>意向锁</strong>（见上个问题）</p><h2 id="7-什么是死锁-活锁，怎么解决"><a href="#7-什么是死锁-活锁，怎么解决" class="headerlink" title="7. 什么是死锁 / 活锁，怎么解决"></a>7. 什么是死锁 / 活锁，怎么解决</h2><ul><li><p><strong>死锁：</strong>两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环等待的现象。</p><p><strong>解决死锁的方法：</strong></p><ul><li><p>死锁预防：破坏死锁产生的条件</p><p><code>一次封锁法</code>：每个事务必须一次性将所有需要的数据全部加锁，否则不能执行</p><p><code>顺序封锁法</code>：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序进行封锁</p></li><li><p>死锁检测：</p><p><code>超时法：</code>如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</p><p><code>等待图法：</code>如果图中存在回路，则表示系统中出现了死锁</p></li><li><p>死锁处理：</p><p>一般采取的死锁解除策略是：<u>选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去。</u></p></li></ul></li><li><p><strong>活锁：</strong>事务T1 封锁了数据 1，事务 T2请求封锁数据1，于是 T2等待，T3 也请求封锁数据1，当事务 T1 释放了对数据 1 的封锁后，批准了 T3 的请求，于是 T2 继续等待，T4 请求封锁数据1，当事务 T3 释放了对数据 1 的封锁后，批准了 T4 的请求，于是 T2 继续等待。。。。T2 可能永远等待，即一个事务等待的时间过长而影响事务的执行，这就是活锁。</p><p><strong>解决活锁的方法</strong>：先来先服务</p></li></ul><h2 id="8-封锁协议"><a href="#8-封锁协议" class="headerlink" title="8. 封锁协议"></a>8. 封锁协议</h2><ul><li><p><strong>三级封锁协议</strong>：<u>运用 X 锁和 S 锁进行加锁的时候应遵守的协议规则</u></p><ul><li><p><code>一级封锁协议</code></p><p>事务修改数据之前，必须加 X 锁，事务结束释放 X 锁</p></li><li><p><code>二级封锁协议</code></p><p>在一级封锁协议的基础上，事务读取数据前，必须加 S 锁，<strong>读取完马上释放 S 锁</strong></p></li><li><p><code>三级封锁协议</code></p><p>在一级封锁协议的基础上，事务读取时间前，必须加 S 锁，<strong>直到事务结束才释放 S 锁</strong></p></li></ul></li><li><p><strong>两段锁协议</strong>：所有事务必须分两个阶段对数据项进行加锁和解锁，<u>两端锁协议用来实现并发调度的可串行性，从而保证调度的正确性</u></p><ul><li><code>扩展阶段</code>（加锁）：在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁</li><li><code>收缩阶段</code>（解锁）：在释放一个封锁的时候，事务不再申请和获得任何其他锁</li></ul><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420140023.png" style="zoom:80%;" /></li></ul><h2 id="9-并发调度的可串行性"><a href="#9-并发调度的可串行性" class="headerlink" title="9. 并发调度的可串行性"></a>9. 并发调度的可串行性</h2><p>数据库管理系统对并发事务不同的调度可能会产生不同的结果，<strong>只有串行调度才能得到正确的结果</strong></p><ul><li><p><code>可串行化调度</code>：多个事务并发调度的结果和按次序串行执行的结果相同，则这个并发调度就是可串行化调度</p><p><strong>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</strong></p></li><li><p><code>冲突可串行化调度</code>：冲突操作是指不同的事务对同一个数据的读写操作和写写操作</p><p>不同事务或者同一事务的冲突操作时不能交换的。</p><p><strong>一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度B，则称调度B是冲突可串行化的调度。</strong></p><p>若一个调度是冲突可串行化调度，那么一定是可串行化调度</p></li></ul><br><h1 id="八、数据库编程"><a href="#八、数据库编程" class="headerlink" title="八、数据库编程"></a>八、数据库编程</h1><p>数据库编程就是用编程方法对数据库进行操纵的技术，SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足（没有逻辑控制能力），提高应用系统和数据库管理系统间的互操作性。</p><h2 id="1-什么是存储过程？有哪些优缺点？"><a href="#1-什么是存储过程？有哪些优缺点？" class="headerlink" title="1. 什么是存储过程？有哪些优缺点？"></a>1. 什么是存储过程？有哪些优缺点？</h2><p>存储过程是一个<strong>预编译的SQL语句</strong>，优点是允许模块化的设计，就是说<strong>只需要创建一次，以后在该程序中就可以调用多次</strong>。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><ul><li>存储过程是预编译过的，执行效率高。</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li><li>安全性高，执行存储过程需要有一定权限的用户。</li><li>存储过程可以重复使用，减少数据库开发人员的工作量。</li></ul><p><strong>缺点</strong></p><ul><li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</li><li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li><li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li><li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li></ul><h2 id="2-什么是游标"><a href="#2-什么是游标" class="headerlink" title="2. 什么是游标"></a>2. 什么是游标</h2><p>游标主要用于嵌入式 SQL，<strong>一条 SQL 语句可以产生或处理多条记录；而主语言是面向记录的，一组主变量一次只能存放一条记录。为此引入游标来协调这两种不同的处理方式</strong></p><p><u>游标是面向集合的，游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</u>，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p><br><h1 id="九、索引-⭐"><a href="#九、索引-⭐" class="headerlink" title="九、索引 ⭐"></a>九、索引 ⭐</h1><h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p><p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h2 id="2-索引的创建"><a href="#2-索引的创建" class="headerlink" title="2. 索引的创建"></a>2. 索引的创建</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][cluster] <span class="keyword">index</span> 索引名</span><br><span class="line"><span class="keyword">on</span> 表名 (列名[次序]，列名[次序]...)</span><br></pre></td></tr></table></figure><p>unique 表示此索引的每一个索引值只对应唯一的数据记录</p><p>cluster 表示该索引是聚集索引，详见后文</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> sno_index <span class="keyword">on</span> student(sno);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> cno_index <span class="keyword">on</span> cource(cno);</span><br><span class="line"><span class="comment"># sc表按学号升序和课程号降序建立唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> sc_index <span class="keyword">on</span> sc(sno <span class="keyword">asc</span>, cno <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure><h2 id="3-为什么要使用索引，索引的优缺点分析"><a href="#3-为什么要使用索引，索引的优缺点分析" class="headerlink" title="3. 为什么要使用索引，索引的优缺点分析"></a>3. 为什么要使用索引，索引的优缺点分析</h2><h3 id="①-索引的优点"><a href="#①-索引的优点" class="headerlink" title="① 索引的优点"></a>① 索引的优点</h3><ul><li><p><strong>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的</strong>  。</p></li><li><p>另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p></li></ul><h3 id="②-索引的缺点"><a href="#②-索引的缺点" class="headerlink" title="② 索引的缺点"></a>② 索引的缺点</h3><ul><li>创建索引和维护索引需要耗费许多<strong>时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</li><li>占用物理存储<strong>空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="③-索引的使用条件"><a href="#③-索引的使用条件" class="headerlink" title="③ 索引的使用条件"></a>③ 索引的使用条件</h3><ul><li><p><strong>对于非常小的表</strong>、大部分情况下简单的<strong>全表扫描比建立索引更高效</strong>；</p></li><li><p>对于中到大型的表，索引就非常有效；</p></li><li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术</strong>。</p><blockquote><p>数据库的存储介质一般由多个磁盘阵列组成。数据在磁盘阵列上的分布也是数据库物理设计的内容之一，这就是所谓的分区设计 partition design。分区设计的一般原则如下：</p><ul><li>减少访盘冲突，提高 I/O 并行性</li><li>分散热点数据，均衡 I/O 负荷</li><li>保证关键数据的快速访问，缓解系统的瓶颈</li></ul></blockquote></li></ul><h2 id="4-B-树原理-⭐"><a href="#4-B-树原理-⭐" class="headerlink" title="4. B+树原理 ⭐"></a>4. B+树原理 ⭐</h2><h3 id="①-数据结构"><a href="#①-数据结构" class="headerlink" title="① 数据结构"></a>① 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，所有叶子节点位于同一层并且不带任何信息，所有索引信息和相应的数据都存储在分支结点中（既存放 键(key) 也存放 数据(data)）</p><p>B+树是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<strong>B+树中叶节点包含关键字的全部信息（键(key) 和数据(data)），其他非叶结点/分支结点仅起索引作用（仅存储key）。并将关键字按照大小顺序排列，相邻叶子结点按照大小顺序相互链接起来（支持顺序查找）</strong>。</p><p>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而<strong>B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</strong></p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200413211701.png" alt=""></p><h3 id="②-操作"><a href="#②-操作" class="headerlink" title="② 操作"></a>② 操作</h3><p>进行查找操作时，<strong>首先在根节点进行二分查找</strong>，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，<strong>然后在叶子节点上进行二分查找</strong>，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。（插入删除操作详细见 <u>数据结构【五】查找</u>）</p><h3 id="③-与红黑树的比较"><a href="#③-与红黑树的比较" class="headerlink" title="③ 与红黑树的比较"></a>③ 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是<strong>文件系统及数据库系统普遍采用 B+ Tree 作为索引结构</strong>，主要有以下两个原因：</p><ul><li><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p><strong>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</strong></p></li><li><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p></li></ul><h3 id="④-与Hash索引的比较"><a href="#④-与Hash索引的比较" class="headerlink" title="④ 与Hash索引的比较"></a>④ 与Hash索引的比较</h3><ul><li><p><strong>Hash索引定位快</strong></p><p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p></li><li><p><strong>Hash冲突问题</strong></p><p>不过对于数据库来说这还不算最大的缺点。</p></li><li><p><strong>Hash索引不支持顺序和范围查询是它最大的缺点。</strong>⭐</p><p>试想一种情况:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure><p>B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。</p><p>而Hash索引是根据hash算法来定位的，需要对所有数据进行一遍hash才能得到查询结果，显然是不现实的。这就是Hash最大的缺点了。</p></li></ul><h2 id="5-索引类型"><a href="#5-索引类型" class="headerlink" title="5. 索引类型"></a>5. 索引类型</h2><h3 id="①-主键索引"><a href="#①-主键索引" class="headerlink" title="① 主键索引"></a>① 主键索引</h3><p><strong>数据表的主键列使用的就是主键索引。</strong></p><p><strong>一张数据表有且只能有一个主键，并且主键不能为null，不能重复。</strong></p><p>在mysql的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</p><h3 id="②-辅助索引-二级索引"><a href="#②-辅助索引-二级索引" class="headerlink" title="② 辅助索引/二级索引"></a>② 辅助索引/二级索引</h3><p>二级索引又称为辅助索引，是因为<strong>二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ul><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</li></ul><h2 id="6-聚集索引与非聚集索引"><a href="#6-聚集索引与非聚集索引" class="headerlink" title="6. 聚集索引与非聚集索引"></a>6. 聚集索引与非聚集索引</h2><h3 id="①-聚集索引"><a href="#①-聚集索引" class="headerlink" title="① 聚集索引"></a>① 聚集索引</h3><p><strong>定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引</strong>，主键索引属于聚集索引。</p><p>举例：</p><table><thead><tr><th>地址</th><th>id</th><th>username</th><th>score</th></tr></thead><tbody><tr><td>0x01</td><td>1</td><td>小明</td><td>90</td></tr><tr><td>0x02</td><td>2</td><td>小红</td><td>80</td></tr><tr><td>0x03</td><td>3</td><td>小华</td><td>92</td></tr><tr><td>..</td><td>..</td><td>..</td><td>..</td></tr><tr><td>0xff</td><td>256</td><td>小英</td><td>70</td></tr></tbody></table><p>数据行的物理顺序与列值的顺序相同，<strong>如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后</strong>。</p><p><strong>聚集索引的优点</strong>：</p><ul><li>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，<u>定位到索引的节点，就相当于定位到了数据。</u></li></ul><p><strong>聚集索引的缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="②-非聚集索引"><a href="#②-非聚集索引" class="headerlink" title="② 非聚集索引"></a>② 非聚集索引</h3><p>定义：该索引中<strong>索引的逻辑顺序与磁盘上的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><blockquote><p>MYISAM引擎的表的.MYI文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， <strong>叶子节点存储索引和索引对应数据的指针</strong>，指向.MYD文件的数据。</p></blockquote><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，<u>根据主键再回表查数据</u>。</strong></p><p><strong>非聚集索引的优点</strong></p><ul><li><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，<strong>非聚集索引的叶子节点是不存放数据的</strong></li></ul><p><strong>非聚集索引的缺点</strong></p><ul><li><p>跟聚集索引一样，非聚集索引也依赖于有序的数据</p></li><li><p><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p></li></ul><p><strong>总结来说，对于B+树，如果是聚集索引，那么叶子节点的data将存放数据，如果是非聚集索引，那么data将存放指向数据的指针</strong></p><h2 id="7-MySQL主要使用的两种索引"><a href="#7-MySQL主要使用的两种索引" class="headerlink" title="7. MySQL主要使用的两种索引"></a>7. MySQL主要使用的两种索引</h2><h3 id="①-B-树索引"><a href="#①-B-树索引" class="headerlink" title="① B+树索引"></a>① B+树索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，即聚集索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚集索引。</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200413215059.png" alt=""></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200413215118.png" alt=""></p><h3 id="②-哈希索引"><a href="#②-哈希索引" class="headerlink" title="② 哈希索引"></a>② 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“<strong>自适应哈希索引</strong>”，当某个索引值被使用的非常频繁时，会在 <strong>B+Tree 索引之上再创建一个哈希索引</strong>，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h2 id="8-索引创建原则"><a href="#8-索引创建原则" class="headerlink" title="8. 索引创建原则"></a>8. 索引创建原则</h2><ul><li><p><strong>单列索引</strong></p><p>单列索引即由一列属性组成的索引。</p></li><li><p><strong>联合索引(多列索引)</strong></p><p>联合索引即由多列属性组成索引。</p></li><li><p>*<em>最左前缀原则 *</em>⭐</p><p>假设创建的联合索引由三个字段组成:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">num</span>,<span class="keyword">name</span>,age)</span><br></pre></td></tr></table></figure><p>那么当查询的条件有为 : <code>num / (num AND name) / (num AND name AND age)</code>时，索引才生效。</p><p>所以在创建联合索引时，<strong>尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</strong></p></li></ul><h2 id="9-索引创建注意点"><a href="#9-索引创建注意点" class="headerlink" title="9. 索引创建注意点"></a>9. 索引创建注意点</h2><p><u><strong>① 最左前缀原则</strong></u></p><p>虽然目前较高的Mysql版本好像不遵守最左前缀原则，索引也会生效。 但是我们仍应遵守最左前缀原则，以免版本迭代带来的麻烦。</p><p><u><strong>② 选择合适的字段</strong></u></p><ul><li><p><strong>不为NULL的字段</strong><br>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p></li><li><p><strong>被频繁查询的字段</strong><br>我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p><strong>被作为条件查询的字段</strong><br>被作为WHERE条件查询的字段，应该被考虑建立索引。</p></li><li><p><strong>被经常频繁用于连接的字段</strong><br>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p></li></ul><p><u><strong>③ 不适合创建索引的字段</strong></u></p><ul><li><p><strong>被频繁更新的字段应该慎重建立索引</strong><br>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p></li><li><p><strong>不被经常查询的字段没有必要建立索引</strong></p></li><li><p><strong>尽可能的考虑建立联合索引而不是单列索引</strong><br>因为索引是需要占用磁盘空间的，<u>可以简单理解为每个索引都对应着一颗B+树</u>。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p></li><li><p><strong>注意避免冗余索引</strong><br>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引。</p><p>如<u>（name,city ）和（name ）这两个索引就是冗余索引</u>，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p></li><li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong><br>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p></li></ul><h2 id="10-索引优化"><a href="#10-索引优化" class="headerlink" title="10. 索引优化"></a>10. 索引优化</h2><ul><li><p><strong>独立的列</strong></p><p>在进行查询时，<strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>多列索引</strong></p><p>  在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>索引列的顺序</strong></p><p><strong>让选择性最强的索引列放在前面。</strong></p><p>索引的选择性是指：<code>不重复的索引值的个数 / 记录总数</code> (最大值为 1)。 此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure></li><li><p><strong>前缀索引</strong></p><p>  对于<code>BLOB、TEXT 和 VARCHAR</code>类型的列，必须使用前缀索引，<strong>只索引开始的部分字符。</strong></p><p>  前缀长度的选取需要根据索引选择性来确定。</p></li><li><p><strong>覆盖索引</strong></p><p><u>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”</u>。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</p><blockquote><p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。那么name的索引就称为覆盖索引</p></blockquote></li></ul><h2 id="11-百万级别或以上的数据如何删除"><a href="#11-百万级别或以上的数据如何删除" class="headerlink" title="11. 百万级别或以上的数据如何删除"></a>11. 百万级别或以上的数据如何删除</h2><p>索引是单独存在的文件，所以当我们对数据的增加、修改、删除时，都会产生额外的对索引文件的操作，这些操作需要消耗额外的 I/O，降低增删改的效率。</p><p>对于百万级别的数据来说，删除数据的速度和已建立的索引数量成正比。</p><p>所以，删除数据之前，我们需要先删除索引，再删除数据。</p><br><h1 id="十、存储引擎-Storage-engine"><a href="#十、存储引擎-Storage-engine" class="headerlink" title="十、存储引擎 Storage engine"></a>十、存储引擎 Storage engine</h1><p><code>存储引擎Storage engine</code>：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><p>是 <strong>MySQL 默认的事务型存储引擎</strong>，提供了对数据库 ACID 特性的支持，并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p><p>主索引是聚集索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p><strong>不支持事务。</strong></p><p><strong>不支持行级锁，只能对整张表加锁</strong>，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ul><li>事务：<strong>InnoDB 是事务型的</strong>，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 <strong>InnoDB 同时支持行级锁和表级锁</strong>。</li><li>外键：<strong>InnoDB 支持外键</strong>。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul>]]></content>
    
    <summary type="html">
    
      数据库面试指南
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://aaronyard.github.io/2020/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93/LeetCode/"/>
    <id>https://aaronyard.github.io/2020/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93/LeetCode/</id>
    <published>2020-03-31T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:23.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="💾-LeetCode-数据库部分题目"><a href="#💾-LeetCode-数据库部分题目" class="headerlink" title="💾 LeetCode 数据库部分题目"></a>💾 LeetCode 数据库部分题目</h1><hr><h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">175. 组合两个表</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502172156.png" style="zoom: 80%;" /><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><blockquote><p> FirstName, LastName, City, State</p></blockquote><a id="more"></a><p>需要保留Person表中未连接的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> FirstName,LastName,City,State</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> Address</span><br><span class="line"><span class="keyword">on</span> Person.PersonId = Address.PersonId;</span><br></pre></td></tr></table></figure><br><h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176. 第二高的薪水</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502172636.png" style="zoom: 80%;" /><br><p>方法一：使用聚集函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Salary) SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">where</span> Salary &lt; (<span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">from</span> Employee);</span><br></pre></td></tr></table></figure><p>方法二：使用 <code>limit</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> Salary</span><br><span class="line">    <span class="keyword">from</span> Employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">    <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure><p><code>limit x offset y</code>：跳过 y 条数据查询 x 条数据</p><br><h3 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">177. 第N高的薪水</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502173929.png" style="zoom: 80%;" /><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">      <span class="keyword">limit</span> N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><br><h3 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178. 分数排名</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502174557.png" style="zoom:80%;" /><br><p>我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合 H 里就只有99一个元素，个数为1，因此你的Rank为1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.Score, <span class="keyword">count</span>(<span class="keyword">distinct</span>(s2.Score)) <span class="keyword">Rank</span></span><br><span class="line"><span class="keyword">from</span> Scores s1, Scores s2</span><br><span class="line"><span class="keyword">where</span> s1.Score&lt;=s2.Score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s1.Id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Rank</span>;</span><br></pre></td></tr></table></figure><br><h3 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener">180. 连续出现的数字</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502180956.png" style="zoom:80%;" /><br><p>至少连续出现三次的数字则必定id连续三次或三次以上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.Num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Logs</span> a,<span class="keyword">Logs</span> b,<span class="keyword">Logs</span> c</span><br><span class="line"><span class="keyword">where</span> a.Num=b.Num <span class="keyword">and</span> b.Num=c.Num <span class="keyword">and</span> a.id=b.id<span class="number">-1</span> <span class="keyword">and</span> b.id=c.id<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><br><h3 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">181. 超过经理收入的员工</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502181827.png" style="zoom:80%;" /><br><p>自连接，第一张表的 Managerid = 第二张表的 id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">where</span> Salary &gt; (<span class="keyword">select</span> Salary <span class="keyword">from</span> Employee b </span><br><span class="line">                <span class="keyword">where</span> b.id = a.Managerid);</span><br></pre></td></tr></table></figure><br><h3 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">182. 查找重复的电子邮箱</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502182635.png" style="zoom:80%;" /><br><p>利用 group by - having</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email <span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br><h3 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/" target="_blank" rel="noopener">183. 从不订购的客户</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200502183527.png" style="zoom:80%;" /><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.Name <span class="keyword">as</span> Customers <span class="keyword">from</span> Customers c</span><br><span class="line"><span class="keyword">where</span> c.Id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> o.CustomerId <span class="keyword">from</span> Orders o);</span><br></pre></td></tr></table></figure><br><h3 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200503134807.png"  /><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    d.Name <span class="keyword">as</span> Department,</span><br><span class="line">    e.Name <span class="keyword">as</span> Employee,</span><br><span class="line">    e.Salary </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Employee e,Department d </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    e.DepartmentId=d.id <span class="keyword">and</span></span><br><span class="line">    (e.Salary,e.DepartmentId) <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">max</span>(Salary),DepartmentId </span><br><span class="line">        <span class="keyword">from</span> Employee </span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId);</span><br></pre></td></tr></table></figure><br><h3 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">185. 部门工资前三高的所有员工</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200503135952.png"  /><p>先定义找出前三高薪水的查询语句，即不超过三个值比这个薪水大。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.Salary </span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">AS</span> e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">3</span> &gt; </span><br><span class="line">(<span class="keyword">SELECT</span>  <span class="keyword">count</span>(<span class="keyword">DISTINCT</span> e2.Salary) </span><br><span class="line"> <span class="keyword">FROM</span>Employee <span class="keyword">AS</span> e2 </span><br><span class="line">  <span class="keyword">WHERE</span>e1.Salary &lt; e2.Salary <span class="keyword">AND</span> </span><br><span class="line">         e1.DepartmentId = e2.DepartmentId) ;</span><br></pre></td></tr></table></figure><blockquote><p>举个栗子：<br>当 e1 = e2 = [4,5,6,7,8]</p><p>e1.Salary = 4，e2.Salary 可以取值 [5,6,7,8]，count(DISTINCT e2.Salary) = 4</p><p>e1.Salary = 5，e2.Salary 可以取值 [6,7,8]，count(DISTINCT e2.Salary) = 3</p><p>e1.Salary = 6，e2.Salary 可以取值 [7,8]，count(DISTINCT e2.Salary) = 2</p><p>e1.Salary = 7，e2.Salary 可以取值 [8]，count(DISTINCT e2.Salary) = 1</p><p>e1.Salary = 8，e2.Salary 可以取值 []，count(DISTINCT e2.Salary) = 0</p><p>最后 3 &gt; count(DISTINCT e2.Salary)，所以 e1.Salary 可取值为 [6,7,8]，即集合前 3 高的薪水</p></blockquote><p>再把两个表连接，获得各个部门工资前三高的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department,</span><br><span class="line">       e.Name <span class="keyword">as</span> Employee,</span><br><span class="line">       e.Salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> Employee e, Department d</span><br><span class="line"><span class="keyword">where</span> e.DepartmentId = d.Id <span class="keyword">and</span></span><br><span class="line">      <span class="number">3</span> &gt; (</span><br><span class="line">          <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary)</span><br><span class="line">          <span class="keyword">from</span> Employee e2</span><br><span class="line">          <span class="keyword">where</span> e.Salary &lt; e2.Salary</span><br><span class="line">          <span class="keyword">and</span> e.DepartmentId = e2.DepartmentId</span><br><span class="line">      )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> d.Id, e.Salary <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><br><h3 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/" target="_blank" rel="noopener">196. 删除重复的电子邮箱</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200503142021.png" style="zoom:80%;" /><p><strong>方法一：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">Id</span> <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">Id</span>) <span class="keyword">as</span> <span class="keyword">id</span></span><br><span class="line">        <span class="keyword">from</span> Person</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line">    ) <span class="keyword">as</span> temp</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要套一层临时表，因为查询语句的输出不能作为更新语句的输入</p><p><strong>方法二：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用了表别名，delete后要加别名</span></span><br><span class="line"><span class="keyword">delete</span> p1 <span class="keyword">from</span> Person p1,Person p2</span><br><span class="line"><span class="keyword">where</span> p1.Email = p2.Email</span><br><span class="line">      <span class="keyword">and</span> p1.Id &gt; p2.Id;</span><br></pre></td></tr></table></figure><br><h3 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">197. 上升的温度</a></h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200503143419.png" style="zoom:80%;" /><p>MySQL 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_datediff" target="_blank" rel="noopener">DATEDIFF</a> 来比较两个日期类型的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> w1.Id </span><br><span class="line"><span class="keyword">from</span> Weather w1, Weather w2</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">DATEDIFF</span>(w1.RecordDate,w2.RecordDate) = <span class="number">1</span> <span class="keyword">AND</span></span><br><span class="line">      w1.Temperature &gt; w2.Temperature;</span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      LeetCode
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库编程</title>
    <link href="https://aaronyard.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>https://aaronyard.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</id>
    <published>2020-03-30T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:27.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库编程就是用编程方法对数据库进行操纵的技术，SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足（没有逻辑控制能力），提高应用系统和数据库管理系统间的互操作性。</p><p>使用 SQL 编程来访问和管理数据库中数据的方式主要有：</p><ul><li>嵌入式 SQL （ESQL）</li><li>过程化 SQL （PL/SQL）</li><li>存储过程和自定义函数</li><li>开放数据库互连（ODBC）</li><li>Java 数据库连接 （JDBC）</li></ul></blockquote><h1 id="一、嵌入式-SQL"><a href="#一、嵌入式-SQL" class="headerlink" title="一、嵌入式 SQL"></a>一、嵌入式 SQL</h1><a id="more"></a><h2 id="1-嵌入式-SQL-的处理过程"><a href="#1-嵌入式-SQL-的处理过程" class="headerlink" title="1. 嵌入式 SQL 的处理过程"></a>1. 嵌入式 SQL 的处理过程</h2><p>嵌入式 SQL 就是将 SQL 语句嵌入程序语言中，被嵌入的程序设计语言比如 Java 就称为宿主语言 / 主语言。</p><p>数据库对 嵌入式 SQL 一般采取预编译方法处理，识别出嵌入式 SQL 语句，将其转换为主语言调用语句。</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200430221444.png" alt=""></p><p>为了能快速区分 SQL 语句与主语言语句，所有 SQL 语句必须加前缀。</p><ul><li><p><strong>主语言 C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></table></figure></li><li><p><strong>主语言 Java</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># SQL &#123;&lt;SQL语句&gt;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-嵌入式-SQL-语句与主语言之间的通信"><a href="#2-嵌入式-SQL-语句与主语言之间的通信" class="headerlink" title="2. 嵌入式 SQL 语句与主语言之间的通信"></a>2. 嵌入式 SQL 语句与主语言之间的通信</h2><p>SQL 语句负责操纵数据库，宿主语言负责控制逻辑流程。这时程序中会含有两种不同计算模型的语句，它们之间该如何通信呢？</p><ul><li><p>SQL 语句执行后，系统将包含描述系统当前状态和运行环境的各种数据送到 <strong>SQL 通信区</strong>，应用程序从 SQL 通信区取出这些状态信息，据此决定接下来执行的语句</p></li><li><p>主语言向 SQL 提供参数，主要用<strong>主变量</strong>实现</p><p>SQL 语句中使用的宿主语言的程序变量称为主变量</p></li><li><p>将 SQL 语句的处理结果交给宿主语言处理，主要用主变量和<strong>游标</strong>实现</p><p>游标是面向集合的，<strong>一条 SQL 语句可以产生或处理多条记录；而主语言是面向记录的，一组主变量一次只能存放一条记录。为此引入游标来协调这两种不同的处理方式</strong></p></li></ul><h2 id="3-游标"><a href="#3-游标" class="headerlink" title="3. 游标"></a>3. 游标</h2><p>使用游标的四个步骤：</p><ul><li><p><strong>声明游标，这个过程没有实际检索出数据</strong>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span>语句;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br></pre></td></tr></table></figure></li><li><p><strong>打开游标；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 游标名</span><br></pre></td></tr></table></figure></li><li><p><strong>推进游标，取出数据；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH 游标名 INTO 主变量 [指示变量] [,主变量 [指示变量]]</span><br></pre></td></tr></table></figure><p>[ ] 表示可选的</p><p>主变量就是 select 语句查询的对应列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch mycursor into ret;</span><br><span class="line"><span class="keyword">select</span> ret;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭游标；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close 游标名</span><br></pre></td></tr></table></figure></li></ul><br><h1 id="二、过程化-SQL"><a href="#二、过程化-SQL" class="headerlink" title="二、过程化 SQL"></a>二、过程化 SQL</h1><h2 id="1-定义和执行"><a href="#1-定义和执行" class="headerlink" title="1. 定义和执行"></a>1. 定义和执行</h2><p><strong>定义</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DEClARE</span> 变量/游标/常量/异常等</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SQL</span>语句、过程化<span class="keyword">SQL</span>的流程控制语句</span><br><span class="line"><span class="keyword">EXCEPTION</span></span><br><span class="line">异常处理部分</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><h3 id="①-条件控制语句"><a href="#①-条件控制语句" class="headerlink" title="① 条件控制语句"></a>① 条件控制语句</h3><p><strong>IF 语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF 条件 THEN</span><br><span class="line">SQL语句;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure><p><strong>IF - ELSE 语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF 条件 THEN</span><br><span class="line">SQL语句;</span><br><span class="line">ELSE</span><br><span class="line">SQL语句;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure><p><strong>嵌套的 IF 语句</strong></p><p>THEN和ELSE子句中还能再包含 IF 语句</p><h3 id="②-循环控制语句"><a href="#②-循环控制语句" class="headerlink" title="② 循环控制语句"></a>② 循环控制语句</h3><p><strong>LOOP</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">SQL 语句;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p><strong>WHILE-LOOP</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE 条件 LOOP</span><br><span class="line">SQL 语句;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p><strong>FOR-LOOP</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR count IN [REVERSE] 循环下界1 循环上界2 LOOP</span><br><span class="line">SQL 语句;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p>小于循环下界或者大于循环上界就退出循环，指定了 REVERSE 则反之</p><br><h1 id="三、存储过程"><a href="#三、存储过程" class="headerlink" title="三、存储过程"></a>三、存储过程</h1><p>存储过程是由 过程化 SQL 编写的过程，这个过程经编译和优化后存储在数据库服务器中，因此称它为存储过程，使用时只要调用即可</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。<strong>可以使用 delemiter 自定义结束符</strong></p><p>包含 in 输入参数（默认）、out 输出参数 和 inout 输入/输出参数 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p><strong>创建存储过程</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(参数)</span><br><span class="line"><span class="keyword">as</span> 过程化<span class="keyword">SQL</span>块</span><br></pre></td></tr></table></figure><p><strong>执行存储过程：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>/PERFORM <span class="keyword">PROCEDURE</span> 过程名(参数<span class="number">1</span>,参数<span class="number">2.</span>..);</span><br></pre></td></tr></table></figure><p><strong>删除存储过程：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 过程名();</span><br></pre></td></tr></table></figure><p><strong>存储过程示例：</strong></p><p>从账户1转账到账户2，Account(Accountnum 账户号码, Total 余额)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数：转入账户、转出账户、转账额度</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> transfer(inAccount <span class="built_in">int</span>, outAccount <span class="built_in">int</span>, amount <span class="built_in">float</span>)</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">declare</span></span><br><span class="line">totalDepositOut <span class="built_in">float</span>; // 转出账户的额度</span><br><span class="line">totalDepositIn float; //转入账户的额度</span><br><span class="line">inAccountnum int; // 转入账户号码</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">select</span> Total <span class="keyword">into</span> totalDepositOut <span class="keyword">from</span> <span class="keyword">Account</span> <span class="keyword">where</span> Accountnum = outAccount</span><br><span class="line"><span class="keyword">IF</span> totalDepositOut <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> //如果转出账户没有存款</span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    RETURN;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">IF totalDepositOut &lt; amount THEN // 转出账户余额 &lt; 需转额度</span><br><span class="line">ROLLABCK;</span><br><span class="line">RETURN;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">SELECT</span> Accountnum <span class="keyword">INTO</span> inAccount <span class="keyword">From</span> <span class="keyword">Account</span></span><br><span class="line"><span class="keyword">WHERE</span> Accountnum = inAccount; //给参数 转入账户 赋值</span><br><span class="line">IF inAccountnum IS NULL THEN // 转入账户不存在</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line">RETURN;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">Account</span> <span class="keyword">SET</span> Total = Total - amount </span><br><span class="line"><span class="keyword">WHERE</span> Accountnum = outAccount; //修改转出账户余额</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">Account</span> <span class="keyword">Set</span> Total = Total + amount</span><br><span class="line"><span class="keyword">WHERE</span> Accountnum = inAccount; //修改转入账户余额</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      10-数据库编程
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>事务处理-并发控制</title>
    <link href="https://aaronyard.github.io/2020/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/9-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>https://aaronyard.github.io/2020/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/9-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2020-03-29T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:32.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章以及上一章的并发控制都是关于<strong>事务处理</strong>技术的。</p><p><strong>事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。</strong></p><p>事务处理技术主要包括</p><ul><li>数据库恢复技术（上一章）</li><li><strong>并发控制技术</strong></li></ul></blockquote><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200429181735.png" alt=""></p><br><a id="more"></a><h1 id="一、并发事务带来的问题"><a href="#一、并发事务带来的问题" class="headerlink" title="一、并发事务带来的问题"></a>一、并发事务带来的问题</h1><blockquote><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p></blockquote><h2 id="1-脏读（Dirty-read）"><a href="#1-脏读（Dirty-read）" class="headerlink" title="1. 脏读（Dirty read）"></a>1. 脏读（Dirty read）</h2><p><strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据</strong>。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据” ，依据 “脏数据” 所做的操作可能是不正确的。<br> （T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。）</p> <img src="https://gitee.com/xinxiban/images/raw/master/img/20200506101423.png" style="zoom:80%;" /><h2 id="2-丢失修改（Lost-update）"><a href="#2-丢失修改（Lost-update）" class="headerlink" title="2. 丢失修改（Lost update）"></a>2. 丢失修改（Lost update）</h2><p>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。<br> （T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。）</p> <img src="https://gitee.com/xinxiban/images/raw/master/img/20200506101609.png" style="zoom:80%;" /><h2 id="3-不可重复读（no-repeatable-read）"><a href="#3-不可重复读（no-repeatable-read）" class="headerlink" title="3. 不可重复读（no-repeatable read）"></a>3. 不可重复读（no-repeatable read）</h2><p><strong>一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br> （T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同）</p> <img src="https://gitee.com/xinxiban/images/raw/master/img/20200506101913.png" style="zoom:80%;" /><h2 id="4-幻读（Phantom-read）"><a href="#4-幻读（Phantom-read）" class="headerlink" title="4. 幻读（Phantom read）"></a>4. 幻读（Phantom read）</h2><p>幻读与不可重复读类似。<strong>它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</strong><br> （T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同）</p> <img src="https://gitee.com/xinxiban/images/raw/master/img/20200506102124.png" style="zoom:80%;" /><br><blockquote><p>⚠ <strong>不可重复度和幻读区别</strong>：</p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p><strong>例1</strong>（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：</p><p>事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p><p><strong>例2</strong>（同样的条件, 第1次和第2次读出来的记录数不一样 ）：</p><p>假如某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p></blockquote><br><h1 id="二、封锁"><a href="#二、封锁" class="headerlink" title="二、封锁"></a>二、封锁</h1><p>并发控制的主要技术有封锁 locking、时间戳 timestamp、乐观控制法 optimistic scheduler 和多版本控制 MVCC 等</p><p>封锁是众多数据库产品采用的基本方法。</p><p>所谓封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁，在事务T释放它的锁之前，其他事务不更新此对象。</p><p>确切的控制由封锁的类型决定，如下</p><h2 id="1-封锁类型"><a href="#1-封锁类型" class="headerlink" title="1. 封锁类型"></a>1. 封锁类型</h2><p>基本的封锁类型有两种：排他锁 X 锁 和 共享锁 S锁</p><h3 id="①-排他锁-X-锁-写锁"><a href="#①-排他锁-X-锁-写锁" class="headerlink" title="① 排他锁 - X 锁/写锁"></a>① 排他锁 - X 锁/写锁</h3><p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和修改。</p><p><strong>加X锁期间其它事务不能对 A 加任何锁</strong>。这就保证了其他事务在该事务释放X锁之前不能读取和修改A</p><h3 id="②-共享锁-S-锁-读锁"><a href="#②-共享锁-S-锁-读锁" class="headerlink" title="② 共享锁 - S 锁/读锁"></a>② 共享锁 - S 锁/读锁</h3><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。</p><p><strong>加S锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</strong>这就保证了其他事务可以读A，但在该事务释放S锁之前不能对A进行修改</p><h3 id="③-数据锁相容矩阵"><a href="#③-数据锁相容矩阵" class="headerlink" title="③ 数据锁相容矩阵"></a>③ 数据锁相容矩阵</h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420120236.png" style="zoom:80%;" /><h2 id="2-封锁协议-三级封锁协议"><a href="#2-封锁协议-三级封锁协议" class="headerlink" title="2. 封锁协议 - 三级封锁协议"></a>2. 封锁协议 - 三级封锁协议</h2><p>在运用X锁和S锁对数据对象加锁的时候，还需要约定一些规则。比如何时申请X锁或S锁、持锁时间、何时释放等。这些规则称为封锁协议。此处介绍的是三级封锁协议，后续还有两段锁协议</p><h3 id="①-一级封锁协议"><a href="#①-一级封锁协议" class="headerlink" title="① 一级封锁协议"></a>① 一级封锁协议</h3><p><strong>事务 T 要<code>修改数据 A 时必须加 X 锁</code>，直到 T 结束才释放锁。</strong></p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p>但不能解决读脏数据和不可重复读的问题，因为在一级封锁协议中，仅仅读数据而对其进行修改是不需要进行加锁的</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200429173918.png" style="zoom:80%;" /><h3 id="②-二级封锁协议"><a href="#②-二级封锁协议" class="headerlink" title="② 二级封锁协议"></a>② 二级封锁协议</h3><p><strong>在一级的基础上，要求<code>读取数据 A 时必须加 S 锁, 读取完马上释放 S 锁。</code></strong></p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p>但不能解决不可重复读问题，因为读完数据后就释放S锁，其他事务可以再加锁进行修改</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200429175013.png" style="zoom:80%;" /><h3 id="③-三级封锁协议"><a href="#③-三级封锁协议" class="headerlink" title="③ 三级封锁协议"></a>③ 三级封锁协议</h3><p><strong>在一级协议的基础上，要求<code>读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁</code>。</strong></p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200429180404.png" alt=""></p><h3 id="④-三级封锁协议总结"><a href="#④-三级封锁协议总结" class="headerlink" title="④ 三级封锁协议总结"></a>④ 三级封锁协议总结</h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420122416.png" style="zoom:80%;" /><br><h1 id="三、活锁和死锁"><a href="#三、活锁和死锁" class="headerlink" title="三、活锁和死锁"></a>三、活锁和死锁</h1><p>和操作系统一样，封锁的方法可能引起活锁和死锁问题</p><h2 id="1-活锁"><a href="#1-活锁" class="headerlink" title="1. 活锁"></a>1. 活锁</h2><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420122757.png" style="zoom:80%;" /><p>避免活锁的方法就是采用先来先服务的策略。</p><h2 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h2><p>事务T1封锁数据R1，事务T2封锁数据R2，T1请求R2, T2请求R1，于是事务T1等待事务T2释放锁，事务T2也等待事务T1释放锁，两个事务循环等待，永远不能结束。如上图 b 所示</p><h2 id="3-死锁的处理和预防"><a href="#3-死锁的处理和预防" class="headerlink" title="3. 死锁的处理和预防"></a>3. 死锁的处理和预防</h2><p>对于死锁问题，要么采取措施预防死锁发生，要么允许死锁发生，检测到死锁后采取策略解除死锁</p><h3 id="①-死锁的预防"><a href="#①-死锁的预防" class="headerlink" title="① 死锁的预防"></a>① 死锁的预防</h3><p>破坏产生死锁的条件</p><ul><li><p><code>一次封锁法</code></p><p>每个事务必须一次性将所有需要的数据全部加锁，否则不能执行</p></li><li><p><code>顺序封锁法</code></p><p>预先对数据对象规定一个封锁顺序，所有事务都按照整个顺序进行封锁</p></li></ul><h3 id="②-死锁的检测和处理"><a href="#②-死锁的检测和处理" class="headerlink" title="② 死锁的检测和处理"></a>② 死锁的检测和处理</h3><ul><li><p><code>超时法</code></p><p>如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</p></li><li><p><code>等待图法</code></p><p>事务等待图是一个有向图 G = (T, U) ，T是结点的集合，每个结点表示正在运行的事务；U为边的集合，每条边表示事务等待的情况，T1——&gt;T2 表示 T1 正在等待 T2.</p><p>如果图中存在回路，则表示系统中出现了死锁</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420132225.png" style="zoom:80%;" /></li></ul><br><p>数据库检测到死锁后，一般采取的死锁解除策略是：选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去。</p><br><h1 id="四、并发调度的可串行性"><a href="#四、并发调度的可串行性" class="headerlink" title="四、并发调度的可串行性"></a>四、并发调度的可串行性</h1><p>数据库管理系统对并发事务不同的调度可能会产生不同的结果，只有串行调度才能得到正确的结果</p><h2 id="1-可串行化调度"><a href="#1-可串行化调度" class="headerlink" title="1. 可串行化调度"></a>1. 可串行化调度</h2><p>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为 <code>可串行 serializable 调度</code>。</p><p><strong>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</strong></p><p><strong>示例：</strong></p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420133905.png" style="zoom:80%;" /><h2 id="2-冲突可串行化调度"><a href="#2-冲突可串行化调度" class="headerlink" title="2. 冲突可串行化调度"></a>2. 冲突可串行化调度</h2><p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作</p><p>不同事务或者同一事务的冲突操作时不能交换的。</p><p>一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度B，则称调度B是<code>冲突可串行化</code>的调度。</p><p>若一个调度是冲突可串行化调度，那么一定是可串行化调度</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420134504.png" style="zoom:80%;" /><br><h1 id="五、两段锁协议"><a href="#五、两段锁协议" class="headerlink" title="五、两段锁协议"></a>五、两段锁协议</h1><p>目前数据库管理系统普遍采用 <code>两段锁 TwoPhase Locking 协议</code>（简称 2PL）的的方法实现并发调度的可串行性，从而保证调度的正确性</p><p>两段锁协议就是指<strong>所有事务必须分两个阶段对数据项进行加锁和解锁</strong></p><ul><li><strong>扩展阶段</strong>：在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁</li><li><strong>收缩阶段</strong>：在释放一个封锁的时候，事务不再申请和获得任何其他锁</li></ul><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420140023.png" style="zoom:80%;" /><br><h1 id="六、封锁的粒度"><a href="#六、封锁的粒度" class="headerlink" title="六、封锁的粒度"></a>六、封锁的粒度</h1><p>封锁对象的大小称为 <code>封锁粒度 granularity</code></p><p>MySQL 中提供了两种封锁粒度：<code>行级锁</code> 以及 <code>表级锁</code> 。</p><blockquote><ul><li>表级锁： MySQL中锁定 粒度最大 的一种锁，<strong>对当前操作的整张表加锁</strong>，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li><li>行级锁： MySQL中锁定 粒度最小 的一种锁，<strong>只针对当前操作的行进行加锁</strong>。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul></blockquote><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是<strong>加锁需要消耗资源</strong>，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。<strong>因此封锁粒度越小，系统开销就越大。</strong></p><p>因此如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为 <code>多粒度封锁 multiple granularity locking</code></p><h2 id="1-多粒度封锁"><a href="#1-多粒度封锁" class="headerlink" title="1. 多粒度封锁"></a>1. 多粒度封锁</h2><p>首先我们需要知道<code>多粒度树</code>：多粒度树的根节点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度</p><p>下图给出了一个三级粒度树</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420141411.png" style="zoom:80%;" /><p>多粒度封锁协议允许多粒度树中的每个结点被独立的加锁，<strong>对一个结点加锁意味着这个结点的所有后裔结点都被加以同样的锁</strong></p><ul><li><code>显示封锁</code>：应事务的要求直接加到数据对象上的锁</li><li><code>隐式封锁</code>：该数据对象没有被独立加锁，继承上级结点的锁</li></ul><p>系统检查封锁冲突时不仅要检查显示封锁，还要检查隐式封锁。</p><p>显然，这样的检查方法效率很低，为此人们引进了<strong>意向锁</strong></p><h2 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h2><p>意向锁表示<strong>如果对一个结点加锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁</strong></p><p>例如：对任一元组加锁时，必须先对它所在的关系或者数据库加意向锁</p><p>下面介绍三种常用的意向锁</p><h3 id="①-IS-锁"><a href="#①-IS-锁" class="headerlink" title="① IS 锁"></a>① IS 锁</h3><p>如果对一个数据对象加 IS 锁，则表示它的后裔结点想要加 S 锁</p><h3 id="②-IX-锁"><a href="#②-IX-锁" class="headerlink" title="② IX 锁"></a>② IX 锁</h3><p>如果对一个数据对象加 IX 锁，则表示它的后裔结点想要加 X 锁</p><h3 id="③-SIX-锁"><a href="#③-SIX-锁" class="headerlink" title="③ SIX 锁"></a>③ SIX 锁</h3><p>如果对一个数据对象加 SIX 锁，则表示对他加 S 锁，再加 IX 锁</p><p>例如对某个表加 SIX 锁，则表示该事务先要读整个表，读表过程中不允许其他事务进行修改；读表的同时还会对该表中的个别元组进行修改，所以加 IX 锁，表示表下面的元组想要加X锁。</p><h3 id="④-数据锁相容矩阵"><a href="#④-数据锁相容矩阵" class="headerlink" title="④ 数据锁相容矩阵"></a>④ 数据锁相容矩阵</h3><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420142816.png" style="zoom:80%;" /><p>从上图我们可以看出锁的强弱程度，即对其他锁的排斥程度。一个事务在申请封锁的时候，以强锁代替弱锁时安全的，反之则不然</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420143232.png"  /><p><strong>总结如下：</strong></p><ul><li>X 锁 不兼容任何锁</li><li>任意IS / IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁</li><li>这里兼容关系针对的是表级锁，而 <code>表级的 IX 锁和行级的 X 锁兼容</code>，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><br><h1 id="七、事务的隔离级别"><a href="#七、事务的隔离级别" class="headerlink" title="七、事务的隔离级别"></a>七、事务的隔离级别</h1><p>事务具有隔离性，理论上说事务之间的执行不应该相互影响，其读数据库的影响应该和他们串行时执行一样。<br>完全的隔离性会导致系统并发性能很低，降低对资源的利用率，因而实际上会对隔离性的要求会有所放松。</p><p>SQL 标准为事务定义了四个不同的隔离级别，从低到高依次是：</p><ul><li><p><code>READ-UNCOMMITTED(读取未提交)</code>：</p><p>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p><code>READ-COMMITTED(读取已提交)</code>：</p><p>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p><code>REPEATABLE-READ(可重复读)</code>：</p><p>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p><code>SERIALIZABLE(可串行化)</code>：</p><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br> （该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。）</p></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td><strong>×</strong></td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td><strong>×</strong></td><td><strong>×</strong></td><td>√</td></tr><tr><td>SERIALIZABLE</td><td><strong>×</strong></td><td><strong>×</strong></td><td><strong>×</strong></td></tr></tbody></table><blockquote><p><strong>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</strong></p><p>这里需要注意的是：与 SQL 标准不同的地方在于 <strong>InnoDB 存储引擎在REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)</strong> 隔离级别。</p><br><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p></blockquote><br><h1 id="八、DBMS保证事务的ACID特性原理"><a href="#八、DBMS保证事务的ACID特性原理" class="headerlink" title="八、DBMS保证事务的ACID特性原理"></a>八、DBMS保证事务的ACID特性原理</h1><p>结合上一章和本章的内容，我们来总结一下数据库管理系统是如何保证事务的ACID特性的。</p><p>首先，事务的原子性、持久性、隔离性都是为了实现事务的一致性</p><h2 id="1-原子性实现原理-Undo-Log"><a href="#1-原子性实现原理-Undo-Log" class="headerlink" title="1. 原子性实现原理 - Undo Log"></a>1. 原子性实现原理 - Undo Log</h2><p><strong>为了实现原子性，需要通过日志</strong>：将所有对数据更新操作都写入日志，如果一个事务中的一部分已经操作成功，但以后的操作由于断电/系统崩溃/其他软硬件错误或者用户提交了rollback 导致无法进行，则通过回溯日志，<strong>将已经执行成功的操作撤销 undo</strong>，从而达到全部操作失败的目的，使得数据库恢复到一致性的状态，可以继续被使用。</p><h2 id="2-持久性实现原理-Redo-Log"><a href="#2-持久性实现原理-Redo-Log" class="headerlink" title="2. 持久性实现原理 - Redo Log"></a>2. 持久性实现原理 - Redo Log</h2><p>和Undo Log 相反，<strong>Redo（重做） Log 记录的是新数据的备份</strong>。在事务提交前，只是将Redo Log 持久化即可，不需要数据持久化。当系统崩溃时，虽然数据没有持久化，但Redo Log 已经持久化了。<strong>系统可以根据Redo Log 将数据更新到最新的状态。</strong></p><h2 id="3-隔离性实现原理-锁"><a href="#3-隔离性实现原理-锁" class="headerlink" title="3. 隔离性实现原理 - 锁"></a>3. 隔离性实现原理 - 锁</h2><p>当然，保证事务的隔离性，即并发控制不止可用封锁协议，还有时间戳、多版本控制等等。</p><p><strong>基于锁的并发控制流程：</strong></p><ul><li>事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排它锁）。</li><li>申请锁的请求被发给锁管理器。锁管理器根据当前页是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁。</li><li>若锁被授予，则申请锁的事务可以被继续执行；若被拒绝，则申请锁的事务将进行等待，直到锁被其它事务释放。</li></ul><p><strong>可能出现的问题：</strong></p><ul><li>死锁：多个事务持有锁并循环等待其它事务的锁导致所有的事务都无法继续执行。</li></ul>]]></content>
    
    <summary type="html">
    
      9-事务处理-并发控制
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>事务处理-数据库恢复技术</title>
    <link href="https://aaronyard.github.io/2020/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93/8-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <id>https://aaronyard.github.io/2020/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93/8-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</id>
    <published>2020-03-28T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:38.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章以及下一章的并发控制都是关于<strong>事务处理</strong>技术的。</p><p><strong>事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。</strong></p><p>事务处理技术主要包括</p><ul><li><strong>数据库恢复技术</strong></li><li>并发控制技术（下一章）</li></ul></blockquote><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200429181735.png" alt=""></p><br><a id="more"></a><h1 id="一、事务的基本概念"><a href="#一、事务的基本概念" class="headerlink" title="一、事务的基本概念"></a>一、事务的基本概念</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><p>事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p><p>一个程序包含多个事务。</p><br><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。</p><p>万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。<strong>事务就是保证这两个关键操作要么都成功，要么都要失败</strong>。</p><br><p>事务的开始和结束可以由用户显示控制，在SQL中，定义事务的语句有3条</p><ul><li><p><code>BEGIN TRANSACTION;</code> ： 事务以此语句开始</p></li><li><p><code>COMMIT;</code> : 提交事务的所有操作</p></li><li><p><code>RLLBACK;</code>：回滚</p><p>事务一般以 commit 或者 rollback 结束</p></li></ul><h2 id="2-事务的ACID特性"><a href="#2-事务的ACID特性" class="headerlink" title="2. 事务的ACID特性"></a>2. 事务的ACID特性</h2><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420101415.png" alt=""></p><ul><li><code>原子性（Atomicity）</code><br><strong>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</strong> </li><li><code>一致性（Consistency）</code><br><strong>数据库在事务执行前后都保持一致性状态</strong>。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。<br>例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的.</li><li><code>隔离性（Isolation）</code><br><strong>一个事务的执行不能被其他事务干扰</strong>，即一个事务的内部操作即使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><code>持久性（Durability）</code><br><strong>一旦事务提交，则其所做的修改将会永远保存到数据库中</strong>。接下来的操作和故障不应该对其执行结果有任何影响</li></ul><h2 id="3-事务的ACID特性遭到破坏的因素"><a href="#3-事务的ACID特性遭到破坏的因素" class="headerlink" title="3. 事务的ACID特性遭到破坏的因素"></a>3. 事务的ACID特性遭到破坏的因素</h2><p>事务时恢复和并发控制的基本单位，保证事务ACID特性是事务管理的重要任务，事务ACID特性可能遭到破坏的因素有：</p><ul><li>多个事务并发执行，相互干扰</li><li>事务在运行过程中被强行终止</li></ul><br><h1 id="二、数据库恢复技术作用"><a href="#二、数据库恢复技术作用" class="headerlink" title="二、数据库恢复技术作用"></a>二、数据库恢复技术作用</h1><p>数据库恢复技术就是把数据库从错误状态恢复到某一已知的正确状态。</p><p>数据恢复技术是衡量系统性能优劣的重要指标</p><br><h1 id="三、故障的种类"><a href="#三、故障的种类" class="headerlink" title="三、故障的种类"></a>三、故障的种类</h1><h2 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h2><p>事务内部的故障更多是非预期的、不能由应用程序处理的故障。一般我们所说的事务故障都是指这类非预期故障。</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200420103114.png" style="zoom:85%;" /><p>事务故障意味着事务没有到达预期的终点（commit 或者 rollback）因此，数据库可能处于不正确的状态。</p><p>恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务已经做出的任何对数据库的修改。这类恢复操作称为 <code>事务撤销 UNDO</code></p><h2 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h2><p><strong>系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。</strong></p><p>例如，特定类型的硬件错误(CPU故障) 、操作系统故障、DBMS代码错误、系统断电等。这类故障影响正在运行的所有事务，但不破坏数据库。此时主存内容，尤其是数据库缓冲区 中的内容都被丢失，所有运行事务都非正常终止。发生系统故障时，一些 尚未完成的事务的结果可能已送入物理数据库，从而造成数据库可能处于不正确的状态。为保证数据库的一致性，需要清除这些事务对数据库的所有修改。<br><br><br>所以系统重新启动后， 恢复子系统除需要撤销所有未完成的事务外， 还需要<code>重做(REDO)</code>所有已提交的事务，以将数据库真正恢复到一致状态</p><h2 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h2><p>系统故障称为<strong>软故障</strong>，介质故障称为<strong>硬故障</strong>。</p><p><strong>硬故障指外存损坏</strong>，比如磁盘损坏等</p><h2 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h2><br><h1 id="四、恢复的实现技术"><a href="#四、恢复的实现技术" class="headerlink" title="四、恢复的实现技术"></a>四、恢复的实现技术</h1><p>恢复的基本原理十分简单。可以用一个词来概括，<strong>冗余</strong>。就是说数据库中任何一部分被破坏或者不正确的数据都可以根据存储在系统别处的冗余数据来重建。</p><p>恢复机制涉及的两个关键问题就是：</p><ul><li>如何建立冗余数据（数据转储 + 登记日志文件 logging）</li><li>如何利用冗余数据实现数据库恢复</li></ul><h2 id="1-数据转储"><a href="#1-数据转储" class="headerlink" title="1. 数据转储"></a>1. 数据转储</h2><p>数据转储就是管理员定期的将整个数据库复制到磁带、磁盘或其他存储介质上。这些备用的数据称为<strong>后备副本 backup</strong></p><p>重装后备副本只能将数据库恢复到转储时的状态，其之后的事务操作都必须重新执行一遍才能恢复到故障发生时的状态。</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200423105029.png" style="zoom:80%;" /><p>转储十分耗时，不能频繁进行。</p><h2 id="2-登记日志文件"><a href="#2-登记日志文件" class="headerlink" title="2. 登记日志文件"></a>2. 登记日志文件</h2><p>日志文件中需要登记的内容包括：</p><ul><li>各个事务的开始标记</li><li>各个事务的结束标记</li><li>各个事务的更新操作</li></ul><p>登记日志文件时必须遵循两条原则</p><ul><li>登记的次序必须严格按照并发事务执行的时间次序</li><li>必须先写日志文件，后进行数据库操作</li></ul>]]></content>
    
    <summary type="html">
    
      8-事务处理-数据库恢复技术
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>查询处理和优化</title>
    <link href="https://aaronyard.github.io/2020/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/7-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>https://aaronyard.github.io/2020/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/7-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-27T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:41.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、查询处理"><a href="#一、查询处理" class="headerlink" title="一、查询处理"></a>一、查询处理</h1><p>查询处理是数据库管理系统把用户提交上来的查询语句转换成高效的查询执行计划。</p><p>关系数据库管理系统查询处理可以分为4个阶段：</p><ul><li>查询分析</li><li>查询检查</li><li>查询优化</li><li>查询执行</li></ul><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200417110226.png" alt=""></p><h2 id="1-查询分析"><a href="#1-查询分析" class="headerlink" title="1. 查询分析"></a>1. 查询分析</h2><p><strong>首先对查询语句进行扫描、语法分析和词法分析</strong>。从查询语句中识别出语言符号，如SQL关键字、属性名和关系名等，进行语法检查和语法分析，<strong>判断查询语句是否符合SQL语法规则</strong></p><a id="more"></a><h2 id="2-查询检查"><a href="#2-查询检查" class="headerlink" title="2. 查询检查"></a>2. 查询检查</h2><p><strong>对合法的查询语句进行语义检查，即检查数据库对象，如关系名、属性名是否存在和有效。</strong></p><p>还要根据用户权限和完整性约束定义对用户的存取权限进行检查。如果用户没有相应权限或者违反了完整性约束，就拒绝执行该查询。</p><p>检查过后将SQL查询语句转成内部表示即等价的关系代数表达式，一般用 <strong>查询树 / 语法分析树</strong> 来表示扩展的关系代数表达式</p><h2 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h2><p><strong>查询优化就是优化器选择一个高效执行的查询处理策略，以获得最好的查询优化效果</strong></p><p>按照优化的层次分为代数优化和物理优化</p><h2 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h2><p>根据优化器得到的执行策略生成查询执行计划，由代码生成器生成执行这个查询计划的代码，然后加以执行，并返回查询结果</p><br><h1 id="二、实现查询操作的算法"><a href="#二、实现查询操作的算法" class="headerlink" title="二、实现查询操作的算法"></a>二、实现查询操作的算法</h1><h2 id="1-选择操作的实现"><a href="#1-选择操作的实现" class="headerlink" title="1. 选择操作的实现"></a>1. 选择操作的实现</h2><h3 id="①-全表扫描算法-table-scan"><a href="#①-全表扫描算法-table-scan" class="headerlink" title="① 全表扫描算法 table scan"></a>① 全表扫描算法 table scan</h3><p>适用于规模较小的表。</p><p>对于大规模的表，当选择率较低时，这个算法的效率很低</p><h3 id="②-索引扫描算法-index-scan"><a href="#②-索引扫描算法-index-scan" class="headerlink" title="② 索引扫描算法 index scan"></a>② 索引扫描算法 index scan</h3><p>如果选择条件中的属性上有索引，可以用索引扫描算法，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组</p><h2 id="2-连接操作的实现-多表连接"><a href="#2-连接操作的实现-多表连接" class="headerlink" title="2. 连接操作的实现 / 多表连接"></a>2. 连接操作的实现 / 多表连接</h2><p>以下面这条 SQL 语句为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student,SC <span class="keyword">where</span> Student.Sno = SC.Sno;</span><br></pre></td></tr></table></figure><h3 id="①-嵌套循环算法-nested-loop"><a href="#①-嵌套循环算法-nested-loop" class="headerlink" title="① 嵌套循环算法 nested loop"></a>① 嵌套循环算法 nested loop</h3><p>最简单可行的算法。</p><ul><li>取 Student 表的一个元组，与 SC 表的所有元组进行比较，凡满足连接条件的元组就进行连接并且作为结果输出。</li><li>然后再取 Student 表的下一个元组，与 S 的所有元组比较，直至 Student 表的所有元组与 SC 表的所有元组比较完毕为止。</li></ul><h3 id="②-排序-归并算法-sort-merge"><a href="#②-排序-归并算法-sort-merge" class="headerlink" title="② 排序-归并算法 sort-merge"></a>② 排序-归并算法 sort-merge</h3><p>等值连接常用的算法，如果 Student 表和 SC 表<strong>已经按连接属性排好序</strong>了，则可按序比较两个表的连接属性，找出匹配的所有元组。</p><p>核心思想：分别从两个表中取出一行元组进行比较，如果匹配就连接起来放入结果集；<strong>如果不匹配，将较小的那个元组丢弃，继续匹配这个表的下一行</strong>，依次处理直到将两表的数据取完。</p><blockquote><p>如果 Student 表 和 SC 表在做连接操作之前没有按连接属性进行排序，则我们需要事先为之排序，由于排序是开销很大的操作，在此情况下是否值得使用排序归并法，那就需要权衡了。</p></blockquote><h3 id="③-索引连接算法-index-join"><a href="#③-索引连接算法-index-join" class="headerlink" title="③ 索引连接算法 index join"></a>③ 索引连接算法 index join</h3><ul><li>在 SC 表上已经建立了 Sno 的索引</li><li>对 Student 中的每一个元组，在 SC 表中通过 Sno 的索引查找对应的 SC 元组，把相匹配的两个表中的元组连接起来。循环执行，直到 Student 表扫描结束</li></ul><h3 id="④-散列连接算法-hash-join"><a href="#④-散列连接算法-hash-join" class="headerlink" title="④ 散列连接算法 hash join"></a>④ 散列连接算法 hash join</h3><blockquote><p>🚨 Oracle 支持 hash join，MySQL 不支持</p></blockquote><p>用来处理等值连接。把连接属性作为 hash 的 value，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。</p><ul><li><strong>创建阶段</strong>：创建 hash 表。对包含较少元组的表进行处理，把他的元组按 hash 函数分散到 hahs 桶中（采用拉链法）</li><li><strong>连接阶段</strong>：对另一个表进行 hash。并把这个表中元组和上一个表中相匹配的元组（同义词）连接起来。如果一个桶中只有 Student 或者 SC 的元组，则不进行连接。</li></ul><br><h1 id="三、查询优化"><a href="#三、查询优化" class="headerlink" title="三、查询优化"></a>三、查询优化</h1><p>每个查询都会有许多可供选择的执行策略和操作算法，<strong>查询优化就是选择一个高效执行的查询处理策略</strong>。</p><p>查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统可以比用户程序的优化做的更好。</p><h2 id="1-代数优化"><a href="#1-代数优化" class="headerlink" title="1. 代数优化"></a>1. 代数优化</h2><p>代数优化就是通过对关系代数式的等价变换来提高查询效率</p><p>代数优化改变的是查询语句中操作的次序和组合，但不涉及底层的存取路径</p><br><p>最常用的优化原则是尽量缩减查询过程中的中间结果。由于选择、投影等一元操作分别从水平或垂直方向减少关系的大小，而连接、并等二元操作不但操作本身的开销较大，而且很可能产生大的中间结果。因此，再做查询优化时，总是让选择和投影先做，再做连接等二元操作。在连接时，也是先做小关系之间的连接，再做大关系之间的连接。</p><br><p><strong>常见的对关系表达式进行查询优化的方法有</strong>：</p><ul><li>选择运算尽可能先做</li><li>若投影运算和选择运算都是对同一个关系进行操作，则将投影运算和选择运算同时进行</li><li>把投影同其前或后的双目运算符结合起来</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个来连接运算（连接，特别是等值连接，要比同样关系上的笛卡尔积省很多时间）</li><li>找出公共子表达式（比如查询视图的时候，定义视图的表达式就是公共子表达式）</li></ul><h2 id="2-物理优化"><a href="#2-物理优化" class="headerlink" title="2. 物理优化"></a>2. 物理优化</h2><p>物理优化就是选择高效合理的操作算法或者存取路径来达到查询优化的目标</p><p>选择的方法如下：</p><ul><li>基于规则的启发式优化</li><li>基于代价估算的优化：选择代价最小的执行计划</li><li>两者结合的优化方法</li></ul><h3 id="①-基于规则的启发式优化"><a href="#①-基于规则的启发式优化" class="headerlink" title="① 基于规则的启发式优化"></a>① 基于规则的启发式优化</h3><p>🚩 <u>启发式优化：指的是在大部分情况下使用，但不是在所有情况下都是最好的规则</u></p><p><strong>1）对于选择操作的启发式规则</strong>：</p><ul><li>对于小关系，使用全表顺序扫描，即使选择列上有索引</li><li>对于大关系，启发式规则有：<ul><li>选择条件是 <code>主键 = 值</code>，采用主键索引</li><li>选择条件是 <code>非主属性 = 值</code>，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描</li><li>选择条件是 <code>非等值查询或范围查询</code>，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描</li><li>使用 <code>AND</code> 连接的合取选择条件，如果有涉及这些属性的组合索引，则优先使用索引，否则使用全表顺序扫描</li><li>对于 <code>OR</code> 连接的析取选择条件，一般使用全表顺序扫描</li></ul></li></ul><p><strong>2）对于连接操作的启发式规则</strong>：</p><ul><li>如果两个表都已经按照连接属性排序，则使用排序-合并算法</li><li>如果一个表在连接属性上有索引，则使用索引连接算法</li><li>如果上面两个规则不适用，且其中一个表较小，则使用 hash join 算法</li><li>最后可以使用嵌套循环算法</li></ul><h3 id="②-基于代价估算的优化"><a href="#②-基于代价估算的优化" class="headerlink" title="② 基于代价估算的优化"></a>② 基于代价估算的优化</h3><p>基于代价的优化方法要计算各种操作算法的执行代价，它与数据库的状态密切相关。为此在数据字典中存储了优化器需要的统计信息，主要包括以下几个方面：</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200512224228.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      7-查询处理和优化
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计之E-R图</title>
    <link href="https://aaronyard.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B9%8BE-R%E5%9B%BE/"/>
    <id>https://aaronyard.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B9%8BE-R%E5%9B%BE/</id>
    <published>2020-03-26T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:44.587Z</updated>
    
    <content type="html"><![CDATA[<p>P.P.S.Chen 提出的 E-R 模型使用 E-R 图来描述现实世界的概念模型。E-R 模型涉及的主要概念包括实体、属性、实体之间的联系等</p><ul><li><strong>实体 entity：</strong>客观存在并可相互区别的事物，比如一个学生，一门课，学生的一次选课</li><li><strong>属性：</strong>实体所具有的特性，比如学生的身高</li><li><strong>码：</strong>唯一标识实体的属性集，比如学生的学号</li><li><strong>实体型</strong>： 实体名+属性名，比如 <u>学生（学号，姓名，性别）</u>就是一个实体型</li><li><strong>实体集</strong>：同一类型的实体的集合，比如全体学生</li><li><strong>联系 relationship</strong>：实体之间的联系（有一对一，一对多，多对多等多种类型）</li></ul><br><a id="more"></a><h1 id="一、实体之间的联系"><a href="#一、实体之间的联系" class="headerlink" title="一、实体之间的联系"></a>一、实体之间的联系</h1><h2 id="1-两个实体6-型之间的联系"><a href="#1-两个实体6-型之间的联系" class="headerlink" title="1. 两个实体6-型之间的联系"></a>1. 两个实体6-型之间的联系</h2><p>可分为以下三种：</p><h3 id="①-一对一联系-1：1"><a href="#①-一对一联系-1：1" class="headerlink" title="① 一对一联系 1：1"></a>① 一对一联系 1：1</h3><p>例如一个班级一个只有班长，班长和班级之间具有一对一联系</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419162515.png" style="zoom: 80%;" /><h3 id="②-一对多联系-1：n"><a href="#②-一对多联系-1：n" class="headerlink" title="② 一对多联系 1：n"></a>② 一对多联系 1：n</h3><p>例如一个班级中有若干个学生，且每个学生只在一个班级中学习，班级与学生之间具有一对多联系</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419162536.png" style="zoom:80%;" /><h3 id="③-多对多联系-m：n"><a href="#③-多对多联系-m：n" class="headerlink" title="③ 多对多联系 m：n"></a>③ 多对多联系 m：n</h3><p>例如一门课程同时有若干个学生选修，而一个学生可以选修多个课程，则课程和学生之间具有多对多联系</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419162557.png" style="zoom:80%;" /><h2 id="2-两个以上实体型之间的联系"><a href="#2-两个以上实体型之间的联系" class="headerlink" title="2. 两个以上实体型之间的联系"></a>2. 两个以上实体型之间的联系</h2><p>两个以上实体型之间的联系也存在一对一，一对多，多对多的联系</p><p>例如，对于课程，教师，参考书三个实体型，一门课程可以有若干个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419163203.png" style="zoom:80%;" /><p>又如：对于供应商，项目，零件三个实体型，一个供应商可以给多个项目供应零件，每个项目可以使用多个供应商提供的零件，每种零件可由不同供应商提供，则供应商、项目、零件三者之间的关系就是多对多的联系</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419163220.png" style="zoom:80%;" /><h2 id="3-单个实体型内的联系"><a href="#3-单个实体型内的联系" class="headerlink" title="3. 单个实体型内的联系"></a>3. 单个实体型内的联系</h2><p>同一个实体型内的各实体之间也存在一对一、一对多、多对多的联系。</p><p>例如：职工实体型内部具有领导和被领导的联系，即某一职工领导若干名职工，而一个职工仅被另外一个职工直接领导，因此这是一对多的联系</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419163528.png" style="zoom:80%;" /><br><h1 id="二、E-R-图"><a href="#二、E-R-图" class="headerlink" title="二、E-R 图"></a>二、E-R 图</h1><h2 id="1-基本表示方法"><a href="#1-基本表示方法" class="headerlink" title="1. 基本表示方法"></a>1. 基本表示方法</h2><p>E-R 图提供了表示实体型、属性、联系的方法</p><p>例如：</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419164120.png" alt=""></p><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><p>下面用 E-R 图来表示某个工厂物资管理的概念模型</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419164431.png" style="zoom:80%;" /><p>E-R 图如下：</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419164942.png"  /><br><h1 id="三、E-R-图向关系模式的转换"><a href="#三、E-R-图向关系模式的转换" class="headerlink" title="三、E-R 图向关系模式的转换"></a>三、E-R 图向关系模式的转换</h1><h2 id="1-转换的一般原则"><a href="#1-转换的一般原则" class="headerlink" title="1. 转换的一般原则"></a>1. 转换的一般原则</h2><p>转换的一般原则：</p><ul><li><p><strong>一个实体型转换为一个关系模式</strong></p><ul><li>关系的属性就是实体的属性</li></ul></li><li><p>关系的码就是实体的码</p></li><li><p>一个 1：1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</p></li><li><p>一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并</p></li><li><p>一个 m：n 联系可以转换为一个独立的关系模式</p><ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体型码的组合</li></ul></li><li><p>三个或三个以上实体间的一个多元联系可以转换为一个关系模式</p><ul><li>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合 </li></ul></li><li><p>具有相同码的关系模式可合并</p><p>目的：减少系统中的关系个数</p></li></ul><h2 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2. 实例"></a>2. 实例</h2><p>物资管理的 E-R 图如下：</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200505222034.png" alt=""></p><ul><li><p><strong>一个实体型转换为一个关系模式：</strong></p><p>供应商（<u>供应商号</u>，姓名，地址，电话号，账号）</p><p>项目（项目号，预算，开工日期）</p><p>零件（<u>零件号</u>，名称，规格，单价，描述）</p><p>仓库（<u>仓库号</u>，面积，电话号）</p></li><li><p><strong>三个或三个以上实体间的一个多元联系可以转换为一个关系模式：</strong></p><p>供应（<u>供应商号，项目号，零件号</u>，供应量）</p></li><li><p><strong>一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并</strong></p><p>职工（<u>职工号</u>，姓名，年龄，职称，<u>仓库号</u>，领导职工号）</p></li><li><p><strong>一个 m：n 联系可以转换为一个独立的关系模式</strong></p><p>库存（<u>仓库号，零件号</u>，库存量）</p></li></ul>]]></content>
    
    <summary type="html">
    
      6-数据库设计之E-R图
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库设计理论</title>
    <link href="https://aaronyard.github.io/2020/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/5-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    <id>https://aaronyard.github.io/2020/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/5-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/</id>
    <published>2020-03-25T14:02:45.000Z</published>
    <updated>2020-09-04T15:50:47.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对一个具体问题，应该如何构造一个适合于它的数据库模式呢？</p></blockquote><h1 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h1><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069534079-7d87b554-ecf7-4201-b0a6-1d2bb51a16aa.png" alt="img" style="zoom:70%;" /><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><a id="more"></a><ul><li><strong>数据冗余</strong>：例如 学生 -2 出现了两次。</li><li><strong>更新异常</strong>：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li><strong>删除异常</strong>：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li><strong>插入异常</strong>：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><br><p>数据依赖是一个关系内部属性和属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间的相关联系。其中最重要的是函数依赖和多值依赖。</p><p>一个模式的数据依赖会有哪些不好的性质，如何改造一个不好的模式，这就是规范化要讨论的内容</p><br><h1 id="二、规范化"><a href="#二、规范化" class="headerlink" title="二、规范化"></a>二、规范化</h1><h2 id="1-规范化的目的"><a href="#1-规范化的目的" class="headerlink" title="1. 规范化的目的"></a>1. 规范化的目的</h2><ul><li><p><strong>关系数据库进行规范化的目的</strong>：使结构更合理，解决数据中可能出现的异常情况（比如数据冗余、更新异常、删除异常、插入异常），从而增强数据的稳定性和灵活性</p></li><li><p>关系模式进行规范化的原则：遵从概念单一化“一事一地”原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。</p></li><li><p>关系模式进行规范化的方法：将关系模式投影分解成两个或两个以上的关系模式。</p></li></ul><h2 id="2-函数依赖（functional-dependency，FD）"><a href="#2-函数依赖（functional-dependency，FD）" class="headerlink" title="2. 函数依赖（functional dependency，FD）"></a>2. 函数依赖（functional dependency，FD）</h2><h3 id="①-概念"><a href="#①-概念" class="headerlink" title="① 概念"></a>① 概念</h3><p>记 <code>A-&gt;B</code> 表示 <code>A 函数决定 B</code>，也可以说 <code>B 函数依赖于 A</code>。</p><p>在一个关系中，任意元组，若属性 A1,A2….An 一样，则属性 B1,B2…Bm 必一样，那么称 A1,A2…An 函数决定 B1,B2…Bm。</p><p>记号为 <code>A1,A2...An → B1,B2...Bm</code> Ai与Bi有函数依赖）</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069534144-7498a511-97ea-49c5-8d03-80e3cdf08364.png" alt="img"></p><p>如果 <code>{A1，A2，... ，An}</code> 是关系的一个或多个属性的集合，<strong>该集合函数决定了关系的其它所有属性并且是最小集合</strong>，那么该集合就称为 <strong>键码</strong>。</p><ul><li><p>对于 <code>A-&gt;B</code>，如果能找到 A 的<strong>真子集</strong> A’，使得 <code>A&#39;-&gt; B</code>，那么 A-&gt;B 就是 <strong>部分函数依赖</strong>，否则就是 <strong>完全函数依赖</strong>。</p></li><li><p>对于 <code>A-&gt;B，B-&gt;C</code>，则 <code>A-&gt;C</code> 是一个<strong>传递函数依赖</strong>。</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419140747.png" alt=""></p></li></ul><h3 id="②-范式理论"><a href="#②-范式理论" class="headerlink" title="② 范式理论"></a>② 范式理论</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p><strong>范式理论是为了解决以上提到四种异常。</strong></p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p>一个低一级的范式的关系模式通过模式分解可以转换为若干个高一级的关系模式的集合，这个过程就叫 <strong>规范化（normalization）</strong></p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419140206.png" style="zoom: 80%;" /><h4 id="Ⅰ-第一范式-1NF"><a href="#Ⅰ-第一范式-1NF" class="headerlink" title="Ⅰ 第一范式 (1NF)"></a>Ⅰ 第一范式 (1NF)</h4><p><strong>定义：</strong></p><p>属性不可分。<strong>可以认为任何表都属于第一范式</strong>，因为每个表的最小单位为表中的各个属性。</p><h4 id="Ⅱ-第二范式-2NF"><a href="#Ⅱ-第二范式-2NF" class="headerlink" title="Ⅱ 第二范式 (2NF)"></a>Ⅱ 第二范式 (2NF)</h4><p><strong>定义：</strong></p><p><strong>在满足第一范式前提下</strong>，在所有函数依赖表达式中，<strong>不存在 任何 候选键的真子集 决定 非主属性</strong>。即<strong>消除 非主属性 对于 主键 的 部分依赖，<u>使得非主属性完全依赖于主键</u></strong></p><p>一个关系模式不符合2NF定义，会导致如下问题</p><ul><li>插入异常</li><li>删除异常</li><li>修改复杂</li></ul><br><p><strong>实例：</strong></p><p>有关系模式 S-L-C（<u>Sno,Cno</u>,Sdept,Sloc,Grade)，其中Sloc为学生住处，并且每个系的学生住在同一个地方。则函数依赖有</p><ul><li>（Sno,Cno) — F —&gt; Grade</li><li>Sno ——&gt; Sdept，(Sno, Cno) — P —&gt; Sdept</li><li>Sno ——&gt; Sloc，(Sno, Cno) — P —&gt; Sloc</li><li>Sdept ——&gt; Sloc</li></ul><p>函数依赖关系图如图所示</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419170129.png" style="zoom:80%;" /><p>非主属性Sdept、Sloc并不完全函数依赖于主键/码，因此不符合2NF定义</p><p>解决的办法是用 <strong>投影</strong> 分解原先的关系模式 S-L-C（<u>Sno,Cno</u>,Sdept,Sloc,Grade)，分解为：</p><ul><li><p>SC(<u>Sno, Cno</u>, Grade)</p></li><li><p>S-L(<u>Sno</u>, Sdept, Sloc)</p><img src="C:\Users\19124\AppData\Roaming\Typora\typora-user-images\image-20200427173422370.png" alt="image-20200427173422370" style="zoom:67%;" /><p>这样就使得非主属性对主键是完全函数依赖了，满足第二范式</p></li></ul><h4 id="Ⅲ-第三范式（3NF）"><a href="#Ⅲ-第三范式（3NF）" class="headerlink" title="Ⅲ 第三范式（3NF）"></a>Ⅲ 第三范式（3NF）</h4><p><strong>定义:</strong></p><p><strong>在满足第二范式前提下</strong>，在所有函数依赖表达式中，<strong>所有 非主属性 不传递依赖于 候选键</strong>，这里 A → B ， B → C 则称 C 传递依赖于 A</p><p>一个关系模式不符合3NF定义，会导致如下问题(同2NF)</p><ul><li>插入异常</li><li>删除异常</li><li>修改复杂</li></ul><p><strong>实例：</strong></p><p>在上面的实例关系模式 S-L(<u>Sno</u>, Sdept, Sloc) 中存在传递依赖，Sno ——&gt; Sdept, Sdept——&gt; Sloc, Sloc传递依赖于Sno</p><p>解决的方法同样是<strong>投影</strong>分解，将 S-L 分解为</p><ul><li>S-D (Sno, Sdept)</li><li>D-L (Sdept, Sloc)</li></ul><p>分解后的关系模式 S-D 和 D-L 中不再存在传递依赖，满足第三范式3NF</p><h4 id="Ⅳ-修正的第三范式（BCNF）"><a href="#Ⅳ-修正的第三范式（BCNF）" class="headerlink" title="Ⅳ 修正的第三范式（BCNF）"></a>Ⅳ 修正的第三范式（BCNF）</h4><p><strong>定义：</strong>在满足第二范式的条件下，消除所有属性对主属性的传递依赖。即如果一个属性/属性组 A 决定其他属性/属性组B，则 A 必须包含主键</p><p>关系模式 R 属于 3NF，但 R 不一定属于 BCNF</p><p>下面给出几个例子说明属于3NF的关系模式有的属于BCNF，有的不属于BCNF</p><p><strong>实例：</strong></p><ul><li><p>关系模式C(<u>Cno</u>, Cname , Pcno)，他只有一个码Cno，且没有任何属性对Cno部分依赖或传递依赖，C属于3NF，同时C中Cno是唯一决定因素，所以C属于BCNF</p></li><li><p>有如下函数依赖：(S，J) —&gt; T，(S，J) —&gt; J，T —&gt; J。这里的(S，J) (S，J) 都是主码</p><p>该关系模式是 3NF，因为没有任何非主属性对主码传递依赖；</p><p><strong>不是 BCNF，因为 T 作为决定因素（T 决定 J）但是并不包含主码</strong>。</p></li></ul><h2 id="3-多值依赖"><a href="#3-多值依赖" class="headerlink" title="3. 多值依赖"></a>3. 多值依赖</h2><h3 id="①-概念-1"><a href="#①-概念-1" class="headerlink" title="① 概念"></a>① 概念</h3><p>以上完全是在函数依赖的范畴内讨论问题，属于BCNF的关系模式是否就很完美了呢？下面来看一个例子</p><p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419151459.png" alt=""></p><h3 id="②-范式理论-1"><a href="#②-范式理论-1" class="headerlink" title="② 范式理论"></a>② 范式理论</h3><h4 id="Ⅰ-4NF"><a href="#Ⅰ-4NF" class="headerlink" title="Ⅰ 4NF"></a>Ⅰ 4NF</h4><p>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖</p><h2 id="4-规范化总结"><a href="#4-规范化总结" class="headerlink" title="4. 规范化总结"></a>4. 规范化总结</h2><p>规范化的思想是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的分离。</p><img src="https://gitee.com/xinxiban/images/raw/master/img/20200419152509.png" style="zoom:80%;" /><br><h1 id="三、关系数据库设计习题"><a href="#三、关系数据库设计习题" class="headerlink" title="三、关系数据库设计习题"></a>三、关系数据库设计习题</h1><p>设有关系模式 <strong>R(A,B,C,D,E,F)</strong>,其函数依赖集为： <strong>F={E→D, C→B, CE→F, B→A}.</strong> </p><p>请回答如下问题：</p><ul><li><p><strong>指出R的所有候选键并说明原因；</strong></p><p>按照上述函数依赖画出下述函数依赖图</p></li></ul>  <img src="https://gitee.com/xinxiban/images/raw/master/img/20200419154614.png" style="zoom: 50%;" /><p>  得出：（C, E) 为唯一的候选键，因为只需要这两个元素就可以唯一的确定所有元素</p><ul><li><p><strong>R最高属于第几范式,为什么?</strong></p><p>第三范式需要满足无传递依赖，显示不属于第三范式；</p><p>第二范式需要满足无部分函数依赖，E——&gt;D，(C, E) —P—&gt; D,  D部分依赖于主键（C，E)，所以不属于第二范式；</p><p>所以R属于第一范式</p></li><li><p><strong>分解R为3NF.</strong></p><ul><li><p>1NF ——&gt; 2NF 消除部分函数依赖</p><p>R1(<u>C，E</u>，B，A，F) + R2(<u>E</u>，D)</p></li><li><p>2NF ——&gt;3NF 消除传递函数依赖</p><p>分解为 R3(<u>C, E</u>, F, B) + R4 (<u>B</u>,  A) + R2 (<u>E</u>，D)</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      5-关系数据库设计理论
    
    </summary>
    
    
      <category term="技术探索" scheme="https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数据库" scheme="https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>

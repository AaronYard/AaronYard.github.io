{"meta":{"title":"汪震|个人博客","subtitle":"","description":"","author":"汪震","url":"https://aaronyard.github.io","root":"/"},"pages":[{"title":"汪震","date":"2020-07-05T02:39:24.084Z","updated":"2020-07-05T02:39:24.084Z","comments":true,"path":"about/index.html","permalink":"https://aaronyard.github.io/about/index.html","excerpt":"","text":"欢迎您来到我的 个人博客！我将在这里分享我的个人心得、技术见解、学习历程，给自己一个沉淀的机会，也为大家分享一条前行的路。关于技术方面的问题，大家均可以分享探讨，我个人见解若有不足之处，也欢迎大家批评指正。 因某些原因，暂时没有办法建立一个属于自己的微信公众号，所以不能及时的发布最新的文章，会抓紧时间处理的。 关于我👱‍♂️汪震\\男\\1995 👨‍💻Github：https://github.com/AaronYard 📝目前为unity3D客户端，业余时间沉淀专研3D游戏引擎以及机器学习，目标是全栈。 请联系我📮邮箱：tomwang95@163.com 个人微信号：NOVAWZ"},{"title":"Categories","date":"2019-11-23T07:33:54.918Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://aaronyard.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-11-23T07:33:54.956Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://aaronyard.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自省和展望","slug":"ConclusionAndProspect","date":"2020-08-17T14:40:27.000Z","updated":"2020-08-17T23:54:14.978Z","comments":true,"path":"2020/08/17/ConclusionAndProspect/","link":"","permalink":"https://aaronyard.github.io/2020/08/17/ConclusionAndProspect/","excerpt":"算法题链表的存储反转定义一个方法（函数），实现输入一个链表的头结点，然后可以反转这个链表的方向，并输出反转之后的链表的头结点。 链表结点的结构：1234typedef struct Node&#123; int data; Node *next;&#125; Node, *List; 两种方法：遍历法、递归法","text":"算法题链表的存储反转定义一个方法（函数），实现输入一个链表的头结点，然后可以反转这个链表的方向，并输出反转之后的链表的头结点。 链表结点的结构：1234typedef struct Node&#123; int data; Node *next;&#125; Node, *List; 两种方法：遍历法、递归法 遍历法主要包括如下4步：1）如果head为空，或者只有head这一个节点，return head即可； 2）从头到尾遍历链表，把reversedHead赋值给当前节点的next； 3）当前节点赋值给reversedHead； 4）遍历结束，return reversedHead。 12345678910111213141516Node* reverseList(Node* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node* reversedHead = NULL; Node* p = head; while(p != NULL) &#123; Node* q = p; q-&gt;next = reversedHead; reversedHead = q; p = p-&gt;next; &#125; return reversedHead;&#125; 递归法：递归的实现方式主要有4步：1）如果head为空，或者只有head这一个节点，return head即可； 2）先遍历head-&gt;next为首的链表，得到一个头结点newHead； 3）把head赋值给head-&gt;next-&gt;next， head-&gt;next为空； 4）返回newHead。 12345678910node* reverseList2(node* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; node* newHead = reversedList2(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newHead;&#125; 开放题高楼扔鸡蛋https://www.pianshen.com/article/5717909966/","categories":[{"name":"自我提升","slug":"自我提升","permalink":"https://aaronyard.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"个人发展","slug":"个人发展","permalink":"https://aaronyard.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"}]},{"title":"LeetCode刷题（三）","slug":"LeetCode-3","date":"2020-07-08T15:23:31.000Z","updated":"2020-07-08T16:16:31.458Z","comments":true,"path":"2020/07/08/LeetCode-3/","link":"","permalink":"https://aaronyard.github.io/2020/07/08/LeetCode-3/","excerpt":"4. 寻找两个正序数组的中位数（困难）给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：123nums1 = [1, 3]nums2 = [2]则中位数是 2.0","text":"4. 寻找两个正序数组的中位数（困难）给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例2：123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 示例3：123nums1 = []nums2 = [1]则中位数是 1.0 示例4：123nums1 = []nums2 = [1,2]则中位数是 1.5 类似递归的二分法（java）通过12执行用时：3 ms, 在所有 java 提交中击败了60.78%的用户内存消耗：41 MB, 在所有 java 提交中击败了100.00%的用户 思路解析1利用了类似递归的方法 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int leftLength = nums1.length; int rightLength = nums2.length; // 为了保证第一个数组比第二个数组小(或者相等) if (leftLength &gt; rightLength) &#123; return findMedianSortedArrays(nums2, nums1); &#125; // 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2; // 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果 // 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数 //的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素 int totalLeft = (leftLength + rightLength + 1) / 2; // 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线， // 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i] int left = 0; int right = leftLength; // nums1[i - 1] &lt;= nums2[j] // 此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值 // nums2[j - 1] &lt;= nums1[i] // 此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值 // 循环条件结束的条件为指针重合，即分割线已找到 while (left &lt; right) &#123; // 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置 // 此处+1首先是为了不出现死循环，即left永远小于right的情况 // left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right // 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界（此处 +1 是首先为了避免出现死循环，同时 +1 以后，还不会出现下标越界的情况），因为+1之后向上取整，保证了 // i不会取到0值，即i-1不会小于0 // 此时i也代表着在一个数组中左边的元素的个数 int i = left + (right - left + 1) / 2; // 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和 // 此时j就是第二个元素中左边的元素的个数 int j = totalLeft - i; // 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值 // 说明又指针应该左移，即-1 if (nums1[i - 1] &gt; nums2[j]) &#123; // 下一轮搜索的区间 [left, i - 1] right = i - 1; // 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义 &#125; else &#123; // 下一轮搜索的区间 [i, right] left = i; &#125; &#125; // 退出循环时left一定等于right，所以此时等于left和right都可以 // 为什么left一定不会大于right?因为left=i。 // 此时i代表分割线在第一个数组中所在的位置 // nums1[i]为第一个数组中分割线右边的第一个值 // nums[i-1]即第一个数组中分割线左边的第一个值 int i = left; // 此时j代表分割线在第二个数组中的位置 // nums2[j]为第一个数组中分割线右边的第一个值 // nums2[j-1]即第一个数组中分割线左边的第一个值 int j = totalLeft - i; // 当i=0时，说明第一个数组分割线左边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1]; // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i]; // 当j=0时，说明第二个数组分割线左边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1]; // 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j]; // 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可 if (((leftLength + rightLength) % 2) == 1) &#123; return Math.max(nums1LeftMax, nums2LeftMax); &#125; else &#123; // 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一 // 此处不能被向下取整，所以要强制转换为double类型 return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2; &#125; &#125;&#125; 复杂度分析：时间复杂度O(log(m+n))，空间复杂度O(1)。 建议先看懂上题的注解。 官方解法出处：123作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/来源：力扣（LeetCode） 方法一：二分查找（C++）通过12执行用时：16 ms, 在所有 C++ 提交中击败了84.80%的用户内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123456789主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较这里的 \"/\" 表示整除nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个这样 pivot 本身最大也只能是第 k-1 小的元素如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) &#123; /* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较 * 这里的 \"/\" 表示整除 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个 * 这样 pivot 本身最大也只能是第 k-1 小的元素 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组 * 由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 */ int m = nums1.size(); int n = nums2.size(); int index1 = 0, index2 = 0; while (true) &#123; // 边界情况 if (index1 == m) &#123; return nums2[index2 + k - 1]; &#125; if (index2 == n) &#123; return nums1[index1 + k - 1]; &#125; if (k == 1) &#123; return min(nums1[index1], nums2[index2]); &#125; // 正常情况 int newIndex1 = min(index1 + k / 2 - 1, m - 1); int newIndex2 = min(index2 + k / 2 - 1, n - 1); int pivot1 = nums1[newIndex1]; int pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) &#123; k -= newIndex1 - index1 + 1; index1 = newIndex1 + 1; &#125; else &#123; k -= newIndex2 - index2 + 1; index2 = newIndex2 + 1; &#125; &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if (totalLength % 2 == 1) &#123; return getKthElement(nums1, nums2, (totalLength + 1) / 2); &#125; else &#123; return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0; &#125;&#125;int main()&#123; vector&lt;int&gt; nums1 = &#123;1,3&#125;; vector&lt;int&gt; nums2 = &#123;2&#125;; double myanswer = findMedianSortedArrays(nums1,nums2); cout &lt;&lt; myanswer &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。 空间复杂度：O(1)。 方法二：划分数组（C++）通过12执行用时：24 ms, 在所有 C++ 提交中击败了35.62%的用户内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。当一个数组不出现在前一部分时，对应的值为负无穷，就不会对前一部分的最大值产生影响；当一个数组不出现在后一部分时，对应的值为正无穷，就不会对后一部分的最小值产生影响。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if (nums1.size() &gt; nums2.size()) &#123; return findMedianSortedArrays(nums2, nums1); &#125; int m = nums1.size(); int n = nums2.size(); int left = 0, right = m, ansi = -1; // median1：前一部分的最大值 // median2：后一部分的最小值 int median1 = 0, median2 = 0; while (left &lt;= right) &#123; // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] int i = (left + right) / 2; int j = (m + n + 1) / 2 - i; // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j] int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]); int nums_i = (i == m ? INT_MAX : nums1[i]); int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]); int nums_j = (j == n ? INT_MAX : nums2[j]); if (nums_im1 &lt;= nums_j) &#123; ansi = i; median1 = max(nums_im1, nums_jm1); median2 = min(nums_i, nums_j); left = i + 1; &#125; else &#123; right = i - 1; &#125; &#125; return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;&#125;int main()&#123; vector&lt;int&gt; nums1 = &#123;1,3&#125;; vector&lt;int&gt; nums2 = &#123;2&#125;; double myanswer = findMedianSortedArrays(nums1,nums2); cout &lt;&lt; myanswer &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度：O(log min(m,n)))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。查找的区间是 [0,m]，而该区间的长度在每次循环之后都会减少为原来的一半。所以，只需要执行 log m 次循环。由于每次循环中的操作次数是常数，所以时间复杂度为 O(log m)。由于我们可能需要交换 nums1 和 nums2 使得 m≤n，因此时间复杂度是 O(log min(m,n)))。 空间复杂度：O(1)。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"LeetCode刷题（二）","slug":"LeetCode-2","date":"2020-07-07T15:39:12.000Z","updated":"2020-07-07T16:20:22.422Z","comments":true,"path":"2020/07/07/LeetCode-2/","link":"","permalink":"https://aaronyard.github.io/2020/07/07/LeetCode-2/","excerpt":"3. 无重复字符的最长子串（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1：123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。","text":"3. 无重复字符的最长子串（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1：123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例2：123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例3：1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 解法一：滑动窗口通过12执行用时：20 ms, 在所有 C++ 提交中击败了71.14%的用户内存消耗：7 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123456设立左指针a和右指针bb指针向右侧伸缩｛ 对每个A[b]判断是否在之前的数组出现过； 如果出现，指针a指向出现过的位置的下一个位置； 更新右指针和最大长度；｝ 代码如下123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; int start(0), end(0), length(0), result(0); int size = s.size(); while (end &lt; size) &#123; char end_word = s[end]; for (int i = start; i &lt; end; i++) &#123; if (s[i] == end_word) &#123; start = i + 1; length = end - start; break; &#125; &#125; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n^2)，空间复杂度O(1)。 解法二：hashmap优化时间注：map的key存字符，但是value不存什么0或1了。直接存当前的有序下标，解决了多个字母出现的问题。 通过12执行用时：36 ms, 在所有 C++ 提交中击败了60.40%的用户内存消耗：8.7 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析1判断是否出现过时，利用hashmap优化时间。 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); unordered_map&lt;char, int&gt; hash; while (end &lt; sSize) &#123; char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (hash.find(tmpChar) != hash.end() &amp;&amp; hash[tmpChar] &gt;= start) &#123; start = hash[tmpChar] + 1; length = end - start; &#125; hash[tmpChar] = end; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n)，空间复杂度O(n)。 解法三：利用数组（桶）代替hashmap通过12执行用时：4 ms, 在所有 C++ 提交中击败了99.09%的用户内存消耗：7.9 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析1判断是否出现过时，利用桶来代替hashmap优化时间。 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); vector&lt;int&gt; vec(128, -1); while (end &lt; sSize) &#123; char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (vec[int(tmpChar)] &gt;= start) &#123; start = vec[int(tmpChar)] + 1; length = end - start; &#125; vec[int(tmpChar)] = end; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n)，空间复杂度O(n)。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"LeetCode刷题（一）","slug":"LeetCode-1","date":"2020-07-06T14:58:26.000Z","updated":"2020-07-06T15:52:22.914Z","comments":true,"path":"2020/07/06/LeetCode-1/","link":"","permalink":"https://aaronyard.github.io/2020/07/06/LeetCode-1/","excerpt":"1. 两数之和（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0, 1]","text":"1. 两数之和（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0, 1] 通过12执行用时：12 ms, 在所有 C++ 提交中击败了87.82 %的用户内存消耗：8.3 MB, 在所有 C++ 提交中击败了100.00 %的用户 代码如下1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m_hash; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (m_hash.count(nums[i]) != 0) &#123; result = &#123; i,m_hash[nums[i]] &#125;; return result; &#125; else &#123; m_hash[target - nums[i]] = i; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; a = &#123; 11,2,15,7 &#125;; vector&lt;int&gt; b = twoSum(a, 9); cout &lt;&lt; b[0] &lt;&lt; b[1] &lt;&lt; endl; return 0;&#125; 思路解析我们可以通过遍历一次哈希表完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 复杂度分析：– 时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 – 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 2. 两数相加（中等）给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码如下（解法一）通过12执行用时：36 ms, 在所有 C++ 提交中击败了55.53 %的用户内存消耗：9.3 MB, 在所有 C++ 提交中击败了100.00 %的用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int carry = 0;//进位 ListNode* result = new ListNode(0); result-&gt;next = new ListNode(0); ListNode* cur = result-&gt;next; while (l1 != NULL || l2 != NULL || carry) &#123; if (l1 == NULL)l1 = new ListNode(0); if (l2 == NULL)l2 = new ListNode(0); cur-&gt;val = (l1-&gt;val + l2-&gt;val+ carry) % 10; carry = (l1-&gt;val + l2-&gt;val + carry) / 10; l1 = l1-&gt;next; l2 = l2-&gt;next; if (l1 != NULL || l2 != NULL || carry) &#123; cur-&gt;next = new ListNode(0); cur = cur-&gt;next; &#125; &#125; return result-&gt;next;&#125;int main()&#123; ListNode* a1 = new ListNode(2); a1-&gt;next = new ListNode(4); a1-&gt;next-&gt;next = new ListNode(3); ListNode* a2 = new ListNode(5); a2-&gt;next = new ListNode(6); a2-&gt;next-&gt;next = new ListNode(4); ListNode* b = addTwoNumbers(a1,a2); return 0;&#125; 代码如下（解法二）通过12执行用时：24 ms, 在所有 C++ 提交中击败了97.43 %的用户内存消耗：8.6 MB, 在所有 C++ 提交中击败了100.00 %的用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* addTwoNumbers2(ListNode* l1, ListNode* l2) &#123; int c = 0, temp = 0; ListNode* t1 = l1, * t2 = l2; while (t1-&gt;next != NULL &amp;&amp; t2-&gt;next != NULL) &#123; temp = (t1-&gt;val + t2-&gt;val + c) / 10; t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % 10; c = temp; t1 = t1-&gt;next; t2 = t2-&gt;next; &#125; if (t1-&gt;next == NULL &amp;&amp; t2-&gt;next == NULL) &#123; temp = t1-&gt;val + t2-&gt;val + c; if (temp &gt; 9) t1-&gt;next = new ListNode(temp / 10); t1-&gt;val = temp % 10; &#125; else &#123; if (t1-&gt;next == NULL) t1-&gt;next = t2-&gt;next; temp = (t1-&gt;val + t2-&gt;val + c) / 10; t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % 10; c = temp; t1 = t1-&gt;next; while (c != 0 &amp;&amp; t1-&gt;next != NULL) &#123; temp = t1-&gt;val + c; t1-&gt;val = temp % 10; c = temp / 10; t1 = t1-&gt;next; &#125; if (c != 0) &#123; if (t1-&gt;val + c &gt; 9) t1-&gt;next = new ListNode(1); t1-&gt;val = (t1-&gt;val + c) % 10; &#125; &#125; return l1;&#125;int main()&#123; ListNode* a1 = new ListNode(2); a1-&gt;next = new ListNode(4); a1-&gt;next-&gt;next = new ListNode(3); ListNode* a2 = new ListNode(5); a2-&gt;next = new ListNode(6); a2-&gt;next-&gt;next = new ListNode(4); ListNode* b = addTwoNumbers(a1,a2); return 0;&#125; 思路解析就像在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 伪代码如下： 123456789101112- 将当前结点初始化为返回列表的哑结点。- 将进位 carry 初始化为 0。- 将 p 和 q 分别初始化为列表 l1 和 l2 的头部。- 遍历列表 l1 和 l2 直至到达它们的尾端。--- 将 xx 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。--- 将 yy 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。--- 设定 sum = x + y + carry。--- 更新进位的值，carry = sum / 10。--- 创建一个数值为 (sum mod 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。--- 同时，将 pp 和 qq 前进到下一个结点。- 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。- 返回哑结点的下一个结点。 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 注意陷阱：若只考虑三位数相加，那么会出现val = (l1-&gt;val +l2-&gt;val) + carry / 10，但这样是错的，还要考虑5 + 5 = 10以及99 + 1 = 100等情况，则val = (l1-&gt;val +l2-&gt;val + carry) / 10才是对的。复杂度分析：– 时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n) 次。 – 空间复杂度：O(max(m, n))， 新列表的长度最多为 max(m,n)+1。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"游戏项目中的AI","slug":"GameAI","date":"2020-04-13T04:52:53.000Z","updated":"2020-07-05T02:47:53.270Z","comments":true,"path":"2020/04/13/GameAI/","link":"","permalink":"https://aaronyard.github.io/2020/04/13/GameAI/","excerpt":"项目中的AI前言在游戏开发中实现怪物AI逻辑的主要技术有两种：1、状态机 2、行为树。他们两者的实现机制不一样，其中状态机是“事件”机制，行为树是“轮询”机制。在项目开发中可以根据具体情况合理的选择两者来处理AI编写问题。 接下来将分两个部分对游戏中的AI进行讲解，1、状态机，2、行为树。 概述开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。 知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。","text":"项目中的AI前言在游戏开发中实现怪物AI逻辑的主要技术有两种：1、状态机 2、行为树。他们两者的实现机制不一样，其中状态机是“事件”机制，行为树是“轮询”机制。在项目开发中可以根据具体情况合理的选择两者来处理AI编写问题。 接下来将分两个部分对游戏中的AI进行讲解，1、状态机，2、行为树。 概述开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。 知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。 在行为系统中，有限状态机（FSM，Finite State Machine）最为经典，FSM模型的优势之一是简单。但是FSMs需要用转换（Transition）连接状态（State），因此，状态（State）失去了模块性（Modularity）。 行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构： 对于FSM，每个节点表示一个状态，而对于BT，每个节点表示一个行为。同样是由节点连接而成，BT有什么优势呢？ 在BT中，节点是有层次（Hierarchical）的，子节点由其父节点来控制。每个节点的执行都有一个结果（成功Success，失败Failure或运行Running），该节点的执行结果都由其父节点来管理，从而决定接下来做什么，父节点的类型决定了不同的控制类型。节点不需要维护向其他节点的转换，节点的模块性（Modularity）被大大增强了。实际上，在BT里，由于节点不再有转换，它们不再是状态（State），而是行为（Behavior）。 第一种-有限状态机1、有限状态机（FSM）的实现方式有三种： 面向过程的方式的if else用枚举配合switch case语句。用多态与虚函数（也就是状态模式） 2、状态模式的经典定义：允许对象在当内部状态改变是改变其行为，就好像对象改变了自己的类一样。 3、状态模式的实现分为三个要点： 为状态定义一个接口 为每个状态定义一个类 恰当地进行状态委托 4、通常来说，状态模式中状态对象的存放有两种实现存放思路: 静态状态。初始化时把所有可能的状态都new好，状态切换时通过赋值改变当前的状态实例化状态。每次切换状态时动态new出新的状态。 关于FSM的具体案例如下： 1、Unity的Mecanim动画系统就是通过状态模式来实现的 2、一个简单的战斗过程的状态机，如果用状态模式实现他的攻击逻辑就非常的方便，而且支持后期状态的扩展。 总结：状态模式暂时没有找到好的开源框架，但是状态模式不仅仅在AI方面使用，在游戏的框架中也被广泛使用，比如：UI框架，游戏主逻辑状态框架等等。 第二种-行为树什么是行为树如果了解过状态机，会知道在行为树之前，在实现AI用得比较多的技术是状态机，状态机理解起来是比较简单的，即一个状态过渡到另一个状态，通过判断将角色的状态改变即可，如果学习过Unity的Mecanim动画系统，会更加直观的理解。但是状态机在状态较多的情况下会使状态之间的切换变得异常繁琐，同时状态之间很难复用。在这种情况下，行为树被发明出来，行为树的优点如下： 1、行为树提供大量的流程控制方法，使得状态之间的改变更加直观； 2、整个游戏AI使用树型结构，方便查看与编辑； 3、方便调试和代码编写； 4、更好的封装性和模块性，让游戏逻辑更直观，开发者不会被那些复杂的连线绕晕。 5、最重要的：行为树方便制作编辑器，可以交由策划人员使用； 行为树的基本概念：1、执行每个节点都会有一个结果（成功，失败或运行） 2、子节点的执行结果由其父节点控制和管理 3、返回运行结果的节点被视作处于运行状态，处于运行状态的节点将被持续执行一直到其返回结束（成功或失败）。在其结束前，其父节点不会把控制转移到后续节点。 行为树原理行为树是一种树形结构，所以其可以分成3种节点类型： 1、红色的节点：根节点，没有父节点的节点； 2、蓝色的节点：组合节点，有父节点和子节点的节点； 3、白色的节点：叶节点，没有子节点的节点； 节点的返回每个节点都会有一个返回值，可能出现的返回值有3个，如下： 1、运行中：表示当前节点还在运行中，下一次调用行为树时任然运行当前节点； 2、失败：表示当前节点运行失败； 3、成功：表示当前节点运行成功； 下面我们来细说一下这几个节点： 根节点行为树的入口节点，可以是任意类型的节点； 组合节点行为树的组合节点是由下面几种类型来组成的： 1、选择节点/优先选择节点（Selector）该节点会从左到右的依次执行其子节点，只要子节点返回“失败”，就继续执行后面的节点，直到有一个节点返回“运行中”或“成功”时，会停止后续节点的运行，并且向父节点返回“运行中”或“成功”，如果所有子节点都返回“失败”则向父节点返回“失败”。 2、随机选择节点（Random Selector）之前的选择节点是有优先级顺序的，而随机选择节点的执行顺序是随机的。但每个节点只会执行一次，比如包含子节点：A、B、C、D、E；使用随机选择节点，执行顺序可能是：D、E、A、C、B或其他组合。其它规则同选择节点一致。 3、顺序节点（Sequence）该节点会从左到右的依次执行其子节点，只要子节点返回“成功”，就继续执行后面的节点，直到有一个节点返回“运行中”或“失败”时，会停止后续节点的运行，并且向父节点返回“运行中”或“失败”，如果所有子节点都返回“成功”则向父节点返回“成功”。 4、修饰节点（Decorator）修饰节点只包含一个子节点，用来以某种方式来改变这个子节点的行为。修饰节点的类型比较多，这里我们说一些比较常见的修饰节点： ① Until Success和Until Failure 循环执行子节点，直到返回“成功”或“失败”为止。 比如Until Success在子节点返回“运行中”和“失败”时都会向父节点返回“运行中”，返回“成功”时向父节点返回“成功”。 Until Failure在子节点返回“运行中”和“成功”时都会向父节点返回“运行中”，返回“失败”时向父节点返回“成功”。 ② Limit 执行子节点一定次数后强制返回“失败”。当子节点运行指定次数后还没有返回“失败”则该节点向父节点返回失败。 ③ Timer 子节点不会立即执行，而会在指定的时间到达后才开始执行。 ④ TimeLimit 指定子节点的最长运行时间，如果子节点在指定时间到达后还在运行则强制返回“失败”。 ⑤ Invert 对子节点的返回结果取“非”，即子节点返回“成功”则该节点返回“失败”，子节点返回“失败”则该节点返回成功。 5、并行节点（Parallel）不同于选择和顺序节点依次执行每个节点，并行节点是“同时”执行所有的节点，然后根据所有节点的返回值判断最终返回的结果。 这里的“同时”会迷惑住不少人，实际上，行为树是运行在单一线程上的，并不会在并行节点上开多个线程来进行真正的同时执行，那么“同时”的含义是什么？ 我们知道选择或顺序节点会依次执行所有的子节点，当子节点返回“成功”或“失败”后就会停止后续节点的执行，而并行节点也会依次执行所有的子节点，无论子节点返回“成功”或“失败”都会继续运行后续节点，保证所有子节点都得到运行后在根据每个子节点的返回值来确定最终的返回结果。 并行节点一般可以设定退出该节点的条件，比如： 1、当全部节点都返回成功时退出； 2、当某一个节点返回成功时退出； 3、当全部节点都返回成功或失败时退出； 4、当某一个节点返回成功或失败时退出； 5、当全部节点都返回失败时退出； 6、当某一个节点返回失败时退出； 叶节点1、条件节点（Condition）条件节点可以理解为一个if判断语句，当条件的测试结果为true时向父节点传递success，结果为false时向父节点传递failure； 该节点搭配一些组合节点可以完成各种判断跳转，比如搭配顺序节点，可以做出“是否看见敌人”-&gt;“向敌人开火”的AI； 2、行为节点（Action）行为节点用来完成具体的操作，比如，移动到目标点，执行开火等代码逻辑，多种情况下行为节点会返回running和success；行为节点也可能会使用多帧来完成； 子树的复用我们设计好的行为树可以在其他树中作为一颗子树来进行使用，最大可能的复用子树可以减少开发量。 总结：行为树的框架，网上有比较好的案例，如腾讯开源的behaviac。 Github地址：github.com/Tencent","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的事件系统","slug":"GameEventSys","date":"2020-04-11T13:52:53.000Z","updated":"2020-04-13T11:13:10.354Z","comments":true,"path":"2020/04/11/GameEventSys/","link":"","permalink":"https://aaronyard.github.io/2020/04/11/GameEventSys/","excerpt":"项目中的事件系统成熟的项目中对自己的事件都会进行封装，使得过程透明，使用者不必去了解其构成，只需要关心分发出来的事件，而事件的发出者也不关心谁会用到，只需要将事件发出即可。事件系统维系着项目中所有事件的分发，将游戏逻辑解耦，使得项目逻辑清晰，代码简单易懂。 通常事件系统并不复杂，反而很简单，包含了三个核心的方法： 注册 AddHander 注销 RemoveHander 发送 SendEvent","text":"项目中的事件系统成熟的项目中对自己的事件都会进行封装，使得过程透明，使用者不必去了解其构成，只需要关心分发出来的事件，而事件的发出者也不关心谁会用到，只需要将事件发出即可。事件系统维系着项目中所有事件的分发，将游戏逻辑解耦，使得项目逻辑清晰，代码简单易懂。 通常事件系统并不复杂，反而很简单，包含了三个核心的方法： 注册 AddHander 注销 RemoveHander 发送 SendEvent 使用枚举来作为事件类型 1public enum EEventType&#123;&#125; 事件是基于委托的，一个事件对应于多个委托delegate，利用委托的性质，事件系统将更加的简单明了。 1234//委托 事件的回调 对应于事件的数据结构public delegate void EventSysCallBack(EEventType eventId, object param1, object param2);public delegate void EventSysCallBack_(uint eventId, object param1, object param2);public delegate void EmptyCallBack(); 事件类的数据结构定义 1234567891011121314151617public class EventParamData&#123; private EEventType m_eventId = 0; private object m_param1 = null; private object m_param2 = null; public EventParamData(EEventType eventId, object param1, object param2) &#123; m_eventId = eventId; m_param1 = param1; m_param2 = param2; &#125; public EEventType GetEventId() &#123; return m_eventId; &#125; public object GetParam1() &#123; return m_param1; &#125; public object GetParam2() &#123; return m_param2; &#125;&#125; 接下来就是对于事件系统类EventSys的实现，整个系统继承于ISystem，ISystem继承于MonoBehaviour。 12345678910111213141516public class ISystem : MonoBehaviour&#123; public virtual void Init() &#123; &#125; public void BaseReset() &#123; Reset(); &#125; public virtual void Reset() &#123; &#125; public virtual void Release() &#123; &#125; public virtual void SysUpdate() &#123; &#125; public virtual void SysLateUpdate() &#123; &#125; public virtual void SysFixedUpdate() &#123; &#125; protected bool m_isControlUpdate = false; private int _m_randomNum = 0; public int m_randomNum &#123; get&#123; return _m_randomNum; &#125; set&#123; _m_randomNum = value; &#125; &#125; 在ISystem类中有两个虚方法需要在EventSys中实现，这两个虚方法分别是 12345//初始化方法public virtual void Init() &#123;&#125;//更新public virtual void SysUpdate() &#123;&#125; 事件系统中的事件是一个队列Queue，对列中存放的是一个EventParamData类型的数据，在每次执行SysUpdate的时候对队列中的所有元素执行出队操作，及时向其它系统发送事件，有新事件的时候执行入队操作，在注销事件时删除队列内相关的事件。为确保同一时间内能完整的运行完同一套事件，故而对事件加锁Lock，保证线程安全。 具体的代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class EventSys : ISystem&#123; private static String ms_lock = \"lock\"; private List&lt;EventSysCallBack&gt; m_allHander = new List&lt;EventSysCallBack&gt; (); private List&lt;EventSysCallBack&gt;[] m_eventArray = new List&lt;EventSysCallBack&gt;[(int)EEventType.Count]; private int m_eventNum = 0; private Queue m_eventQueue = new Queue(); public static EventSys Instance = null; private bool m_hasInit = false; public override void Init() &#123; if(m_hasInit) &#123; return; &#125; m_hasInit = true; m_eventQueue.Clear(); Instance = this; m_eventNum = (int)EEventType.Count; &#125; public override void SysUpdate() &#123; lock (ms_lock) &#123; while (m_eventQueue.Count &gt; 0) &#123; EventParamData data = m_eventQueue.Dequeue() as EventParamData; EEventType eventId = data.GetEventId(); SendEvent(eventId, data.GetParam1(), data.GetParam2()); &#125; &#125; &#125; public void AddAllHander(EventSysCallBack callBack) &#123; lock (ms_lock) &#123; m_allHander.Add (callBack); &#125; &#125; public void AddUintHander(uint eventid, object instance, EventSysCallBack_ callBack) &#123; AddHander((EEventType)eventid, (EEventType eventType, object param1, object param2) =&gt; &#123; callBack((uint)eventType, param1, param2); &#125;); &#125; public void AddHander(EEventType eventId, EventSysCallBack callBack) &#123; lock (ms_lock) &#123; if ((int)eventId &lt; m_eventNum) &#123; var eventList = m_eventArray[(int)eventId]; if (eventList != null) &#123; int count = eventList.Count; for (int i = 0; i &lt; count; i++) &#123; if(callBack == eventList[i]) &#123; return; &#125; &#125; eventList.Add(callBack); return; &#125; &#125; List&lt;EventSysCallBack&gt; t = new List&lt;EventSysCallBack&gt;(); t.Add(callBack); m_eventArray[(int)eventId] = t; &#125; &#125; public void RemoveHander(object target) &#123; lock (ms_lock) &#123; for (int i = m_eventNum - 1; i &gt;= 0; i--) &#123; var eventList = m_eventArray[i]; if (eventList != null) &#123; var eventCount = eventList.Count; for(int j = eventCount - 1; j &gt;= 0; j--) &#123; if(target == eventList[j].Target) &#123; eventList.RemoveAt(j); &#125; &#125; &#125; &#125; &#125; &#125; public void AddEvent(EEventType eventId, object param1=null, object param2=null) &#123; lock (ms_lock) &#123; m_eventQueue.Enqueue( new EventParamData(eventId, param1, param2 ) ); &#125; &#125; public void AddUintEvent(uint eventId, object param1 = null, object param2 = null) &#123; AddEvent((EEventType)eventId, param1, param2); &#125; //此函数只能在主线程调用 public void AddEventNow(EEventType eventId, object param1=null, object param2=null) &#123; SendEvent (eventId, param1, param2); &#125; public void AddUintEventNow(uint eventId, object param1 = null, object param2 = null) &#123; AddEventNow((EEventType)eventId, param1, param2); &#125; private void SendEvent(EEventType eventId, object param1, object param2) &#123; for(int i = 0; i &lt; m_allHander.Count; i++) &#123; try &#123; m_allHander[i](eventId, param1, param2); &#125; catch (Exception e) &#123; CNetSys.Instance.SendImportantLogWithBugly(true, \"[Exception]\" + e.ToString()); &#125; &#125; int targetIndex = (int)eventId; if(targetIndex &lt; m_eventNum) &#123; var eventList = m_eventArray[targetIndex]; if(eventList != null) &#123; int count = eventList.Count; for(int i = 0; i &lt; count; i++) &#123; try &#123; if(eventList != null &amp;&amp; i &lt; eventList.Count) &#123; eventList[i](eventId, param1, param2); &#125; &#125; catch (System.Exception e) &#123; CNetSys.Instance.SendImportantLogWithBugly(true, \"[Exception]\" + e.ToString()); &#125; &#125; &#125; &#125; &#125;&#125; 大致流程业务逻辑需要发事件时，调用AddEvent(…)接口，当下一帧到来，sysupdata(…)方法执行，事件被SendEvent(…)发送出去，设置了AddHander(…)的业务逻辑回调就会触发，进行相关的逻辑操作。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的全自动打包机制","slug":"AutomaticPackaging","date":"2020-04-06T07:27:18.000Z","updated":"2020-04-06T12:08:51.832Z","comments":true,"path":"2020/04/06/AutomaticPackaging/","link":"","permalink":"https://aaronyard.github.io/2020/04/06/AutomaticPackaging/","excerpt":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。","text":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。 前期准备工作1、各个渠道的sdk资源按渠道分类至各个渠道文件夹中，包括这个渠道打包所需要的【AndroidManife.xml、res、so、jar包、java代码】（Android）或【framework、.a文件、InfoPlisst、蕴含生命周期的UnityAppController.mm/AppDelegate.m文件】（ios）等资源文件。 2、一台单独打包机器（资金充足的话建议单独配打包机器），建议用MAC机，因为ios包只能用MAC机来打，而MAC机还能打安卓apk。 3、Jenkins，一个开源的可拓展的自动化服务器，关于Jenkins可以单独拿出来将一篇文章了，再此简单的说一下Jenkins的持续集成流程：提交代码–&gt;拉取代码–&gt;编译–&gt;打包–&gt;测试–&gt;反馈问题–&gt;开发处理–&gt;提交代码，从这一流程就可以窥探到Jenkins的便利。 4、打包所用的脚本：build.bat或者build.sh脚本。 5、unity项目代码中可供打包脚本调用的打包相关静态方法。 具体流程1、Jenkins中Build with Parameters里输入相应的打包参数，坐等打包完成，打包过程对你来说是透明的，完毕…哈哈，开个玩笑，接下用最通俗的语言带你揭秘打包流程。 2、全自动化打包流程最重要的在于打包脚本，接收到你的输入参数后开始工作，首先覆盖平台相关资源，其次拉取svn到指定版本，然后再将将指定平台写入代码中，最后关闭打包机上unity和资源管理器窗口。关闭unity尤为重要，不然unity会以进程被占用为由告诉你打包失败。 3、设置Unity宏定义，表明这个包是某个渠道的宏定义。 4、设置游戏版本号，便于后期维护发热更新。 5、构建游戏Aesstbundle资源：调用打包代码，构建资源输出到指定目录，将资源打成压缩包输出到resource目录下。 6、构建游戏安装包。 相关代码build.sh 123456789101112131415#!/bin/bash#define varUnityCmd=/Applications/Unity/Unity.app/Contents/MacOS/Unity CurrentPath=$(cd `(dirname $0)`; pwd)PROJECTHOME=$&#123;CurrentPath&#125;/../FUNCTION_NAME=\"\"BUILDHOME=\"\"APP_NAME=\"\"cmdBuildAB=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod BuildEditor.BuildAndroidAB\"$cmdBuildABcmd=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod AutoBuild.$&#123;FUNCTION_NAME&#125; -outPath $&#123;BUILDHOME&#125;/$&#123;APP_NAME&#125; -logFile\"$cmd C#静态方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//打AssetBundle//state 0:apk 1: ios: 2: editor 3:iOS不压缩ab 4:不挪动UI 5:GOOGLE OBBpublic static void BuildAssetBundle(int state)&#123; DirectoryInfo direc = new DirectoryInfo(Application.streamingAssetsPath + \"/AssetsBundle\"); if (direc.Exists) &#123; direc.Delete(true); &#125; m_abDataLs.list.Clear(); m_options = BuildAssetBundleOptions.CollectDependencies; if(state == 0 || state == 10) &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; m_target = BuildTarget.Android; &#125; else &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; if(state == 1 || state == 3) &#123; m_target = BuildTarget.iPhone; &#125; else if(state == 2) &#123; m_target = BuildTarget.StandaloneWindows; &#125; &#125; if (state == 0 || state == 1) &#123; //移动打包资源 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); AutoBuild.MoveUIResToTemp(); &#125; if (state == 5) &#123; //移除一部分资源去打obb包 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileNameObb, AutoBuild.DirecPrefabFileNameObb); &#125; if (state == 3 || state == 4) &#123; // 只移动Resource/Prefab AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); &#125; //打AssetBundle BuildAB(state); if (state != 3) &#123; //压缩AssetBundle AssetBundleCompress(); &#125;&#125;//打apkpublic static void Build_Apk(int XXqudao)&#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, \"PLAT_SDK_XXqudao\"); PlayerSettings.bundleIdentifier = \"com.xxx.xxx.xxx\"; BuildAndroid(XXqudao);&#125;//移动相关的资源static void BuildAndroid(int XXqudao)&#123; //移动相关平台sdk资源文件夹 MovePluginDir(XXqudao); //替换一些DLL文件 ReplaceDll(\"Android\", \"DLL\"); //替换一些包体内需要用到的图片icon文件 ReplaceLoadingImage(XXqudao); //开始build BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions(); buildPlayerOptions.scenes = new[] &#123; \"Assets/Scene1.unity\", \"Assets/Scene2.unity\" &#125;; buildPlayerOptions.locationPathName = m_outPath; buildPlayerOptions.target = BuildTarget.Android; buildPlayerOptions.options = BuildOptions.None; BuildReport report = BuildPipeline.BuildPlayer(buildPlayerOptions); BuildSummary summary = report.summary; if (summary.result == BuildResult.Succeeded) &#123; Debug.Log(\"Build succeeded: \" + summary.totalSize + \" bytes\"); &#125; if (summary.result == BuildResult.Failed) &#123; Debug.Log(\"Build failed\"); &#125; //将editor使用的DLL恢复 RecoveryDll(\"DLL\"); //恢复sdk资源文件夹 RecoveryPluginDir();&#125; 写在最后这里只是提供一个大体的思路，实际上在自动化流程中还是有很多大大小小的坎坷的，比如一些已经成形的项目，其项目目录结构需要单独进行适配，一些渠道打包需要单独进行调整等，这些都是要考虑到的。 关于sdk：建议单独分出一个集成sdk的部门，用于将各个渠道的sdk集成到一个主的sdk上，游戏项目只需要接入一个sdk即可，使得sdk接入工作透明化，游戏开发人员专注于游戏业务逻辑的开发，更加高效。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的小包更新机制","slug":"AssetsPackage","date":"2020-04-05T12:21:28.000Z","updated":"2020-04-07T04:21:52.782Z","comments":true,"path":"2020/04/05/AssetsPackage/","link":"","permalink":"https://aaronyard.github.io/2020/04/05/AssetsPackage/","excerpt":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考：","text":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考： 方案一没有一个官方的名字，姑且叫它强制小包法叭。 在打apk的时候，将游戏用到的代码、闪屏图、loading图、主场景、登录场景、表格、开场动画等最基本的资源提前准备好，在打包时替换进去，这样包体不会很大，玩家所需的拓展资源则通过项目里的热更新机制加载。 这个方法有一个缺点，由于包体内所携带的资源并不完整，只能保证游戏可以运行不会崩溃，更多的功能资源包则需要在登录游戏之前下载。若热更新较大则会“吓跑”一些新玩家（不成文规定：新发布游戏的热更新包体宜小于30M），为了减少这一影响，第二种补充方案应运而生了。 方案二游戏内小包资源法，作为方案一的补充，它对玩家更友好。 将项目内容分为必须功能和非必须功能，如玩家信息系统、公告系统、技能系统、排行榜系统、基本的新手任务系统以及主城场景等游戏正常运行所必须的或占资源不多的功能系统可以统一将预制图集资源打进包里。但是类似宠物系统、武将系统、野怪系统等占用较多预制资源分类打进AB小包中，用一个json文件来管理资源列表。 在loading主场景的时候，异步检测线上小包资源的json配置是否存在，若存在且为wifi环境则异步下载资源并解压预加载，主界面也会显示相应的窗口。若玩家当前网络环境不满足下载资源的要求，则会在非必须的功能入口处做出限制，告知需要加载资源包才能体验完整的游戏功能，并且会在加载完毕资源后给予一定的奖励。 这样玩家在初始阶段流失的相应较少，体验更佳，对玩家更为友好。 热更新机制热更新机制已经在另一篇文章中详细阐述了，再此就不重复介绍了。–&gt;热更新机制 游戏内小包资源法1、小包有对应的资源版本号，在游戏打包前设定相应的资源版本号，而在拉取小包资源的时候也是以资源版本号作为索引去寻找相应的json配置文件。 2、商业游戏最重要的是游戏安全，可以在写入json配置文件列表的脚本中加入相应的文件大小及MD5等信息作为校验，这样就不会轻易被第三方非法修改。 3、在小包解压时，有概率会出现一些文件解压失败，损失一部分资源，或者玩家不小心删掉了一些资源文件，这个时候在重新下载所有小包资源就不明智了。在游戏中给玩家提供一个主动校验资源的功能，根据现有资源文件名遍历json配置资源列表来寻找需要缺失的文件，异步下载并解压。 4、游戏内小包资源法与热更新机制在本质上是一样的，都是通过unity的AssetBundle加载机制来实现的。 小包资源的加载状态123456789101112public enum AssetsPackageState&#123; None,//初始状态，最初的未加载状态 ReadFileEnd,//读取完json配置文件 DownLoadStart,//开始下载josn文件列表中的小包资源文件 DownLoadStop,//暂停下载josn文件列表中的小包资源文件，并保存当前的下载进度 DownLoadComplete,//小包资源下载完成 DecompressStart,//小包资源开始解压 DecompresFail,//小包资源解压失败 AssetsReady,//资源校验已准备好 AssetsCheck,//资源校验中（成功时会通过回调告知玩家校验结果）&#125; 无感知下载小包资源在加载进入主主场景时，检测是否需要加载资源，根据网络环境并自动加载,代码流程大致如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//初始化检测功能public void CheckInitDownLoad()&#123; //不是初始化状态，说明进入主场景后已经检查过了，不必再走下面的逻辑 if (m_curAssetsPackageState != AssetsPackageState.None) &#123; return; &#125; if (IsAssetsPackageReady()) &#123; m_isDecompressSuc = true; m_isDownLoadSuc = true; m_curAssetsPackageState = AssetsPackageState.AssetsReady; &#125; else &#123; if (m_curAssetsPackageState == AssetsPackageState.None) &#123; LoginCheckDownLoadInfo(); &#125; &#125;&#125;// 资源包是否下载解压好public bool IsAssetsPackageReady()&#123; if(m_data.assetPackage != null) &#123; return m_data.assetPackage.isAssetsPackageReady; &#125; return false;&#125;//用于登录检查下载资源private void LoginCheckDownLoadInfo()&#123; //创建下载目录 m_availablePath = GetPathForPlatform(platform, TargetAssetsBundlPath); if (!Directory.Exists(m_availablePath)) &#123; Directory.CreateDirectory(m_availablePath); &#125; if (m_updateStruct == null) &#123; GetUpdateStructForSvr(InitUpateFileInfo); &#125; else &#123; InitUpateFileInfo(); &#125; &#125;//拉取下载文件清单信息private void GetUpdateStructForSvr(Action succCB = null)&#123; var url = \"....\";//json文件的url DownloadSmallFileTask(url, (string text) =&gt;//下载并解析json文件 &#123; m_updateStruct = JsonMapper.ToObject&lt;UpdateStruct&gt;(text);//将json数据转为C#结构 if (m_updateStruct != null) &#123; if (succCB != null) succCB(); &#125; &#125;); //succCB批次任务执行成功回调,failCB批次任务执行失败回调,netConnectCheckCB网络连接检查回调,tryTimeLimit任务失败后尝试次数上限,value=0默认没有上限，不为0时，超过上限后结束任务执行 StartDownloadSmallFile(succCB, failCB, netConnectCheckCB, tryTimeLimit);&#125;public class UpdateInfo&#123; public string name; public int size; public string md5; public int desize; public string demd5; public UpdateInfo() &#123; name = \"\"; size = 0; md5 = \"\"; desize = 0; demd5 = \"\"; &#125;&#125;//初始化更新文件信息private void InitUpateFileInfo()&#123; //遍历json中的下载信息，统计已下载，总下载，初始化需要下载文件列表 for (int i = 0; i &lt; m_updateInfo.Count; i++)//遍历json数据转换后的list &#123; var updateInfo = m_updateInfo[i]; InitFileReadTask(m_updateInfo[i], m_availablePath);//添加异步下载任务 m_needDeleteFileList.Add(m_availablePath + m_updateInfo[i].name); &#125;&#125;//初始化文件读取任务private void InitFileReadTask(UpdateInfo updateInfo, string path)&#123; string fileName = \"ABC.ab\"; string url = \"https://www.AAA.com/ABC.ab\"; string decompressFileName = \"abc\"; //下载文件读取 m_totalSize += updateInfo.size; AddReadFileTask(fileName, updateInfo.md5, updateInfo.size, //读取成功回调 () =&gt; &#123; m_curSize += updateInfo.size; &#125;, //读取失败回调 (TaskWorkStatus status) =&gt; &#123; AddDownloadBigFileTask(fileName, url, updateInfo.md5, updateInfo.size, () =&gt; &#123; m_childDownSize = 0; m_curSize += updateInfo.size; &#125;, (TaskWorkStatus downStatus) =&gt; &#123; m_childDownSize = 0; &#125;, (long curSize) =&gt; &#123; m_childDownSize = curSize; &#125; ); &#125; ); //解压后文件读取 var unDecompressFile = new CUnzipFile(fileName, decompressFileName, updateInfo.desize); m_totalDecompressSize += updateInfo.desize; AddReadFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;, (TaskWorkStatus status) =&gt; &#123; AddDecompressFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, unDecompressFile, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;); &#125; );&#125;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"浅谈游戏安全","slug":"GameSecurity","date":"2020-03-06T12:22:18.000Z","updated":"2020-04-06T15:10:47.280Z","comments":true,"path":"2020/03/06/GameSecurity/","link":"","permalink":"https://aaronyard.github.io/2020/03/06/GameSecurity/","excerpt":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科","text":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科 外挂的弊端一些外挂会破坏游戏的平衡，造成网络游戏的极度不公平，影响正常玩家的游戏体验，若长时间不控制，正常玩家会逐渐流失。 外挂的种类1、外挂修改器，独立于手机之外的一个小软件，原理是修改内存，有时即使时特意通过第三方加固过的安装包也无法杜绝数据内存被修改。 2、外挂包，即安装包的包体被修改，替换了dll以及so库等。 应对方法我经历的项目有幸被这两种外挂盯上，由于在开发阶段部分功能没有做好数据加密防护，在被外挂魔改之后，达成了一刀秒杀，满攻速，免疫所有伤害等，所幸咱也不怕，兵来将挡，水来土掩，开始与外挂斗智斗勇。 对于外挂修改器，对核心数据进行加密，修改一下存储的数据类型，就可以杜绝大部分外挂修改器的修改，其次，可以对数据进行基本的校验，比如存储时将数据分别*2和/2，三份数据均存在本地，取数据时再进行校验，如果数据不对就闪退。 对于包体被修改，可以在打包之后对包体内的文件进行md5校验，运行游戏的时候如果发现md5不对就闪退。也可以使用第三方加固包体的服务，使得包体无法再被修改。 另外，终极大招就是在服务器端对数据进行校验，这样外挂就无机可乘了。 相关代码可以参考以下代码 DBTools.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485using System;using System.Collections.Generic;using System.Linq;using System.Security.Cryptography;using System.Text;using System.Threading.Tasks; namespace DBTools&#123; public class Encryption &#123; /// &lt;summary&gt; /// 加密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Encrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); byte[] inputByteArray; inputByteArray = Encoding.Default.GetBytes(Text); des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); StringBuilder ret = new StringBuilder(); foreach (byte b in ms.ToArray()) &#123; ret.AppendFormat(\"&#123;0:X2&#125;\", b); &#125; return ret.ToString(); &#125; /// &lt;summary&gt; /// 解密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Decrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); int len; len = Text.Length / 2; byte[] inputByteArray = new byte[len]; int x, i; for (x = 0; x &lt; len; x++) &#123; i = Convert.ToInt32(Text.Substring(x * 2, 2), 16); inputByteArray[x] = (byte)i; &#125; des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); return Encoding.Default.GetString(ms.ToArray()); &#125; // MD5 32 位 public static String Encrypt32(String convertString) &#123; MD5 md5 = new MD5CryptoServiceProvider(); byte[] bytes = System.Text.Encoding.UTF8.GetBytes(convertString); bytes = md5.ComputeHash(bytes); md5.Clear(); string ret = \"\"; for (int i = 0; i &lt; bytes.Length; i++) &#123; ret += Convert.ToString(bytes[i], 16).PadLeft(2, '0'); &#125; return ret.PadLeft(32, '0').ToLower(); &#125; // MD5 16 位 public static string Encrypt16(string convertString) &#123; MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); string t2 = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(convertString)), 4, 8); t2 = t2.Replace(\"-\", \"\"); return t2.ToLower(); &#125; &#125;&#125; 编码时： 123//LoginPwd--要加密的数据。也可以将二进制值传递给此函数。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。//Master--用来对 LoginPwd 进行加密的加密密钥。解密时必须使用同一密钥才能获得原始值。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。string Pwd = DBTools.Encryption.Encrypt(LoginPwd, \"Master\"); 与大多数口令一样，最好选择无法被轻易猜到的密钥值。建议选择满足以下条件的密钥值：长度至少为 16 个字符，混合使用大小写并包含数字、字母和特殊字符。每次要对数据进行解密时，都需要使用此密钥。 解码时： 1string Pwd = DBTools.Encryption.Decrypt(LoginPwd, \"Master\"); ##总结 魔高一丈道高一尺，遇到外挂不要害怕，他们并不可怕，钻研外挂的原理，从源头上击垮他们。在项目立项之初，也要有数据加密的意识，一些重要的运算放在服务器端，客户端只做展示，不给外挂可乘之机。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"GameChangeClothe","slug":"GameChangeClothe","date":"2019-12-05T05:29:09.000Z","updated":"2020-04-13T12:58:08.515Z","comments":true,"path":"2019/12/05/GameChangeClothe/","link":"","permalink":"https://aaronyard.github.io/2019/12/05/GameChangeClothe/","excerpt":"","text":"换装系统游戏项目中一般都会有玩家人物的换装系统，玩家也愿意为好看的时装皮肤付款。但在我眼中时装皮肤就是一串数据，所以不会为这串数据流而花钱，接下来就解密换装系统的奥秘。 时装换装系统换的是什么？时装。 时装的别名也可叫皮肤，那他们的本质是什么呢？ 首先介绍一下玩家在游戏中所操控的玩家人物，在大部分MMORPG游戏中，玩家人物亦是一个人物对象。所谓换汤不换药，如果把一个玩家拆分一下，即可分为骨骼以及蒙皮模型。也就是说一套骨骼可以对应多个服装模型。换装实际上就是将相应的身体部分进行更换，比如要换一套衣服，就是将新的服装与身体上除了服装覆盖的模型再进行一次网格合并，换句话说，更换身体的某一个部位就是更新了整个角色模型。","categories":[],"tags":[]},{"title":"游戏项目中的热更新机制","slug":"GameUpdate","date":"2019-11-30T13:51:31.000Z","updated":"2020-04-05T12:18:12.934Z","comments":true,"path":"2019/11/30/GameUpdate/","link":"","permalink":"https://aaronyard.github.io/2019/11/30/GameUpdate/","excerpt":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。","text":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。 代码热更新实现方式： 1、使用Lua脚本编写游戏的UI或者其他逻辑，Lua是一个精悍小巧的脚本语言，可以跨平台运行解析，而且不需要编译过程。（热更lua） 2、使用C#Light（热更L#） 3、使用C#反射技术（热更DLL） 热更C#代码（DLL）针对C#代码热更新的机制做一个简单的概述，在安卓上可以通过C#的语言特性——反射机制实现动态代码加载从而实现热更新。 具体做法是：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。注：将这部分dll改个名字放在安卓包体中，可以防止一些别有用心的人做一些别有用心的事情。 但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。 关于C#在苹果系统上热更新的思考可以参考此处。 Lua热更新项目中使用的是ulua更新框架，不仅支持热更lua，还支持热更C#Light（L#），之所以把这两者放在一起讲是因为他们都支持安卓与苹果系统的热更新。 Lua热更新的原理：在客户端可以编写Lua的解析器，通过这个解析器，可以运行最新的Lua脚本，后期可以把控制游戏逻辑的代码都写成Lua脚本。 C#和lua中的类型可以一一对应。 Lua 和 C#中类型的对应nil null String System.String number System.Double boolean System.Boolean table Lualnterface.LuaTable function LuaInterface.LuaTable Lua中通过表来实现面向对象的一个小例子123456789101112131415161718192021222324252627282930Enemy = &#123;&#125; --申明对象loacal this = Enemy --申明this关键字代表当前对象--定义并声明对象中的属性Enemy.hp=100Enemy.speed=12--定义并声明对象中的方法Enemy.Move = function() print(\"移动\")endfunction Enemy.Attact() print(this.hp,\"攻击\") this.Move()end--执行Enemy.Attact() Lua解析器示例在C#中执行访问Lua代码12345678910111213Lua lua = new Lua(); //创建Lua解析器lua[\"num\"] = 5; //定义一个 numlua[\"str\"] = \"a string\"; //定义一个字符串lua.newTable(\"tab\"); //创建一个表 tab=&#123;&#125;//取得Lua环境中的变量double num = (double)lua[\"num\"];string str = (string)lua[\"str\"]; 在C#脚本中执行Lua脚本文件，或者脚本字符串1234567lua.DoFile(\"script.lua\");//执行script.lua脚本lua.DoString(\"num = 2\");//执行lua代码lua.DoString(\"str = 'a string'\");object[] retVals = lua.DoString(\"return num,str\"); 在热更新中，只需要写好解析Lua脚本的代码，然后C#代码不需要变动，只需要修改lua脚本就好，通过lua脚本控制游戏逻辑。 把一个C#方法注册进Lua的一个全局方法1234567891011//把一个类中的普通方法注册进去Lua.RegisterFunction(\"NormalMethod\",obj,obj.GetType().GetMethod(\"NormalMethod\"))lua.DoString(\"NormalMethod()\") //把一个类的静态方法注册进去lua.RegisterFunction(\"StaticMethod\",null,typeof(ClassName).GetMethod(\"StaticMethod\"))lua.DoString(\"StaticMethod()\") 在Lua中使用C#脚本123456789101112131415require \"luanet\" --引入库，相当于 import--加载CLR的类型、实例化CLR对象luanet.load_assembly(\"System.Windows.Forms\")luanet.load_assembly(\"System.Drawing\") --表示加载了一个dll，理解为加载了system.drawing的命名空间Form = luanet.import_type(\"System.Windows.Forms.Form\") --表示引入了System.Windows.Forms下的一个类FormStartPosition = luanet.import_type(\"System.Windows.Forms.FormStartPosition\")print(Form)print(StartPosition) 在Lua中使用C#中的类创建对象的时候，会自动匹配最合适的构造方法。 在Lua中访问C#中的属性和方法Lua代码中，访问C#对象的属性的方法和访问table的键索引一样，比如obj.name 或者 obj[“name”] Lua代码中，访问C#对象的普通函数的方式和调用table的函数一样，如：obj:method() 注：在Lua中访问C#中的方法 - 特殊情况 当函数中有out或者ref参数时，out参数和ref参数和函数的返回值一起返回，并且调用的时候，out参数不需要传参。 AssetBundle热更新AssetBundle是一个特定于平台的资产压缩包，资产包括Models、Textures、Prefabs、Audio clips等，每个不同的平台打包出来的AssetBundle不同。AssetBundle的热更新是unity官方支持的。 选择需要打包的资源，在inspector视图底部，找到AssetBundle选项，默认是None，选项卡选择NEW，输入自定义的AssetBundle名称，后面第二个选项卡是AssetBundle的后缀名，可选可不选，如果你使用了后缀，那么加载AssetBundle的时候需要带上后缀名。如果创建的标签是window标签，那么所有window标签的资源会打到一起window AssetBundle。也就是说，Unity会自动把相同标签的资源打包成一个整体。 使用官方提供的API打AB以及加载AB，BuildPipeline.BuildAssetBundles这个API，参数一是打包后AssetBundle的存放路径，参数二是压缩方式，参数三是打包的平台。 1public static AssetBundleManifest BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform); 本地加载，如果你设置的AssertBundle有后缀名，比如后缀是unity3d，则AssertBundle名需要加后缀，如Capsule.unity3d 1234AssetBundle ab = AssetBundle.LoadFromFile(\"Assets/AssetBundles/Android/cube\");if(ab != null)&#123; Instantiate(ab.LoadAsset&lt;GameObject&gt;(cube))&#125; 网络加载 1234567891011IEnumerator InstantiateObject()&#123; string uri = \"file:///\" + Application.dataPath + \"/AssetBundles/\" + assetBundleName; UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); yield return request.Send(); AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(\"Cube\"); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(\"Sprite\"); Instantiate(cube); Instantiate(sprite);&#125; 动态load资源的几种途径： 通过Resources模块，调用它的load函数：可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不关有没有场景引用，都会将其全部打入到安装包中。 通过bundle的形式：即将资源打成 AssetBundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object。（AssetBundle热更的前提和基础） 通过AssetDatabase.loadasset ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。 关于AssetBundle的分组，有必要仔细思考一下，在这里分享下之前公司经历过的一个项目的真实案例。在项目开发的前期，没有注意AssetBundle的分组策略，采用的是一个UI界面一个AssetBundle，在项目的后期却怎么也打不出来包，折腾了一两天之后才终于发现这是unity官方的bug，AssetBundle包有一个数量上的限制，不能突破这个限制，于是我们修改了AssetBundle的分组策略，改为了所有UI界面一个包才最终规避了这个问题。 可以参考官方提供的分组策略： 逻辑实体分组： 一个UI界面或者所有UI界面一个包； 一个角色或者所有角色一个包； 所有场景所共享的部分一个包。 类型分组：比如Models一个包、Audio clips一个包等。 使用分组： 把在某一时间内使用的所有资源打成一个包； 把同一关卡的所有资源打成一个包； 一个场景一个包。 原则 经常更新的资源与不经常更新的资源拆分离为两个包； 把需要同时加载的资源放在同一个包； 把其他包共享的资源放在一个单独的包里面； 把一些需要同时加载的小资源打包成一个包； 如果对于同一个资源有两个版本，可以考虑通过后缀来区分。 热更文本（项目中的表格、json文件等）一般的项目中，为了方便配置控制游戏中的数值以及文本，会使用excel表格填写数据，利用python脚本将其转换成json或者二进制文件供客户端读取。文本不需要编译过程，如果遇到了相关数据的改动，更新相关文件即可。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"上帝掷骰子吗？（一）","slug":"History-of-quantum-physics-1","date":"2019-11-28T14:53:10.000Z","updated":"2019-11-28T15:38:21.052Z","comments":true,"path":"2019/11/28/History-of-quantum-physics-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/History-of-quantum-physics-1/","excerpt":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。","text":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。 最初，人们猜想，光是一种从我们的眼睛里发射出去的东西，当它到达某样事物的时候，这样事物就被我们所“看见”了。恩培多克勒（Empedocles）就认为世界是由水、火、气、土四大元素组成的，而人的眼睛是女神阿芙罗狄忒（Aphrodite）用火点燃的，当火元素（也就是光。古时候往往光、火不分）从人的眼睛里喷出到达物体时，我们就得以看见事物。 到了罗马时代，学者卢克莱修（Lucretius）在《物性论》中提出，光是从光源直接到达人的眼睛的。不过当时的人们并不相信，直到公元1000多年，小孔成像的实验最终证明了这个说法是对的。 欧几里德（Euclid）、托勒密（Ptolemy）、哈桑和开普勒（Johannes Kepler）都参与研究光的性质，于是在前人的基础上，荷兰物理学家斯涅耳（W.Snell）总结出了光的折射定律了。 最后，“业余数学之王”费尔马（Pierre de Fermat）总结为“光总是走最短的路线”。 光学终于作为一门物理学科被正式确立起来，微粒派和波动派开始了无硝烟的战争。 微粒说：光是由一粒粒非常小的“光原子”所组成的，从直观上看来是很有道理的，首先它就可以很好地解释为什么光总是沿着直线前进，为什么会严格而经典地反射，甚至折射现象也可以由粒子流在不同介质里的速度变化而得到解释。 波动说：光不是一种物质粒子，而是由于介质的振动而产生的一种波。光的波动说容易解释投影里的明暗条纹，也容易解释光束可以互相穿过互不干扰。关于直线传播和反射的问题，人们很快就认识到光的波长是很短的，在大多数情况下，光的行为就犹同经典粒子一样。而衍射实验则更加证明了这一点。 但他们也有各自的缺点 微粒说很难说清为什么两道光束相互碰撞的时候不会互相弹开，人们也无法得知，这些细小的光粒子在点上灯火之前是隐藏在何处的，它们的数量是不是可以无限多，等等。 波动说有一个基本的难题，那就是任何波动都需要有介质才能够传递，那星光是怎么穿过太空的呢？于是波动说假设了一种看不见摸不着的介质“以太”（Aether）来实现光的传播。 小故事“业余数学之王”费尔马”业余玩家可以挑战职业选手吗?在数学王国,费马先生给出了答案. 费马被誉为“业余数学之王”,因为他的本职工作是一名律师,数学只是他的业余爱好.但是他在数学上的成就一点也不比职业数学家差,也远远超过了他作为律师的影响力.他当初是不是选错行了呢? 费马出生在一个富裕的家庭,家境殷实.费马的爹是一名大皮革商,为费马提供了富裕舒适的成长环境,从小就有两个家庭教师教学这种高端配置,一点也不用担心落下功课!也许正是这两位无名的家庭教师,让费马对数学有了强烈的兴趣. 数学有许许多多的分支,不可能全部都研究,费马选定了自己的主要研究方向——数论.数论是数学上一个非常坑的分支,研究的是看起来非常简单的整数.前辈们在这个领域留下了一个个精彩的猜想,任何了解整数基本运算的人都可以理解,但是要证明这些猜想却非常困难,只要证明一个就能名垂青史.这让无数有雄心壮志的人跳进了数论这个大坑,可是只有费马一个人从坑里爬了出来。 以太亚里士多德所谓的“第五元素”，他认为日月星辰围绕着地球运转，但其组成却不同与地上的四大元素水火气土。天上的事物应该是完美无缺的，它们只能由一种更为纯洁的元素所构成—以太。 未完待续。。。","categories":[{"name":"日常阅读","slug":"日常阅读","permalink":"https://aaronyard.github.io/categories/%E6%97%A5%E5%B8%B8%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"量子物理史话","slug":"量子物理史话","permalink":"https://aaronyard.github.io/tags/%E9%87%8F%E5%AD%90%E7%89%A9%E7%90%86%E5%8F%B2%E8%AF%9D/"}]},{"title":"3D游戏引擎初探（三）","slug":"3D-Engine-3","date":"2019-11-28T14:11:31.000Z","updated":"2019-11-28T14:14:25.908Z","comments":true,"path":"2019/11/28/3D-Engine-3/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/3D-Engine-3/","excerpt":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。","text":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。 向量的加法在最开始学向量的时候大家已经知道，向量的加法遵循三角形法则和平行四边形法则，在构建游戏世界的过程中用到了向量加法的几何意义。比如游戏中怪物追击玩家的AI中，怪物知道玩家的位置，需要时时刻刻朝向玩家移动，就会在每帧运用向量的加法向玩家移动。 向量的减法向量的减法作为加法的你逆运算，集合意义也是可以用在方向的计算上，另外它还能判断两个物体之间的距离。比如游戏中怪物的追击机制有一个判断条件，那就是距离玩家大于一定的距离后才会进行追击，小于一定距离之后就不再朝向玩家移动，这是就用到了向量的减法。 向量的点乘点乘主要用在了角度的计算和材质的渲染， 判断目标在自己的前后方位 。还是以怪物追击玩家为例子，刚刚只说了追击过程中的位置移动，但是怪物和玩家都是有正面朝向的，不然玩家看到怪物背对着玩家人物进行追击会觉得怪怪的，这时就需要怪物将自己的正面转向玩家。转的角度是多少呢？此时就需要用到向量的点乘进行计算了。 也能用来判断两个向量是否垂直、计算一个向量在另一个向量上的投影分量大小 。再说材质的光照渲染，通俗意义上讲就是光线照射后的明暗效果。现实世界中不规则的材质表面接受光线照射后是有不同的表现的，从数学的几何角度上来解释就是：在shader中，当材质表面的顶点法向量与光线向量的角度（即两个向量的点积）大于90度时就不接受光线的渲染，反之亦然。 向量的叉乘1、叉乘可以用来判断两个向量是否平行或相交。返回值为0，则平行。 2、用于求平面法线（叉乘的几何意义：absinθ） 3、计算两个物体之间形成四边形的面积（|a||b|sinθ） 4、 判断目标在自己的左右方位 关于向量的点乘和叉乘容易混淆的问题，可以这么理解： 点乘判断角度，叉乘判断方向。 向量的单位化向量的单位化计算的是物体间的距离，这个就不必多做介绍了。 矩阵未完待续。。。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（二）","slug":"3D-Engine-2","date":"2019-11-27T14:29:36.000Z","updated":"2019-11-27T14:47:21.966Z","comments":true,"path":"2019/11/27/3D-Engine-2/","link":"","permalink":"https://aaronyard.github.io/2019/11/27/3D-Engine-2/","excerpt":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。","text":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。 各层关系最底层的图形库接口关系到了整个游戏将可以在哪个平台下运行，GDI是专用于Windows平台的图形库，故而只适合在Windows中运行游戏。若想在其它平台中运行，则需要对底层的渲染模块的图形库接口做兼容。 中间层的3D游戏引擎和上层的游戏逻辑其实是相辅相成的，游戏引实质是从游戏逻辑中提取出来的共用的功能。比如unity3D、虚幻4引擎、第一家入职公司自主开发的小胖引擎等等，都是把游戏最基础的图形图像光照处理等游戏逻辑提取了出来，方便开发人员编写游戏时调用，不必在开发新游戏的前期大费周章的再次编写这些底层逻辑。从而把游戏开发的重点转移到了游戏逻辑上，大大提高的开发新游戏的效率，降低了开发新游戏所需要的周期。 由此来看，自主开发的引擎或者说开源的引擎有一个优点，在游戏逻辑开发的过程中如果发现有什么需要新加或者优化的逻辑，可以直接写在引擎中，提供给游戏逻辑层一个调用的接口即可。从根本上尽量避免代码重复，代码遵循统一的风格。所以可以说：游戏引擎为游戏逻辑的开发提供了方便，游戏逻辑的开发优化了游戏引擎的完整性。 所需条件开发一款游戏需要什么条件呢？一共有四条。 语言掌握一门主流的开发语言，本项目使用的是C++语言。 这里不得不说一下C++语言的优势了 1、 C++实现了面向对象程序设计。在高级语言当中，处理运行速度是最快的，大部分的游戏软件，系统都是由C++来编写的。 2、 C++语言非常灵活，功能非常强大。如果说C语言的优点是指针，那么C++的优点就是性能和类层次结构的设计。 3、C++非常严谨、精确和数理化，标准定义很细致。 4、 C++语言的语法思路层次分明、相呼应;语法结构是显式的、明确的。 当然，这只是C++的一部分优势，在运用过程中，我们会逐渐发现C++语言之美。 线性代数在开发引擎的过程中，数学同样很重要。线性代数在游戏的开发过程中可以灵活的解决3D固定流水线中的大部分操作，物体的移动。旋转、缩放、光照等都运用到了数学原理。 GPU编程语言3D游戏引擎的核心功能就是对游戏的场景渲染和物体的材质渲染，对材质中有Alpha通道的要做特殊处理（Alpha通道是材质有透明的部分）。移动端为了减少透明材质的消耗，会通过GPU编程在shader中处理，比如unity项目中一般会把有Alpha通道的图片切割为无Alpha通道和有Alpha通道的图片，通过shader编程将其再合在一起，还有场景渲染使用的后处理效果，模型的选中效果等，都是与GPU编程息息相关的，至少需要了解和使用GPU编程语言中的一种，目前有GLSL、HLSL、CG等。 图形学算法逼真的效果需要适合的图形学算法，比如水的波纹的模拟中用到的波动方程，刚体碰撞效果等，都会用到图形学算法。 先后顺序会从最基础最底层的知识开始学习了解： 数学知识游戏世界所运用到的线性代数的相关知识，领略数学之美。 材质和光照我们就是游戏中创造万物的造物主，首先创造什么？当然是光啦！ 固定流水线晶体管中的二进制数据是如何渲染到屏幕上供我们所观看呢？固定流水线会为你解密这一切。 游戏引擎架构将功能模块进行细分，分步实现，为下一步的整合做好前期准备。 3D游戏引擎的底层架构和封装用计算机语言实现每个功能模块，享受制作引擎工具的乐趣，这就是你手中的模板，用它就能创造一个又一个不同的游戏世界。 游戏逻辑引擎已经搭建完毕了，那么下一步就是进一步搭建可以与玩家互动的游戏世界啦。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（一）","slug":"3D-Engine-1","date":"2019-11-24T15:52:45.000Z","updated":"2019-11-27T14:47:36.167Z","comments":true,"path":"2019/11/24/3D-Engine-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/3D-Engine-1/","excerpt":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。","text":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。 本地化操作书籍中的编辑器是VS2013版，而我在学习的时候使用的是最新版的VS2019，跟着作者学习编写了所有代码，亲测可用，大家可以放心的编写学习啦。 材质地形编辑器书籍中对于材质地形编辑器的描述相当的少，我会在后期详细的描述材质地形是如何编辑的。 个人提升写本博客是必不可少的会重新过一遍书籍以及整合自身所学知识，算是对自己的再一次沉淀和查漏补缺。 收获对数据结构的理解上升了，图形学算法也有查找资料与编写demo的过程中有所了解和应用，学会了进行场景渲染以及物体的材质渲染，对于渲染管线以及传说中的shader不再陌生，也因此具备了宏观上的一些架构能力，对游戏的整体架构有了一定的认识。最重要的是也因此对我自身工作中所用的unity引擎有了更深层次的了解。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"博客建站","slug":"Hexo-blog","date":"2019-11-24T05:44:07.000Z","updated":"2019-11-24T11:20:46.195Z","comments":true,"path":"2019/11/24/Hexo-blog/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/Hexo-blog/","excerpt":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏","text":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏 准备工作 在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 配置好了相关的环境变量。 本文所使用的环境： Windows 10 node.js @12.13.1 Github Desktop @2.2.3 hexo @4.0.0 新建Github仓库在Github中新建一个名为 你的用户名.github.io 的仓库，例如你的GitHub用户名为example，则仓库名为 example.github.io ，这样，将来你的网站访问地址就是 http://example.github.io 了。 配置SSH keySSH key解决了本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git命令行。不要着急，按照如下指令做。 1$ ssh-keygen -t rsa -C \"Github注册邮箱\" 接着连续3次回车后，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的GitHub主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，title随意填写，将刚刚复制的内容粘贴到key中。 验证是否配置成功 1$ ssh -T git@github.com // 注意邮箱地址不用改 在弹出的 Are you sure you want to continue connecting (yes/no)? 后输入yes。 若显示 Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access. 则表明SSH配置成功。 接着输入如下指令 12$ git config --global user.name \"xxx\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@xxx.com\"// 填写你的github注册邮箱 如果遇到git非内外部指令的情况，则说明你没有为git配置环境变量，GitHub Destop的环境变量路径可参考： 1C:\\Users\\AaronEN\\AppData\\Local\\GitHubDesktop\\app-2.2.3\\resources\\app\\git\\cmd Hexo类型：静态网页 特点：速度快、部署简单、免费、结合github pages、支持markdown、内容布局自定义功能强. Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章！我的个人博客就是基于hexo生成的。很多网友对hexo的最深刻印象就是速度快和部署简单了。一个个人博客最核心的功能支持的非常好，你可以专心的写一些技术文章部署到上面了。 安装1$ npm install -g hexo 初始化找个目录存放你的项目代码，例如我的是 D:\\AaronYard 。 12$ cd /d/AaronYard/$ hexo init 初始化后的项目会自带一个主题，此时可以生成一个可以预览的网站。 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中输入 http://localhost:4000/，就可以浏览你的网站了。 主题当然啦，我们并不满足于官方提供的主题，此时就可以去寻觅自己喜欢的主题啦。 官方提供的主题网站：https://hexo.io/themes/ 我的网站的主题是hexo-theme-icarus 接下来就是下载主题的时刻啦！ 12$ cd /d/AaronYard/$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/hexo-theme-icarus 下载的主题会放在themes目录下，修改根目录下_config.yml中的theme: landscape改为theme: hexo-theme-icarus，然后重新执行hexo g来重新生成。 注意主题中的_config.yml也是需要修改的，对此有点基础的摸索片刻后就会修改了。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 提交GitHub在辛苦并快乐着的搭建工作之后，就可以愉快的将博客提交到GitHub中了。 配置根目录下_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:example/example.github.io.git branch: master 安装一个插件 1$ npm install hexo-deployer-git --save 提交本次改动的代码 1$ hexo d 至此，个人博客的框架搭建完成，还需要内容的扩充。 写博客定位到项目的根目录，输入命令 1$ hexo new \"hello-world\" hexo会帮我们在_posts目录下生成相关md文件md文件的目录结构一般如下 12345678---title: postName #文章页面上的显示名称，一般是中文date: 2019-11-24 13:44:07 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格---以下是正文 编写md文件后执行hexo g与hexo s即可浏览博客，若满意就可以hexo d愉快的提交博客啦。 写博客的工具关于写博客的工具，我用的是markdown editor，非常好用，左侧编写，右侧实时展现效果。编写的语法可参见hexo官方写作Wiki。 Hexo常用命令1234567891011121314151617hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本#缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy#组合命令hexo s -g #生成并本地预览hexo d -g #生成并上传 题外话我博客右下方有一只unitychan，很有趣吧，是基于live2d技术做的，感兴趣的可以点击此处学习搭建。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"博客建站","slug":"博客建站","permalink":"https://aaronyard.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"}]},{"title":"我的个人博客开通啦","slug":"MyHexo","date":"2019-11-23T14:44:14.000Z","updated":"2020-04-07T04:22:38.921Z","comments":true,"path":"2019/11/23/MyHexo/","link":"","permalink":"https://aaronyard.github.io/2019/11/23/MyHexo/","excerpt":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。","text":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。 关于我毕业于师范大学数学系，大学期间，我发现对于计算机的兴趣远大于数学带给我的快感，所以像老师申请了计算机实验室，在其中学习成长。在学院老师和同学的帮助下，我成立了团工委网络部，申请了微信公众号，从此开始了我的计算机探索之旅。 承蒙老师厚爱，我在北京实习参加工作，大三暑期开始在完美世界旗下子公司实习游戏客户端岗位，毕业后成功转正。因想稳定下来，目前回到家中，进入了另一家游戏公司继续成长。 三年的工作时间，令我从一个什么都不懂的毛头小子蜕变成了一个敢想敢干的小程序猿。为了弄明白3D游戏的原理，通过查资料以及实践，用C++编写了一个基于GDI的简易的完整3D引擎，并且为这个引擎写了一个游戏小demo，游戏成功运行的那一刻，我终于明白了什么是实践出真知。今天，这个小程序猿，又开始了想象之旅。 建站灵感 一开始没有想过要搭建一个网站啦，早上的时候看了知乎的一篇文章，里面介绍了一些让我很感兴趣的读物，我想从其中的一本书《上帝掷骰子吗？─量子物理史话》开始阅读，并且写下我的读书心得。 于是，我下载了这本书的电子版本当我阅读后想写读书心得时，突然意识到没有一个合适的网站供我书写。也许搭建一个个人博客是个不错的选择呢！毕竟我可以学习怎么搭建嘛，于是对互联网有一些了解的我，开始了漫长的建站之旅。 不断尝试通过对互联网服务器的一些了解，我将自己的笔记本当作服务器，运行了Tomcat，利用花生壳的内网穿透功能，捣鼓了一波家中的路由器，成功的在外网访问到了内网的网站。 但是这远远不够，我还需要一个适合我的网站管理系统，最终我找到了这个hexo，简直神器，完全不需要我进行内网穿透嘛！！而且基于git管理，网站管理方便，支持MarkDown编写，简直满足了我的一切需求。 今日心得新技能Get√ 终于把个人博客有模有样的捣鼓出来了，我可以在以后的日子里专心的写读书心得啦。","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://aaronyard.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"新技能Get√","slug":"新技能Get√","permalink":"https://aaronyard.github.io/tags/%E6%96%B0%E6%8A%80%E8%83%BDGet%E2%88%9A/"}]}]}
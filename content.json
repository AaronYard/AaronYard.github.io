{"meta":{"title":"汪震|个人博客","subtitle":"","description":"","author":"汪震","url":"https://aaronyard.github.io","root":"/"},"pages":[{"title":"汪震","date":"2019-11-28T14:18:31.193Z","updated":"2019-11-28T14:18:31.193Z","comments":true,"path":"about/index.html","permalink":"https://aaronyard.github.io/about/index.html","excerpt":"","text":"欢迎您来到我的 个人博客！我将在这里分享我的个人心得、技术见解、学习历程，给自己一个沉淀的机会，也为大家分享一条前行的路。关于技术方面的问题，大家均可以分享探讨，我个人见解若有不足之处，也欢迎大家批评指正。 因某些原因，暂时没有办法建立一个属于自己的微信公众号，所以不能及时的发布最新的文章，会抓紧时间处理的。 关于我👱‍♂️汪震\\男\\1995 👨‍💻Github：https://github.com/AaronYard 📝目前为unity3D客户端，业余时间沉淀专研3D游戏引擎以及机器学习，目标是全栈。 请联系我📮邮箱：tomwang95@163.com"},{"title":"Tags","date":"2019-11-23T07:33:54.956Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://aaronyard.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-11-23T07:33:54.918Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://aaronyard.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"游戏项目中的全自动打包机制","slug":"AutomaticPackaging","date":"2020-04-06T07:27:18.000Z","updated":"2020-04-06T12:08:51.832Z","comments":true,"path":"2020/04/06/AutomaticPackaging/","link":"","permalink":"https://aaronyard.github.io/2020/04/06/AutomaticPackaging/","excerpt":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。","text":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。 前期准备工作1、各个渠道的sdk资源按渠道分类至各个渠道文件夹中，包括这个渠道打包所需要的【AndroidManife.xml、res、so、jar包、java代码】（Android）或【framework、.a文件、InfoPlisst、蕴含生命周期的UnityAppController.mm/AppDelegate.m文件】（ios）等资源文件。 2、一台单独打包机器（资金充足的话建议单独配打包机器），建议用MAC机，因为ios包只能用MAC机来打，而MAC机还能打安卓apk。 3、Jenkins，一个开源的可拓展的自动化服务器，关于Jenkins可以单独拿出来将一篇文章了，再此简单的说一下Jenkins的持续集成流程：提交代码–&gt;拉取代码–&gt;编译–&gt;打包–&gt;测试–&gt;反馈问题–&gt;开发处理–&gt;提交代码，从这一流程就可以窥探到Jenkins的便利。 4、打包所用的脚本：build.bat或者build.sh脚本。 5、unity项目代码中可供打包脚本调用的打包相关静态方法。 具体流程1、Jenkins中Build with Parameters里输入相应的打包参数，坐等打包完成，打包过程对你来说是透明的，完毕…哈哈，开个玩笑，接下用最通俗的语言带你揭秘打包流程。 2、全自动化打包流程最重要的在于打包脚本，接收到你的输入参数后开始工作，首先覆盖平台相关资源，其次拉取svn到指定版本，然后再将将指定平台写入代码中，最后关闭打包机上unity和资源管理器窗口。关闭unity尤为重要，不然unity会以进程被占用为由告诉你打包失败。 3、设置Unity宏定义，表明这个包是某个渠道的宏定义。 4、设置游戏版本号，便于后期维护发热更新。 5、构建游戏Aesstbundle资源：调用打包代码，构建资源输出到指定目录，将资源打成压缩包输出到resource目录下。 6、构建游戏安装包。 相关代码build.sh 123456789101112131415#!/bin/bash#define varUnityCmd=/Applications/Unity/Unity.app/Contents/MacOS/Unity CurrentPath=$(cd `(dirname $0)`; pwd)PROJECTHOME=$&#123;CurrentPath&#125;/../FUNCTION_NAME=\"\"BUILDHOME=\"\"APP_NAME=\"\"cmdBuildAB=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod BuildEditor.BuildAndroidAB\"$cmdBuildABcmd=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod AutoBuild.$&#123;FUNCTION_NAME&#125; -outPath $&#123;BUILDHOME&#125;/$&#123;APP_NAME&#125; -logFile\"$cmd C#静态方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//打AssetBundle//state 0:apk 1: ios: 2: editor 3:iOS不压缩ab 4:不挪动UI 5:GOOGLE OBBpublic static void BuildAssetBundle(int state)&#123; DirectoryInfo direc = new DirectoryInfo(Application.streamingAssetsPath + \"/AssetsBundle\"); if (direc.Exists) &#123; direc.Delete(true); &#125; m_abDataLs.list.Clear(); m_options = BuildAssetBundleOptions.CollectDependencies; if(state == 0 || state == 10) &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; m_target = BuildTarget.Android; &#125; else &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; if(state == 1 || state == 3) &#123; m_target = BuildTarget.iPhone; &#125; else if(state == 2) &#123; m_target = BuildTarget.StandaloneWindows; &#125; &#125; if (state == 0 || state == 1) &#123; //移动打包资源 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); AutoBuild.MoveUIResToTemp(); &#125; if (state == 5) &#123; //移除一部分资源去打obb包 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileNameObb, AutoBuild.DirecPrefabFileNameObb); &#125; if (state == 3 || state == 4) &#123; // 只移动Resource/Prefab AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); &#125; //打AssetBundle BuildAB(state); if (state != 3) &#123; //压缩AssetBundle AssetBundleCompress(); &#125;&#125;//打apkpublic static void Build_Apk(int XXqudao)&#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, \"PLAT_SDK_XXqudao\"); PlayerSettings.bundleIdentifier = \"com.xxx.xxx.xxx\"; BuildAndroid(XXqudao);&#125;//移动相关的资源static void BuildAndroid(int XXqudao)&#123; //移动相关平台sdk资源文件夹 MovePluginDir(XXqudao); //替换一些DLL文件 ReplaceDll(\"Android\", \"DLL\"); //替换一些包体内需要用到的图片icon文件 ReplaceLoadingImage(XXqudao); //开始build BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions(); buildPlayerOptions.scenes = new[] &#123; \"Assets/Scene1.unity\", \"Assets/Scene2.unity\" &#125;; buildPlayerOptions.locationPathName = m_outPath; buildPlayerOptions.target = BuildTarget.Android; buildPlayerOptions.options = BuildOptions.None; BuildReport report = BuildPipeline.BuildPlayer(buildPlayerOptions); BuildSummary summary = report.summary; if (summary.result == BuildResult.Succeeded) &#123; Debug.Log(\"Build succeeded: \" + summary.totalSize + \" bytes\"); &#125; if (summary.result == BuildResult.Failed) &#123; Debug.Log(\"Build failed\"); &#125; //将editor使用的DLL恢复 RecoveryDll(\"DLL\"); //恢复sdk资源文件夹 RecoveryPluginDir();&#125; 写在最后这里只是提供一个大体的思路，实际上在自动化流程中还是有很多大大小小的坎坷的，比如一些已经成形的项目，其项目目录结构需要单独进行适配，一些渠道打包需要单独进行调整等，这些都是要考虑到的。 关于sdk：建议单独分出一个集成sdk的部门，用于将各个渠道的sdk集成到一个主的sdk上，游戏项目只需要接入一个sdk即可，使得sdk接入工作透明化，游戏开发人员专注于游戏业务逻辑的开发，更加高效。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的小包更新机制","slug":"AssetsPackage","date":"2020-04-05T12:21:28.000Z","updated":"2020-04-06T06:48:10.793Z","comments":true,"path":"2020/04/05/AssetsPackage/","link":"","permalink":"https://aaronyard.github.io/2020/04/05/AssetsPackage/","excerpt":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考：","text":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考： 方案一没有一个官方的名字，姑且叫它强制小包法叭。 在打apk的时候，将游戏用到的代码、闪屏图、loading图、主场景、登录场景、表格、开场动画等最基本的资源提前准备好，在打包时替换进去，这样包体不会很大，玩家所需的拓展资源则通过项目里的热更新机制加载。 这个方法有一个缺点，由于包体内所携带的资源并不完整，只能保证游戏可以运行不会崩溃，更多的功能资源包则需要在登录游戏之前下载。若热更新较大则会“吓跑”一些新玩家（不成文规定：新发布游戏的热更新包体宜小于30M），为了减少这一影响，第二种补充方案应运而生了。 方案二游戏内小包资源法，作为方案一的补充，它对玩家更友好。 将项目内容分为必须功能和非必须功能，如玩家信息系统、公告系统、技能系统、排行榜系统、基本的新手任务系统以及主城场景等游戏正常运行所必须的或占资源不多的功能系统可以统一将预制图集资源打进包里。但是类似宠物系统、武将系统、野怪系统等占用较多预制资源分类打进AB小包中，用一个json文件来管理资源列表。 在loading主场景的时候，异步检测线上小包资源的json配置是否存在，若存在且为wifi环境则异步下载资源并解压预加载，主界面也会显示相应的窗口。若玩家当前网络环境不满足下载资源的要求，则会在非必须的功能入口处做出限制，告知需要加载资源包才能体验完整的游戏功能，并且会在加载完毕资源后给予一定的奖励。 这样玩家在初始阶段流失的相应较少，体验更佳，对玩家更为友好。 热更新机制热更新机制已经在另一篇文章中详细阐述了，再此就不重复介绍了。 游戏内小包资源法1、小包有对应的资源版本号，在游戏打包前设定相应的资源版本号，而在拉取小包资源的时候也是以资源版本号作为索引去寻找相应的json配置文件。 2、商业游戏最重要的是游戏安全，可以在写入json配置文件列表的脚本中加入相应的文件大小及MD5等信息作为校验，这样就不会轻易被第三方非法修改。 3、在小包解压时，有概率会出现一些文件解压失败，损失一部分资源，或者玩家不小心删掉了一些资源文件，这个时候在重新下载所有小包资源就不明智了。在游戏中给玩家提供一个主动校验资源的功能，根据现有资源文件名遍历json配置资源列表来寻找需要缺失的文件，异步下载并解压。 4、游戏内小包资源法与热更新机制在本质上是一样的，都是通过unity的AssetBundle加载机制来实现的。 小包资源的加载状态123456789101112public enum AssetsPackageState&#123; None,//初始状态，最初的未加载状态 ReadFileEnd,//读取完json配置文件 DownLoadStart,//开始下载josn文件列表中的小包资源文件 DownLoadStop,//暂停下载josn文件列表中的小包资源文件，并保存当前的下载进度 DownLoadComplete,//小包资源下载完成 DecompressStart,//小包资源开始解压 DecompresFail,//小包资源解压失败 AssetsReady,//资源校验已准备好 AssetsCheck,//资源校验中（成功时会通过回调告知玩家校验结果）&#125; 无感知下载小包资源在加载进入主主场景时，检测是否需要加载资源，根据网络环境并自动加载,代码流程大致如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//初始化检测功能public void CheckInitDownLoad()&#123; //不是初始化状态，说明进入主场景后已经检查过了，不必再走下面的逻辑 if (m_curAssetsPackageState != AssetsPackageState.None) &#123; return; &#125; if (IsAssetsPackageReady()) &#123; m_isDecompressSuc = true; m_isDownLoadSuc = true; m_curAssetsPackageState = AssetsPackageState.AssetsReady; &#125; else &#123; if (m_curAssetsPackageState == AssetsPackageState.None) &#123; LoginCheckDownLoadInfo(); &#125; &#125;&#125;// 资源包是否下载解压好public bool IsAssetsPackageReady()&#123; if(m_data.assetPackage != null) &#123; return m_data.assetPackage.isAssetsPackageReady; &#125; return false;&#125;//用于登录检查下载资源private void LoginCheckDownLoadInfo()&#123; //创建下载目录 m_availablePath = GetPathForPlatform(platform, TargetAssetsBundlPath); if (!Directory.Exists(m_availablePath)) &#123; Directory.CreateDirectory(m_availablePath); &#125; if (m_updateStruct == null) &#123; GetUpdateStructForSvr(InitUpateFileInfo); &#125; else &#123; InitUpateFileInfo(); &#125; &#125;//拉取下载文件清单信息private void GetUpdateStructForSvr(Action succCB = null)&#123; var url = \"....\";//json文件的url DownloadSmallFileTask(url, (string text) =&gt;//下载并解析json文件 &#123; m_updateStruct = JsonMapper.ToObject&lt;UpdateStruct&gt;(text);//将json数据转为C#结构 if (m_updateStruct != null) &#123; if (succCB != null) succCB(); &#125; &#125;); //succCB批次任务执行成功回调,failCB批次任务执行失败回调,netConnectCheckCB网络连接检查回调,tryTimeLimit任务失败后尝试次数上限,value=0默认没有上限，不为0时，超过上限后结束任务执行 StartDownloadSmallFile(succCB, failCB, netConnectCheckCB, tryTimeLimit);&#125;public class UpdateInfo&#123; public string name; public int size; public string md5; public int desize; public string demd5; public UpdateInfo() &#123; name = \"\"; size = 0; md5 = \"\"; desize = 0; demd5 = \"\"; &#125;&#125;//初始化更新文件信息private void InitUpateFileInfo()&#123; //遍历json中的下载信息，统计已下载，总下载，初始化需要下载文件列表 for (int i = 0; i &lt; m_updateInfo.Count; i++)//遍历json数据转换后的list &#123; var updateInfo = m_updateInfo[i]; InitFileReadTask(m_updateInfo[i], m_availablePath);//添加异步下载任务 m_needDeleteFileList.Add(m_availablePath + m_updateInfo[i].name); &#125;&#125;//初始化文件读取任务private void InitFileReadTask(UpdateInfo updateInfo, string path)&#123; string fileName = \"ABC.ab\"; string url = \"https://www.AAA.com/ABC.ab\"; string decompressFileName = \"abc\"; //下载文件读取 m_totalSize += updateInfo.size; AddReadFileTask(fileName, updateInfo.md5, updateInfo.size, //读取成功回调 () =&gt; &#123; m_curSize += updateInfo.size; &#125;, //读取失败回调 (TaskWorkStatus status) =&gt; &#123; AddDownloadBigFileTask(fileName, url, updateInfo.md5, updateInfo.size, () =&gt; &#123; m_childDownSize = 0; m_curSize += updateInfo.size; &#125;, (TaskWorkStatus downStatus) =&gt; &#123; m_childDownSize = 0; &#125;, (long curSize) =&gt; &#123; m_childDownSize = curSize; &#125; ); &#125; ); //解压后文件读取 var unDecompressFile = new CUnzipFile(fileName, decompressFileName, updateInfo.desize); m_totalDecompressSize += updateInfo.desize; AddReadFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;, (TaskWorkStatus status) =&gt; &#123; AddDecompressFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, unDecompressFile, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;); &#125; );&#125;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"浅谈游戏安全","slug":"GameSecurity","date":"2020-03-06T12:22:18.000Z","updated":"2020-04-06T15:07:23.985Z","comments":true,"path":"2020/03/06/GameSecurity/","link":"","permalink":"https://aaronyard.github.io/2020/03/06/GameSecurity/","excerpt":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科","text":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科 外挂的弊端一些外挂会破坏游戏的平衡，造成网络游戏的极度不公平，影响正常玩家的游戏体验，若长时间不控制，正常玩家会逐渐流失。 外挂的种类1、外挂修改器，独立于手机之外的一个小软件，原理是修改内存，有时即使时特意通过第三方加固过的安装包也无法杜绝数据内存被修改。 2、外挂包，即安装包的包体被修改，替换了dll以及so库等。 应对方法项目有幸被这两种外挂盯上，由于在开发阶段部分功能没有做好数据加密防护，在被外挂魔改之后，达成了一刀秒杀，满攻速，免疫所有伤害等，所幸咱也不怕，兵来将挡，水来土掩，开始与外挂斗智斗勇。 对于外挂修改器，对核心数据进行加密，修改一下存储的数据类型，就可以杜绝大部分外挂修改器的修改，其次，可以对数据进行基本的校验，比如存储时将数据分别*2和/2，三份数据均存在本地，取数据时再进行校验，如果数据不对就闪退。 对于包体被修改，可以在打包之后对包体内的文件进行md5校验，运行游戏的时候如果发现md5不对就闪退。也可以使用第三方加固包体的服务，使得包体无法再被修改。 另外，终极大招就是在服务器端对数据进行校验，这样外挂就无机可乘了。 相关代码可以参考以下代码 DBTools.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485using System;using System.Collections.Generic;using System.Linq;using System.Security.Cryptography;using System.Text;using System.Threading.Tasks; namespace DBTools&#123; public class Encryption &#123; /// &lt;summary&gt; /// 加密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Encrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); byte[] inputByteArray; inputByteArray = Encoding.Default.GetBytes(Text); des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); StringBuilder ret = new StringBuilder(); foreach (byte b in ms.ToArray()) &#123; ret.AppendFormat(\"&#123;0:X2&#125;\", b); &#125; return ret.ToString(); &#125; /// &lt;summary&gt; /// 解密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Decrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); int len; len = Text.Length / 2; byte[] inputByteArray = new byte[len]; int x, i; for (x = 0; x &lt; len; x++) &#123; i = Convert.ToInt32(Text.Substring(x * 2, 2), 16); inputByteArray[x] = (byte)i; &#125; des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); return Encoding.Default.GetString(ms.ToArray()); &#125; // MD5 32 位 public static String Encrypt32(String convertString) &#123; MD5 md5 = new MD5CryptoServiceProvider(); byte[] bytes = System.Text.Encoding.UTF8.GetBytes(convertString); bytes = md5.ComputeHash(bytes); md5.Clear(); string ret = \"\"; for (int i = 0; i &lt; bytes.Length; i++) &#123; ret += Convert.ToString(bytes[i], 16).PadLeft(2, '0'); &#125; return ret.PadLeft(32, '0').ToLower(); &#125; // MD5 16 位 public static string Encrypt16(string convertString) &#123; MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); string t2 = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(convertString)), 4, 8); t2 = t2.Replace(\"-\", \"\"); return t2.ToLower(); &#125; &#125;&#125; 编码时： 123//LoginPwd--要加密的数据。也可以将二进制值传递给此函数。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。//Master--用来对 LoginPwd 进行加密的加密密钥。解密时必须使用同一密钥才能获得原始值。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。string Pwd = DBTools.Encryption.Encrypt(LoginPwd, \"Master\"); 与大多数口令一样，最好选择无法被轻易猜到的密钥值。建议选择满足以下条件的密钥值：长度至少为 16 个字符，混合使用大小写并包含数字、字母和特殊字符。每次要对数据进行解密时，都需要使用此密钥。 解码时： 1string Pwd = DBTools.Encryption.Decrypt(LoginPwd, \"Master\"); ##总结 魔高一丈道高一尺，遇到外挂不要害怕，他们并不可怕，钻研外挂的原理，从源头上击垮他们。在项目立项之初，也要有数据加密的意识，一些重要的运算放在服务器端，客户端只做展示，不给外挂可乘之机。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的热更新机制","slug":"GameUpdate","date":"2019-11-30T13:51:31.000Z","updated":"2020-04-05T12:18:12.934Z","comments":true,"path":"2019/11/30/GameUpdate/","link":"","permalink":"https://aaronyard.github.io/2019/11/30/GameUpdate/","excerpt":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。","text":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。 代码热更新实现方式： 1、使用Lua脚本编写游戏的UI或者其他逻辑，Lua是一个精悍小巧的脚本语言，可以跨平台运行解析，而且不需要编译过程。（热更lua） 2、使用C#Light（热更L#） 3、使用C#反射技术（热更DLL） 热更C#代码（DLL）针对C#代码热更新的机制做一个简单的概述，在安卓上可以通过C#的语言特性——反射机制实现动态代码加载从而实现热更新。 具体做法是：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。注：将这部分dll改个名字放在安卓包体中，可以防止一些别有用心的人做一些别有用心的事情。 但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。 关于C#在苹果系统上热更新的思考可以参考此处。 Lua热更新项目中使用的是ulua更新框架，不仅支持热更lua，还支持热更C#Light（L#），之所以把这两者放在一起讲是因为他们都支持安卓与苹果系统的热更新。 Lua热更新的原理：在客户端可以编写Lua的解析器，通过这个解析器，可以运行最新的Lua脚本，后期可以把控制游戏逻辑的代码都写成Lua脚本。 C#和lua中的类型可以一一对应。 Lua 和 C#中类型的对应nil null String System.String number System.Double boolean System.Boolean table Lualnterface.LuaTable function LuaInterface.LuaTable Lua中通过表来实现面向对象的一个小例子123456789101112131415161718192021222324252627282930Enemy = &#123;&#125; --申明对象loacal this = Enemy --申明this关键字代表当前对象--定义并声明对象中的属性Enemy.hp=100Enemy.speed=12--定义并声明对象中的方法Enemy.Move = function() print(\"移动\")endfunction Enemy.Attact() print(this.hp,\"攻击\") this.Move()end--执行Enemy.Attact() Lua解析器示例在C#中执行访问Lua代码12345678910111213Lua lua = new Lua(); //创建Lua解析器lua[\"num\"] = 5; //定义一个 numlua[\"str\"] = \"a string\"; //定义一个字符串lua.newTable(\"tab\"); //创建一个表 tab=&#123;&#125;//取得Lua环境中的变量double num = (double)lua[\"num\"];string str = (string)lua[\"str\"]; 在C#脚本中执行Lua脚本文件，或者脚本字符串1234567lua.DoFile(\"script.lua\");//执行script.lua脚本lua.DoString(\"num = 2\");//执行lua代码lua.DoString(\"str = 'a string'\");object[] retVals = lua.DoString(\"return num,str\"); 在热更新中，只需要写好解析Lua脚本的代码，然后C#代码不需要变动，只需要修改lua脚本就好，通过lua脚本控制游戏逻辑。 把一个C#方法注册进Lua的一个全局方法1234567891011//把一个类中的普通方法注册进去Lua.RegisterFunction(\"NormalMethod\",obj,obj.GetType().GetMethod(\"NormalMethod\"))lua.DoString(\"NormalMethod()\") //把一个类的静态方法注册进去lua.RegisterFunction(\"StaticMethod\",null,typeof(ClassName).GetMethod(\"StaticMethod\"))lua.DoString(\"StaticMethod()\") 在Lua中使用C#脚本123456789101112131415require \"luanet\" --引入库，相当于 import--加载CLR的类型、实例化CLR对象luanet.load_assembly(\"System.Windows.Forms\")luanet.load_assembly(\"System.Drawing\") --表示加载了一个dll，理解为加载了system.drawing的命名空间Form = luanet.import_type(\"System.Windows.Forms.Form\") --表示引入了System.Windows.Forms下的一个类FormStartPosition = luanet.import_type(\"System.Windows.Forms.FormStartPosition\")print(Form)print(StartPosition) 在Lua中使用C#中的类创建对象的时候，会自动匹配最合适的构造方法。 在Lua中访问C#中的属性和方法Lua代码中，访问C#对象的属性的方法和访问table的键索引一样，比如obj.name 或者 obj[“name”] Lua代码中，访问C#对象的普通函数的方式和调用table的函数一样，如：obj:method() 注：在Lua中访问C#中的方法 - 特殊情况 当函数中有out或者ref参数时，out参数和ref参数和函数的返回值一起返回，并且调用的时候，out参数不需要传参。 AssetBundle热更新AssetBundle是一个特定于平台的资产压缩包，资产包括Models、Textures、Prefabs、Audio clips等，每个不同的平台打包出来的AssetBundle不同。AssetBundle的热更新是unity官方支持的。 选择需要打包的资源，在inspector视图底部，找到AssetBundle选项，默认是None，选项卡选择NEW，输入自定义的AssetBundle名称，后面第二个选项卡是AssetBundle的后缀名，可选可不选，如果你使用了后缀，那么加载AssetBundle的时候需要带上后缀名。如果创建的标签是window标签，那么所有window标签的资源会打到一起window AssetBundle。也就是说，Unity会自动把相同标签的资源打包成一个整体。 使用官方提供的API打AB以及加载AB，BuildPipeline.BuildAssetBundles这个API，参数一是打包后AssetBundle的存放路径，参数二是压缩方式，参数三是打包的平台。 1public static AssetBundleManifest BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform); 本地加载，如果你设置的AssertBundle有后缀名，比如后缀是unity3d，则AssertBundle名需要加后缀，如Capsule.unity3d 1234AssetBundle ab = AssetBundle.LoadFromFile(\"Assets/AssetBundles/Android/cube\");if(ab != null)&#123; Instantiate(ab.LoadAsset&lt;GameObject&gt;(cube))&#125; 网络加载 1234567891011IEnumerator InstantiateObject()&#123; string uri = \"file:///\" + Application.dataPath + \"/AssetBundles/\" + assetBundleName; UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); yield return request.Send(); AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(\"Cube\"); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(\"Sprite\"); Instantiate(cube); Instantiate(sprite);&#125; 动态load资源的几种途径： 通过Resources模块，调用它的load函数：可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不关有没有场景引用，都会将其全部打入到安装包中。 通过bundle的形式：即将资源打成 AssetBundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object。（AssetBundle热更的前提和基础） 通过AssetDatabase.loadasset ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。 关于AssetBundle的分组，有必要仔细思考一下，在这里分享下之前公司经历过的一个项目的真实案例。在项目开发的前期，没有注意AssetBundle的分组策略，采用的是一个UI界面一个AssetBundle，在项目的后期却怎么也打不出来包，折腾了一两天之后才终于发现这是unity官方的bug，AssetBundle包有一个数量上的限制，不能突破这个限制，于是我们修改了AssetBundle的分组策略，改为了所有UI界面一个包才最终规避了这个问题。 可以参考官方提供的分组策略： 逻辑实体分组： 一个UI界面或者所有UI界面一个包； 一个角色或者所有角色一个包； 所有场景所共享的部分一个包。 类型分组：比如Models一个包、Audio clips一个包等。 使用分组： 把在某一时间内使用的所有资源打成一个包； 把同一关卡的所有资源打成一个包； 一个场景一个包。 原则 经常更新的资源与不经常更新的资源拆分离为两个包； 把需要同时加载的资源放在同一个包； 把其他包共享的资源放在一个单独的包里面； 把一些需要同时加载的小资源打包成一个包； 如果对于同一个资源有两个版本，可以考虑通过后缀来区分。 热更文本（项目中的表格、json文件等）一般的项目中，为了方便配置控制游戏中的数值以及文本，会使用excel表格填写数据，利用python脚本将其转换成json或者二进制文件供客户端读取。文本不需要编译过程，如果遇到了相关数据的改动，更新相关文件即可。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"上帝掷骰子吗？（一）","slug":"History-of-quantum-physics-1","date":"2019-11-28T14:53:10.000Z","updated":"2019-11-28T15:38:21.052Z","comments":true,"path":"2019/11/28/History-of-quantum-physics-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/History-of-quantum-physics-1/","excerpt":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。","text":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。 最初，人们猜想，光是一种从我们的眼睛里发射出去的东西，当它到达某样事物的时候，这样事物就被我们所“看见”了。恩培多克勒（Empedocles）就认为世界是由水、火、气、土四大元素组成的，而人的眼睛是女神阿芙罗狄忒（Aphrodite）用火点燃的，当火元素（也就是光。古时候往往光、火不分）从人的眼睛里喷出到达物体时，我们就得以看见事物。 到了罗马时代，学者卢克莱修（Lucretius）在《物性论》中提出，光是从光源直接到达人的眼睛的。不过当时的人们并不相信，直到公元1000多年，小孔成像的实验最终证明了这个说法是对的。 欧几里德（Euclid）、托勒密（Ptolemy）、哈桑和开普勒（Johannes Kepler）都参与研究光的性质，于是在前人的基础上，荷兰物理学家斯涅耳（W.Snell）总结出了光的折射定律了。 最后，“业余数学之王”费尔马（Pierre de Fermat）总结为“光总是走最短的路线”。 光学终于作为一门物理学科被正式确立起来，微粒派和波动派开始了无硝烟的战争。 微粒说：光是由一粒粒非常小的“光原子”所组成的，从直观上看来是很有道理的，首先它就可以很好地解释为什么光总是沿着直线前进，为什么会严格而经典地反射，甚至折射现象也可以由粒子流在不同介质里的速度变化而得到解释。 波动说：光不是一种物质粒子，而是由于介质的振动而产生的一种波。光的波动说容易解释投影里的明暗条纹，也容易解释光束可以互相穿过互不干扰。关于直线传播和反射的问题，人们很快就认识到光的波长是很短的，在大多数情况下，光的行为就犹同经典粒子一样。而衍射实验则更加证明了这一点。 但他们也有各自的缺点 微粒说很难说清为什么两道光束相互碰撞的时候不会互相弹开，人们也无法得知，这些细小的光粒子在点上灯火之前是隐藏在何处的，它们的数量是不是可以无限多，等等。 波动说有一个基本的难题，那就是任何波动都需要有介质才能够传递，那星光是怎么穿过太空的呢？于是波动说假设了一种看不见摸不着的介质“以太”（Aether）来实现光的传播。 小故事“业余数学之王”费尔马”业余玩家可以挑战职业选手吗?在数学王国,费马先生给出了答案. 费马被誉为“业余数学之王”,因为他的本职工作是一名律师,数学只是他的业余爱好.但是他在数学上的成就一点也不比职业数学家差,也远远超过了他作为律师的影响力.他当初是不是选错行了呢? 费马出生在一个富裕的家庭,家境殷实.费马的爹是一名大皮革商,为费马提供了富裕舒适的成长环境,从小就有两个家庭教师教学这种高端配置,一点也不用担心落下功课!也许正是这两位无名的家庭教师,让费马对数学有了强烈的兴趣. 数学有许许多多的分支,不可能全部都研究,费马选定了自己的主要研究方向——数论.数论是数学上一个非常坑的分支,研究的是看起来非常简单的整数.前辈们在这个领域留下了一个个精彩的猜想,任何了解整数基本运算的人都可以理解,但是要证明这些猜想却非常困难,只要证明一个就能名垂青史.这让无数有雄心壮志的人跳进了数论这个大坑,可是只有费马一个人从坑里爬了出来。 以太亚里士多德所谓的“第五元素”，他认为日月星辰围绕着地球运转，但其组成却不同与地上的四大元素水火气土。天上的事物应该是完美无缺的，它们只能由一种更为纯洁的元素所构成—以太。 未完待续。。。","categories":[{"name":"日常阅读","slug":"日常阅读","permalink":"https://aaronyard.github.io/categories/%E6%97%A5%E5%B8%B8%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"量子物理史话","slug":"量子物理史话","permalink":"https://aaronyard.github.io/tags/%E9%87%8F%E5%AD%90%E7%89%A9%E7%90%86%E5%8F%B2%E8%AF%9D/"}]},{"title":"3D游戏引擎初探（三）","slug":"3D-Engine-3","date":"2019-11-28T14:11:31.000Z","updated":"2019-11-28T14:14:25.908Z","comments":true,"path":"2019/11/28/3D-Engine-3/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/3D-Engine-3/","excerpt":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。","text":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。 向量的加法在最开始学向量的时候大家已经知道，向量的加法遵循三角形法则和平行四边形法则，在构建游戏世界的过程中用到了向量加法的几何意义。比如游戏中怪物追击玩家的AI中，怪物知道玩家的位置，需要时时刻刻朝向玩家移动，就会在每帧运用向量的加法向玩家移动。 向量的减法向量的减法作为加法的你逆运算，集合意义也是可以用在方向的计算上，另外它还能判断两个物体之间的距离。比如游戏中怪物的追击机制有一个判断条件，那就是距离玩家大于一定的距离后才会进行追击，小于一定距离之后就不再朝向玩家移动，这是就用到了向量的减法。 向量的点乘点乘主要用在了角度的计算和材质的渲染， 判断目标在自己的前后方位 。还是以怪物追击玩家为例子，刚刚只说了追击过程中的位置移动，但是怪物和玩家都是有正面朝向的，不然玩家看到怪物背对着玩家人物进行追击会觉得怪怪的，这时就需要怪物将自己的正面转向玩家。转的角度是多少呢？此时就需要用到向量的点乘进行计算了。 也能用来判断两个向量是否垂直、计算一个向量在另一个向量上的投影分量大小 。再说材质的光照渲染，通俗意义上讲就是光线照射后的明暗效果。现实世界中不规则的材质表面接受光线照射后是有不同的表现的，从数学的几何角度上来解释就是：在shader中，当材质表面的顶点法向量与光线向量的角度（即两个向量的点积）大于90度时就不接受光线的渲染，反之亦然。 向量的叉乘1、叉乘可以用来判断两个向量是否平行或相交。返回值为0，则平行。 2、用于求平面法线（叉乘的几何意义：absinθ） 3、计算两个物体之间形成四边形的面积（|a||b|sinθ） 4、 判断目标在自己的左右方位 关于向量的点乘和叉乘容易混淆的问题，可以这么理解： 点乘判断角度，叉乘判断方向。 向量的单位化向量的单位化计算的是物体间的距离，这个就不必多做介绍了。 矩阵未完待续。。。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（二）","slug":"3D-Engine-2","date":"2019-11-27T14:29:36.000Z","updated":"2019-11-27T14:47:21.966Z","comments":true,"path":"2019/11/27/3D-Engine-2/","link":"","permalink":"https://aaronyard.github.io/2019/11/27/3D-Engine-2/","excerpt":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。","text":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。 各层关系最底层的图形库接口关系到了整个游戏将可以在哪个平台下运行，GDI是专用于Windows平台的图形库，故而只适合在Windows中运行游戏。若想在其它平台中运行，则需要对底层的渲染模块的图形库接口做兼容。 中间层的3D游戏引擎和上层的游戏逻辑其实是相辅相成的，游戏引实质是从游戏逻辑中提取出来的共用的功能。比如unity3D、虚幻4引擎、第一家入职公司自主开发的小胖引擎等等，都是把游戏最基础的图形图像光照处理等游戏逻辑提取了出来，方便开发人员编写游戏时调用，不必在开发新游戏的前期大费周章的再次编写这些底层逻辑。从而把游戏开发的重点转移到了游戏逻辑上，大大提高的开发新游戏的效率，降低了开发新游戏所需要的周期。 由此来看，自主开发的引擎或者说开源的引擎有一个优点，在游戏逻辑开发的过程中如果发现有什么需要新加或者优化的逻辑，可以直接写在引擎中，提供给游戏逻辑层一个调用的接口即可。从根本上尽量避免代码重复，代码遵循统一的风格。所以可以说：游戏引擎为游戏逻辑的开发提供了方便，游戏逻辑的开发优化了游戏引擎的完整性。 所需条件开发一款游戏需要什么条件呢？一共有四条。 语言掌握一门主流的开发语言，本项目使用的是C++语言。 这里不得不说一下C++语言的优势了 1、 C++实现了面向对象程序设计。在高级语言当中，处理运行速度是最快的，大部分的游戏软件，系统都是由C++来编写的。 2、 C++语言非常灵活，功能非常强大。如果说C语言的优点是指针，那么C++的优点就是性能和类层次结构的设计。 3、C++非常严谨、精确和数理化，标准定义很细致。 4、 C++语言的语法思路层次分明、相呼应;语法结构是显式的、明确的。 当然，这只是C++的一部分优势，在运用过程中，我们会逐渐发现C++语言之美。 线性代数在开发引擎的过程中，数学同样很重要。线性代数在游戏的开发过程中可以灵活的解决3D固定流水线中的大部分操作，物体的移动。旋转、缩放、光照等都运用到了数学原理。 GPU编程语言3D游戏引擎的核心功能就是对游戏的场景渲染和物体的材质渲染，对材质中有Alpha通道的要做特殊处理（Alpha通道是材质有透明的部分）。移动端为了减少透明材质的消耗，会通过GPU编程在shader中处理，比如unity项目中一般会把有Alpha通道的图片切割为无Alpha通道和有Alpha通道的图片，通过shader编程将其再合在一起，还有场景渲染使用的后处理效果，模型的选中效果等，都是与GPU编程息息相关的，至少需要了解和使用GPU编程语言中的一种，目前有GLSL、HLSL、CG等。 图形学算法逼真的效果需要适合的图形学算法，比如水的波纹的模拟中用到的波动方程，刚体碰撞效果等，都会用到图形学算法。 先后顺序会从最基础最底层的知识开始学习了解： 数学知识游戏世界所运用到的线性代数的相关知识，领略数学之美。 材质和光照我们就是游戏中创造万物的造物主，首先创造什么？当然是光啦！ 固定流水线晶体管中的二进制数据是如何渲染到屏幕上供我们所观看呢？固定流水线会为你解密这一切。 游戏引擎架构将功能模块进行细分，分步实现，为下一步的整合做好前期准备。 3D游戏引擎的底层架构和封装用计算机语言实现每个功能模块，享受制作引擎工具的乐趣，这就是你手中的模板，用它就能创造一个又一个不同的游戏世界。 游戏逻辑引擎已经搭建完毕了，那么下一步就是进一步搭建可以与玩家互动的游戏世界啦。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（一）","slug":"3D-Engine-1","date":"2019-11-24T15:52:45.000Z","updated":"2019-11-27T14:47:36.167Z","comments":true,"path":"2019/11/24/3D-Engine-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/3D-Engine-1/","excerpt":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。","text":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。 本地化操作书籍中的编辑器是VS2013版，而我在学习的时候使用的是最新版的VS2019，跟着作者学习编写了所有代码，亲测可用，大家可以放心的编写学习啦。 材质地形编辑器书籍中对于材质地形编辑器的描述相当的少，我会在后期详细的描述材质地形是如何编辑的。 个人提升写本博客是必不可少的会重新过一遍书籍以及整合自身所学知识，算是对自己的再一次沉淀和查漏补缺。 收获对数据结构的理解上升了，图形学算法也有查找资料与编写demo的过程中有所了解和应用，学会了进行场景渲染以及物体的材质渲染，对于渲染管线以及传说中的shader不再陌生，也因此具备了宏观上的一些架构能力，对游戏的整体架构有了一定的认识。最重要的是也因此对我自身工作中所用的unity引擎有了更深层次的了解。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"博客建站","slug":"Hexo-blog","date":"2019-11-24T05:44:07.000Z","updated":"2019-11-24T11:20:46.195Z","comments":true,"path":"2019/11/24/Hexo-blog/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/Hexo-blog/","excerpt":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏","text":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏 准备工作 在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 配置好了相关的环境变量。 本文所使用的环境： Windows 10 node.js @12.13.1 Github Desktop @2.2.3 hexo @4.0.0 新建Github仓库在Github中新建一个名为 你的用户名.github.io 的仓库，例如你的GitHub用户名为example，则仓库名为 example.github.io ，这样，将来你的网站访问地址就是 http://example.github.io 了。 配置SSH keySSH key解决了本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git命令行。不要着急，按照如下指令做。 1$ ssh-keygen -t rsa -C \"Github注册邮箱\" 接着连续3次回车后，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的GitHub主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，title随意填写，将刚刚复制的内容粘贴到key中。 验证是否配置成功 1$ ssh -T git@github.com // 注意邮箱地址不用改 在弹出的 Are you sure you want to continue connecting (yes/no)? 后输入yes。 若显示 Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access. 则表明SSH配置成功。 接着输入如下指令 12$ git config --global user.name \"xxx\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@xxx.com\"// 填写你的github注册邮箱 如果遇到git非内外部指令的情况，则说明你没有为git配置环境变量，GitHub Destop的环境变量路径可参考： 1C:\\Users\\AaronEN\\AppData\\Local\\GitHubDesktop\\app-2.2.3\\resources\\app\\git\\cmd Hexo类型：静态网页 特点：速度快、部署简单、免费、结合github pages、支持markdown、内容布局自定义功能强. Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章！我的个人博客就是基于hexo生成的。很多网友对hexo的最深刻印象就是速度快和部署简单了。一个个人博客最核心的功能支持的非常好，你可以专心的写一些技术文章部署到上面了。 安装1$ npm install -g hexo 初始化找个目录存放你的项目代码，例如我的是 D:\\AaronYard 。 12$ cd /d/AaronYard/$ hexo init 初始化后的项目会自带一个主题，此时可以生成一个可以预览的网站。 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中输入 http://localhost:4000/，就可以浏览你的网站了。 主题当然啦，我们并不满足于官方提供的主题，此时就可以去寻觅自己喜欢的主题啦。 官方提供的主题网站：https://hexo.io/themes/ 我的网站的主题是hexo-theme-icarus 接下来就是下载主题的时刻啦！ 12$ cd /d/AaronYard/$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/hexo-theme-icarus 下载的主题会放在themes目录下，修改根目录下_config.yml中的theme: landscape改为theme: hexo-theme-icarus，然后重新执行hexo g来重新生成。 注意主题中的_config.yml也是需要修改的，对此有点基础的摸索片刻后就会修改了。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 提交GitHub在辛苦并快乐着的搭建工作之后，就可以愉快的将博客提交到GitHub中了。 配置根目录下_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:example/example.github.io.git branch: master 安装一个插件 1$ npm install hexo-deployer-git --save 提交本次改动的代码 1$ hexo d 至此，个人博客的框架搭建完成，还需要内容的扩充。 写博客定位到项目的根目录，输入命令 1$ hexo new \"hello-world\" hexo会帮我们在_posts目录下生成相关md文件md文件的目录结构一般如下 12345678---title: postName #文章页面上的显示名称，一般是中文date: 2019-11-24 13:44:07 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格---以下是正文 编写md文件后执行hexo g与hexo s即可浏览博客，若满意就可以hexo d愉快的提交博客啦。 写博客的工具关于写博客的工具，我用的是markdown editor，非常好用，左侧编写，右侧实时展现效果。编写的语法可参见hexo官方写作Wiki。 Hexo常用命令1234567891011121314151617hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本#缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy#组合命令hexo s -g #生成并本地预览hexo d -g #生成并上传 题外话我博客右下方有一只unitychan，很有趣吧，是基于live2d技术做的，感兴趣的可以点击此处学习搭建。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"博客建站","slug":"博客建站","permalink":"https://aaronyard.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"}]},{"title":"我的个人博客开通啦","slug":"MyHexo","date":"2019-11-23T14:44:14.000Z","updated":"2019-11-24T15:41:21.659Z","comments":true,"path":"2019/11/23/MyHexo/","link":"","permalink":"https://aaronyard.github.io/2019/11/23/MyHexo/","excerpt":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。","text":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。 关于我毕业于师范大学数学系，大学期间，我发现对于计算机的兴趣远大于数学带给我的快感，所以像老师申请了计算机实验室，在其中学习成长。在学院老师和同学的帮助下，我成立了团工委网络部，申请了微信公众号，从此开始了我的计算机探索之旅。 承蒙老师厚爱，我在北京实习参加工作，大三暑期开始在完美世界旗下子公司实习游戏客户端岗位，毕业后成功转正。因想稳定下来，目前回到家中，进入了另一家游戏公司继续成长。 三年的工作时间，令我从一个什么都不懂的毛头小子蜕变成了一个敢想敢干的小程序猿。为了弄明白3D游戏的原理，通过查资料以及实践，用C++编写了一个基于GDI的简易的完整3D引擎，并且为这个引擎写了一个游戏小demo，游戏成功运行的那一刻，我终于明白了什么是实践出真知。今天，这个小程序猿，又开始了想象之旅。 建站灵感 一开始没有想过要搭建一个网站啦，早上的时候看了知乎的一篇文章，里面介绍了一些让我很感兴趣的读物，我想从其中的一本书《上帝掷骰子吗？─量子物理史话》开始阅读，并且写下我的读书心得。 于是，我下载了这本书的电子版本当我阅读后想写读书心得时，突然意识到没有一个合适的网站供我书写。也许搭建一个个人博客是个不错的选择呢！毕竟我可以学习怎么搭建嘛，于是对互联网有一些了解的我，开始了漫长的建站之旅。 不断尝试通过对互联网服务器的一些了解，我将自己的笔记本当作服务器，运行了Tomcat，利用花生壳的内网穿透功能，捣鼓了一波家中的路由器，成功的在外网访问到了内网的网站。 但是这远远不够，我还需要一个适合我的网站管理系统，最终我找到了这个hexo，简直神器，完全不需要我进行内网穿透嘛！！而且基于git管理，网站管理方便，支持MarkDown编写，简直满足了我的一切需求。 今日心得新技能Get√ 终于把个人博客有模有样的捣鼓出来了，我可以在以后的日子里专心的写读书心得啦。","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://aaronyard.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"新技能Get√","slug":"新技能Get√","permalink":"https://aaronyard.github.io/tags/%E6%96%B0%E6%8A%80%E8%83%BDGet%E2%88%9A/"}]}]}
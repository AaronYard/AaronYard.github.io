{"meta":{"title":"汪震|个人博客","subtitle":"","description":"","author":"汪震","url":"https://aaronyard.github.io","root":"/"},"pages":[{"title":"Categories","date":"2019-11-23T07:33:54.918Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://aaronyard.github.io/categories/index.html","excerpt":"","text":""},{"title":"汪震","date":"2020-07-05T02:39:24.084Z","updated":"2020-07-05T02:39:24.084Z","comments":true,"path":"about/index.html","permalink":"https://aaronyard.github.io/about/index.html","excerpt":"","text":"欢迎您来到我的 个人博客！我将在这里分享我的个人心得、技术见解、学习历程，给自己一个沉淀的机会，也为大家分享一条前行的路。关于技术方面的问题，大家均可以分享探讨，我个人见解若有不足之处，也欢迎大家批评指正。 因某些原因，暂时没有办法建立一个属于自己的微信公众号，所以不能及时的发布最新的文章，会抓紧时间处理的。 关于我👱‍♂️汪震\\男\\1995 👨‍💻Github：https://github.com/AaronYard 📝目前为unity3D客户端，业余时间沉淀专研3D游戏引擎以及机器学习，目标是全栈。 请联系我📮邮箱：tomwang95@163.com 个人微信号：NOVAWZ"},{"title":"Tags","date":"2019-11-23T07:33:54.956Z","updated":"2018-05-01T16:28:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://aaronyard.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MMORPG手游项目优化分享总结","slug":"MMORPG","date":"2022-01-03T14:01:12.000Z","updated":"2022-01-04T14:55:36.208Z","comments":true,"path":"2022/01/03/MMORPG/","link":"","permalink":"https://aaronyard.github.io/2022/01/03/MMORPG/","excerpt":"最近为了全面提升沉淀自己的项目经验，以及想吸收其它优秀MMOPRG项目的技术，观看了一系列UWA讲座，大佬云集，技术以及思维的碰撞产生了大量的灵感，也促使我加深了对MMORPG游戏有了更深的理解，在此针对大世界MMO手游《剑侠世界3》优化分享的讲座进行总结。 讲座详细信息主办单位：UWA讲座：大世界MMO手游《剑侠世界3》优化分享主讲人：江志强 — 西山居《剑侠世界3》项目组 客户端主程如有侵犯，请联系我。","text":"最近为了全面提升沉淀自己的项目经验，以及想吸收其它优秀MMOPRG项目的技术，观看了一系列UWA讲座，大佬云集，技术以及思维的碰撞产生了大量的灵感，也促使我加深了对MMORPG游戏有了更深的理解，在此针对大世界MMO手游《剑侠世界3》优化分享的讲座进行总结。 讲座详细信息主办单位：UWA讲座：大世界MMO手游《剑侠世界3》优化分享主讲人：江志强 — 西山居《剑侠世界3》项目组 客户端主程如有侵犯，请联系我。 MMORPG手游现状大世界、实时天气、上天入地、捏脸易容、超远视距、布料模拟、大规模植被、多人群战、高精度渲染、适配机型广、体积渲染、内存占用小。 剑世3项目基础参数引擎：Unity 2019.4.x 源码编译管线：基于URP7.x改造发布平台：Android/iOS/Windows/Mac M1API:OPGLES3.0或以上，vukan版本制作种内存要求：2G或以上机型：OPPO A5/华为 mate 9/iPhone 6S/以上分辨率：移动端最高画质默认960p包体：首包1.4G，整包2.6G，后台边下边玩补充下载 1.场景相关一、场景相关优化1.场景静态处理2.场景流式加载机制3.取代LODGroup，独立LOD线程4.光照烘培&amp;TextureStreaming5.PVS遮挡剔除6.地形&amp;植被7.移动逻辑体素格子8.远景优化思路 场景基础数据（以主城-江南道场景为例）主体大小2K，外围远景4K总制作面数2000万面以上（3级LOD，不含植被Instanceing）4万个以上Render50万棵以上植被手机最高可视距离3.5公里以上模型Mesh制作3级LOD（按1/0.6/0.3面数比例制作） 1.场景静态处理分层分块分LOD相同材质静态合并Mesh相同层（远景/地形/植被/建筑框架/地砖/中景/近景/其它）相同区域（32*32米格子内，不同层的分块大小不一样）相同参数（是否参与烘培，是否投射阴影，是否接受阴影，相同材质，相同LOD数量）自动合并&amp;手动合并 不可见面剔除背面剔除（可移动区域外）地下剔除（地形以下）闭合模型重叠面剔除（石头堆叠） 带顶点动画物体合并质心坐标合并到UV3 合并后同步源参数Layer，Tag，ContriGI，LightmapScale，Shadow Caster…未参与合并的Renderer保持不变打组机制，A和B存在子集renderer被合并，那么要保持A，B同时显示或隐藏 导出Mesh/Prefab文件供后面使用—未完待续—","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"沉淀总结","slug":"沉淀总结","permalink":"https://aaronyard.github.io/tags/%E6%B2%89%E6%B7%80%E6%80%BB%E7%BB%93/"}]},{"title":"薄弱处总结","slug":"problem","date":"2021-12-19T14:01:12.000Z","updated":"2021-12-31T10:25:26.000Z","comments":true,"path":"2021/12/19/problem/","link":"","permalink":"https://aaronyard.github.io/2021/12/19/problem/","excerpt":"小阶段沉淀及总结近期发现了一些自己知识点的薄弱之处，利用加班的工作之余零碎的时间提升自己，顺便将其总结为本篇文章。（连续上半个月的班，每天还加班到深夜甚至凌晨，脑瓜子真的是嗡嗡的！！！） 大纲1.算法总结2.四叉树 （一）五大算法总结1）分治算法基本思想分而治之，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。","text":"小阶段沉淀及总结近期发现了一些自己知识点的薄弱之处，利用加班的工作之余零碎的时间提升自己，顺便将其总结为本篇文章。（连续上半个月的班，每天还加班到深夜甚至凌晨，脑瓜子真的是嗡嗡的！！！） 大纲1.算法总结2.四叉树 （一）五大算法总结1）分治算法基本思想分而治之，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 需要满足的条件①该问题缩小到一定程度就可以容易的解决。 ②该问题可以分解为若干规模较小的相同问题，即该问题具有最优子结构。 ③利用该问题分解出的子问题的解可以合并为该问题的解。 ④该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 因为问题的计算复杂性一般是随着问题规模的增加而增加，所以①是满足的。②是应用分治法的前提，也是递归思想的应用。是否应用分治法完全取决于③，若不满足该条件，则可以考虑用贪心法或动态规划法。④涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 基本的步骤step1分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； step2解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题； step3合并：将各个子问题的解合并为原问题的解。 思维过程（类似于数学归纳法）1、一定是先找到最小问题规模时的求解方法 2、然后考虑随着问题规模增大时的求解方法 3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。 2）动态规划基本思想其与分治法最大的差别：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况①最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 ②无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响，也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 ③有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 基本的步骤动态规划的设计都有着一定的模式，一般要经历以下几个步骤： 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态①划分阶段：按照问题的时间特征，把问题分为若干个阶段，在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 ②确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来，当然，状态的选择要满足无后效性。 ③确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 ④寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 思维过程一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程。实际应用中可以按以下几个简化的步骤进行设计：①分析最优解的性质，并刻画其结构特征。 ②递归的定义最优解。 ③以自底向上或自顶向下的记忆化方式（备忘录法 dptable）计算出最优值。 ④根据计算最优值时得到的信息，构造问题的最优解。 注意使用动态规划求解问题，最重要的就是确定动态规划三要素：①问题的阶段 ②每个阶段的状态 ③从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 3）贪心算法基本思想贪心算法不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（某个状态以后的过程不会影响以前的状态，只与当前状态有关。） 基本思路①建立数学模型来描述问题。 ②把求解的问题分成若干个子问题。 ③对每一子问题求解，得到子问题的局部最优解。 ④把子问题的解局部最优解合成原来解问题的一个解。 需要满足的条件局部最优策略能导致产生全局最优解。一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。 例题分析——背包问题有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 物品 A B C D E F G 重量 35 30 60 50 40 10 25 价值 10 40 30 50 35 40 30分析： 目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ （2）每次挑选所占重量最小的物品装入是否能得到最优解？ （3）每次选取单位重量价值最大的物品，成为解本题的策略。 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下： （1）贪心策略：选取价值最大者。反例： W=30 物品：A B C 重量：28 12 12 价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 （3）贪心策略：选取单位重量价值最大的物品。反例： W=30 物品：A B C 重量：28 20 10 价值：28 20 10根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 四）回溯法（DFS）基本思想在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。而满足回溯条件的某个状态的点称为“回溯点”。若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 基本思路①针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解； ②确定结点的扩展搜索规则； ③以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 基本框架设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。 非递归回溯框架12345678910111213141516171819202122232425262728 int a[n],i; 初始化数组a[]; i = 1; while (i&gt;0(有路可走) and (未达到目标)) // 还未回溯到头&#123; if(i &gt; n) // 搜索到叶结点 &#123; 搜索到一个解，输出； &#125; else // 处理第i个元素 &#123; a[i]第一个可能的值； while(a[i]在不满足约束条件且在搜索空间内) &#123; a[i]下一个可能的值； &#125; if(a[i]在搜索空间内) &#123; 标识占用的资源； i = i+1; // 扩展下一个结点 &#125; else &#123; 清理所占的状态空间； // 回溯 i = i –1; &#125; &#125;&#125; 递归的算法框架回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下： 12345678910111213141516171819int a[n]; try(int i)&#123; if(i&gt;n) 输出结果; else &#123; for(j = 下界; j &lt;= 上界; j=j+1) // 枚举i所有可能的路径 &#123; if(fun(j)) // 满足限界函数和约束条件 &#123; a[i] = j; ... // 其他操作,如回溯前的清理工作（如a[i]置空值等）; try(i+1); &#125; &#125; &#125;&#125; 五）分支限界法（BFS）基本思想在问题的解空间树T上搜索问题解的算法，分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 基本思路分支限界法的搜索策略：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。 回溯法和分支限界法的区别回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解。 分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解。 （二）四叉树四叉树及其变种常用在碰撞检测以及地图块加载的案例中。近期看了一个技术分享，一款MMO开放大世界的手游，在玩家跳转场景时，把跳转的时间压制在1秒，大大的减少了玩家等待的时间。他们是怎么做到的呢？首先是根据玩家身上的跨场景任务进行预加载，其次，他们把场景地图分为一个个的小块tile，通过四叉树，同步加载玩家坐标周边的地块以及NPC，异步加载场景中的其它物体。这样玩家的就不会长时间进行等待，而是一秒后便可以进入场景，游戏体验极好。 插入、更新、删除、查询的过程插入123插入一个物体，插入时分割空间直到能容纳改物体的最小空间，插入该物体到结点if 这个节点是能容纳该物体的最小节点，放入这个节点else 分割这个节点，找到合适的子节点执行插入操作 删除123找到该物体的所属的结点，删除该物体，如果结点不再包含物体并且不含有叶子节点，删除该节点获取给定物体在节点中的空间划分获取给定物体在当前节点的空间信息，即4象限信息 查询查询是否包含给定物体 更新123当物体的位置、大小发生变化，更新4叉树中该物体的信息一般是删除该物体后重新插入获取某节点下所有物体 单个空间节点为什么要设置成超过8个元素才往下继续划分空间？因为要平衡查询、与更新的性能 为什么要设置一个looseness松散值让空间节点之间有重合？因为要防止边缘元素频繁进更换空间节点，加大更新的性能消耗","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"沉淀总结","slug":"沉淀总结","permalink":"https://aaronyard.github.io/tags/%E6%B2%89%E6%B7%80%E6%80%BB%E7%BB%93/"}]},{"title":"LeetCode刷题（四）","slug":"LeetCode-4","date":"2021-05-30T15:02:26.000Z","updated":"2021-05-30T16:09:17.035Z","comments":true,"path":"2021/05/30/LeetCode-4/","link":"","permalink":"https://aaronyard.github.io/2021/05/30/LeetCode-4/","excerpt":"5. 最长回文子串（中等）给你一个字符串 s，找到 s 中最长的回文子串。 示例1：123输入：s = \"babad\"输出：\"bab\"解释：\"aba\" 同样是符合题意的答案。","text":"5. 最长回文子串（中等）给你一个字符串 s，找到 s 中最长的回文子串。 示例1：123输入：s = \"babad\"输出：\"bab\"解释：\"aba\" 同样是符合题意的答案。 示例2：12输入：s = \"cbbd\"输出：\"bb\" 示例3：12输入：s = \"a\"输出：\"a\" 示例4：12输入：s = \"ac\"输出：\"a\" 提示：121 &lt;= s.length &lt;= 1000s 仅由数字和英文字母（大写和/或小写）组成 方法一：动态规划通过12执行用时：880 ms, 在所有 C++ 提交中击败了19.07%的用户内存消耗：378.1 MB, 在所有 C++ 提交中击败了5.34%的用户 思路解析1对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if (n &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; n; i++) &#123; dp[i][i] = true; &#125; // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= n; L++) &#123; // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; n; i++) &#123; // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= n) &#123; break; &#125; if (s[i] != s[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substr(begin, maxLen); &#125;&#125;; 复杂度分析：时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。 空间复杂度：O(n^2)，即存储动态规划状态需要的空间。 方法二：中心扩展算法通过12执行用时：20 ms, 在所有 C++ 提交中击败了91.51%的用户内存消耗：6.8 MB, 在所有 C++ 提交中击败了99.04%的用户 思路解析12345所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1) 扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。 代码如下123456789101112131415161718192021222324252627class Solution &#123;public: pair&lt;int, int&gt; expandAroundCenter(const string&amp; s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return &#123;left + 1, right - 1&#125;; &#125; string longestPalindrome(string s) &#123; int start = 0, end = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; auto [left1, right1] = expandAroundCenter(s, i, i); auto [left2, right2] = expandAroundCenter(s, i, i + 1); if (right1 - left1 &gt; end - start) &#123; start = left1; end = right1; &#125; if (right2 - left2 &gt; end - start) &#123; start = left2; end = right2; &#125; &#125; return s.substr(start, end - start + 1); &#125;&#125;; 复杂度分析：时间复杂度：O(n^2)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 O(n) 次。 空间复杂度：O(1)。 方法三：Manacher 算法不做要求，具体的可以去官网上看。 思路来源1234作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int expand(const string&amp; s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return (right - left - 2) / 2; &#125; string longestPalindrome(string s) &#123; int start = 0, end = -1; string t = \"#\"; for (char c: s) &#123; t += c; t += '#'; &#125; t += '#'; s = t; vector&lt;int&gt; arm_len; int right = -1, j = -1; for (int i = 0; i &lt; s.size(); ++i) &#123; int cur_arm_len; if (right &gt;= i) &#123; int i_sym = j * 2 - i; int min_arm_len = min(arm_len[i_sym], right - i); cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len); &#125; else &#123; cur_arm_len = expand(s, i, i); &#125; arm_len.push_back(cur_arm_len); if (i + cur_arm_len &gt; right) &#123; j = i; right = i + cur_arm_len; &#125; if (cur_arm_len * 2 + 1 &gt; end - start) &#123; start = i - cur_arm_len; end = i + cur_arm_len; &#125; &#125; string ans; for (int i = start; i &lt;= end; ++i) &#123; if (s[i] != '#') &#123; ans += s[i]; &#125; &#125; return ans; &#125;&#125;; 复杂度分析：时间复杂度：O(n)，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n) 步，因此算法的复杂度为 O(n)。 空间复杂度：O(n)，我们需要 O(n) 的空间记录每个位置的臂长。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"随笔","slug":"Development2020To2021","date":"2021-05-29T15:35:14.000Z","updated":"2021-05-29T16:45:11.869Z","comments":true,"path":"2021/05/29/Development2020To2021/","link":"","permalink":"https://aaronyard.github.io/2021/05/29/Development2020To2021/","excerpt":"如今已经是2021年了，时光如梭，不禁想起前几天看到的一则新闻，老友记的演员们时隔十几年又聚到了一起。本来是件挺欢喜的事情，但是当我看到他们时，当年的花花公子乔伊如今已是头发花白，当年的冷笑话担当钱德勒也瘦成了一个小老头……十年老友记，时今老友人。当年都是风华正茂的一群人，没有生活大爆炸那样的高智商群体，有的只是如你我一般的普通人，会因为各种事情喜悦或忧愁，但是都能自我调节，或是有朋友的陪伴一路走过来。他们时一群有趣的人，我觉得他们这一辈子值了，有这样一群朋友，有自己的事业、家庭，经济财富也达到了常人难及的地步。 不禁反问自己，我需要做什么才会等到老了之后不后悔？小时候看着各种各样的海报和杂志，觉得长大之后有风花雪月、碧海蓝天、四处走走瞧瞧，这样的生活才是想要追求的。","text":"如今已经是2021年了，时光如梭，不禁想起前几天看到的一则新闻，老友记的演员们时隔十几年又聚到了一起。本来是件挺欢喜的事情，但是当我看到他们时，当年的花花公子乔伊如今已是头发花白，当年的冷笑话担当钱德勒也瘦成了一个小老头……十年老友记，时今老友人。当年都是风华正茂的一群人，没有生活大爆炸那样的高智商群体，有的只是如你我一般的普通人，会因为各种事情喜悦或忧愁，但是都能自我调节，或是有朋友的陪伴一路走过来。他们时一群有趣的人，我觉得他们这一辈子值了，有这样一群朋友，有自己的事业、家庭，经济财富也达到了常人难及的地步。 不禁反问自己，我需要做什么才会等到老了之后不后悔？小时候看着各种各样的海报和杂志，觉得长大之后有风花雪月、碧海蓝天、四处走走瞧瞧，这样的生活才是想要追求的。 越长大越觉得做什么事最重要的都是靠自己，父母会老，小时候父母会督促我做这做那，帮我们矫正错误的事情。但是父母也有他们的认知壁垒，他们只会在自己的认知里给予我一些有限的支持和引导，长大之后我才发现原来有些引导是不对的，这就需要我自己不停的学习和开阔视野，走出独属于自己的一条路。 从上个博客至今，除了日常上班，这段时间我做了什么呢？ 自律且努力坚持运动锻炼我做了一个减脂的食谱，在妈妈的帮助下，日复一日的吃着，戒糖戒辣，这一坚持就是大半年。光吃不运动怎么能行？我深知养成习惯的重要性，趁着晚上有时间，我就去楼下跳绳，跟着keep锻炼，再然后去健身房跟着健身教练练。每当我想放弃的时候，我就让自己再坚持坚持，想想当初为什么开始。就这样，一天两天、一周两周、一个月两个月，直到现在，我减掉了二十多斤。现在已是标准体重，体脂率也从23降到15…… 这段时间，我收获最大的就是自律，别人吃各种美食的时候我也馋，但是我知道我需要控制热量摄入，忍着不吃。这一忍就是大半年，我现在可以自信的说我对自己的身体负责了。 身为吃货，我连好吃的都可以坚持不吃，还有什么是坚持不下来的？ 读书百遍 其意自现一开始我也做了一个书单，但是渐渐的发现看书的速度太慢了，索性也就慢慢看，每天看一点，居然也把曼昆写的五百多页的微观经济学原理给啃完了。当看完的那一刻，我发现原来我行的，我可以！ 到现在为止，看完了微观经济学，游戏优化，正在啃产业区块链，只是为了拓宽视野，为将来储备知识。看书这个习惯我会一直持续下去，真挺好的，站在前人的肩膀上，才能站的更高，看的更远。 尤克里里和画画生活很多，但是我可以创造甜头。我有两大乐趣，音乐和绘画。 从小就是个音乐迷，听到音乐就会摇头晃脑的跟着哼，但是我只能满足于跟着哼吗？那必不能啊，所以我把尤克里里拾了起来，跟着视频弹唱，也挺有乐趣的，时常会高兴的手舞足蹈。 虽然我画画不怎么样，但是扛不住我喜欢啊！慢慢画，总有一天能画出来自己满意的图画，再者说了，未来做独立游戏说不定还需要自己画呢。 寻开心有时候周末在家实在坐不住呀，那就跟着同事们出去玩嘛，爬山，徒步，逛街，在这个城市长大的，但是一直都没有好好逛过这座城市，趁着这个机会好好逛逛，了解了解它。 未雨绸缪想做一个可以上架steam的独立游戏，已经构思了一阵，最近着手做了才发现还有很多没有考虑到的地方，但好歹也启动了，等将来某一天也许大家就能玩到。 大家要一起继续加油哦~放弃很容易 但坚持 一定很酷","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://aaronyard.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"Fighting","slug":"Fighting","permalink":"https://aaronyard.github.io/tags/Fighting/"}]},{"title":"自省和展望","slug":"ConclusionAndProspect","date":"2020-08-17T14:40:27.000Z","updated":"2020-08-17T23:54:14.978Z","comments":true,"path":"2020/08/17/ConclusionAndProspect/","link":"","permalink":"https://aaronyard.github.io/2020/08/17/ConclusionAndProspect/","excerpt":"算法题链表的存储反转定义一个方法（函数），实现输入一个链表的头结点，然后可以反转这个链表的方向，并输出反转之后的链表的头结点。 链表结点的结构：1234typedef struct Node&#123; int data; Node *next;&#125; Node, *List; 两种方法：遍历法、递归法","text":"算法题链表的存储反转定义一个方法（函数），实现输入一个链表的头结点，然后可以反转这个链表的方向，并输出反转之后的链表的头结点。 链表结点的结构：1234typedef struct Node&#123; int data; Node *next;&#125; Node, *List; 两种方法：遍历法、递归法 遍历法主要包括如下4步：1）如果head为空，或者只有head这一个节点，return head即可； 2）从头到尾遍历链表，把reversedHead赋值给当前节点的next； 3）当前节点赋值给reversedHead； 4）遍历结束，return reversedHead。 12345678910111213141516Node* reverseList(Node* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node* reversedHead = NULL; Node* p = head; while(p != NULL) &#123; Node* q = p; q-&gt;next = reversedHead; reversedHead = q; p = p-&gt;next; &#125; return reversedHead;&#125; 递归法：递归的实现方式主要有4步：1）如果head为空，或者只有head这一个节点，return head即可； 2）先遍历head-&gt;next为首的链表，得到一个头结点newHead； 3）把head赋值给head-&gt;next-&gt;next， head-&gt;next为空； 4）返回newHead。 12345678910node* reverseList2(node* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; node* newHead = reversedList2(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newHead;&#125; 开放题高楼扔鸡蛋https://www.pianshen.com/article/5717909966/","categories":[{"name":"自我提升","slug":"自我提升","permalink":"https://aaronyard.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"个人发展","slug":"个人发展","permalink":"https://aaronyard.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"}]},{"title":"LeetCode刷题（三）","slug":"LeetCode-3","date":"2020-07-08T15:23:31.000Z","updated":"2020-07-08T16:16:31.458Z","comments":true,"path":"2020/07/08/LeetCode-3/","link":"","permalink":"https://aaronyard.github.io/2020/07/08/LeetCode-3/","excerpt":"4. 寻找两个正序数组的中位数（困难）给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：123nums1 = [1, 3]nums2 = [2]则中位数是 2.0","text":"4. 寻找两个正序数组的中位数（困难）给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例2：123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 示例3：123nums1 = []nums2 = [1]则中位数是 1.0 示例4：123nums1 = []nums2 = [1,2]则中位数是 1.5 类似递归的二分法（java）通过12执行用时：3 ms, 在所有 java 提交中击败了60.78%的用户内存消耗：41 MB, 在所有 java 提交中击败了100.00%的用户 思路解析1利用了类似递归的方法 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int leftLength = nums1.length; int rightLength = nums2.length; // 为了保证第一个数组比第二个数组小(或者相等) if (leftLength &gt; rightLength) &#123; return findMedianSortedArrays(nums2, nums1); &#125; // 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2; // 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果 // 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数 //的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素 int totalLeft = (leftLength + rightLength + 1) / 2; // 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线， // 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i] int left = 0; int right = leftLength; // nums1[i - 1] &lt;= nums2[j] // 此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值 // nums2[j - 1] &lt;= nums1[i] // 此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值 // 循环条件结束的条件为指针重合，即分割线已找到 while (left &lt; right) &#123; // 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置 // 此处+1首先是为了不出现死循环，即left永远小于right的情况 // left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right // 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界（此处 +1 是首先为了避免出现死循环，同时 +1 以后，还不会出现下标越界的情况），因为+1之后向上取整，保证了 // i不会取到0值，即i-1不会小于0 // 此时i也代表着在一个数组中左边的元素的个数 int i = left + (right - left + 1) / 2; // 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和 // 此时j就是第二个元素中左边的元素的个数 int j = totalLeft - i; // 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值 // 说明又指针应该左移，即-1 if (nums1[i - 1] &gt; nums2[j]) &#123; // 下一轮搜索的区间 [left, i - 1] right = i - 1; // 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义 &#125; else &#123; // 下一轮搜索的区间 [i, right] left = i; &#125; &#125; // 退出循环时left一定等于right，所以此时等于left和right都可以 // 为什么left一定不会大于right?因为left=i。 // 此时i代表分割线在第一个数组中所在的位置 // nums1[i]为第一个数组中分割线右边的第一个值 // nums[i-1]即第一个数组中分割线左边的第一个值 int i = left; // 此时j代表分割线在第二个数组中的位置 // nums2[j]为第一个数组中分割线右边的第一个值 // nums2[j-1]即第一个数组中分割线左边的第一个值 int j = totalLeft - i; // 当i=0时，说明第一个数组分割线左边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1]; // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums1RightMin = i == leftLength ? Integer.MAX_VALUE : nums1[i]; // 当j=0时，说明第二个数组分割线左边没有值，为了不影响 // nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax) // 的判断，所以将它设置为int的最小值 int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1]; // 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响 // nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin) // 的判断，所以将它设置为int的最大值 int nums2RightMin = j == rightLength ? Integer.MAX_VALUE : nums2[j]; // 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可 if (((leftLength + rightLength) % 2) == 1) &#123; return Math.max(nums1LeftMax, nums2LeftMax); &#125; else &#123; // 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一 // 此处不能被向下取整，所以要强制转换为double类型 return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2; &#125; &#125;&#125; 复杂度分析：时间复杂度O(log(m+n))，空间复杂度O(1)。 建议先看懂上题的注解。 官方解法出处：123作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/来源：力扣（LeetCode） 方法一：二分查找（C++）通过12执行用时：16 ms, 在所有 C++ 提交中击败了84.80%的用户内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123456789主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较这里的 \"/\" 表示整除nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个这样 pivot 本身最大也只能是第 k-1 小的元素如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) &#123; /* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较 * 这里的 \"/\" 表示整除 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个 * 这样 pivot 本身最大也只能是第 k-1 小的元素 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组 * 由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 */ int m = nums1.size(); int n = nums2.size(); int index1 = 0, index2 = 0; while (true) &#123; // 边界情况 if (index1 == m) &#123; return nums2[index2 + k - 1]; &#125; if (index2 == n) &#123; return nums1[index1 + k - 1]; &#125; if (k == 1) &#123; return min(nums1[index1], nums2[index2]); &#125; // 正常情况 int newIndex1 = min(index1 + k / 2 - 1, m - 1); int newIndex2 = min(index2 + k / 2 - 1, n - 1); int pivot1 = nums1[newIndex1]; int pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) &#123; k -= newIndex1 - index1 + 1; index1 = newIndex1 + 1; &#125; else &#123; k -= newIndex2 - index2 + 1; index2 = newIndex2 + 1; &#125; &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if (totalLength % 2 == 1) &#123; return getKthElement(nums1, nums2, (totalLength + 1) / 2); &#125; else &#123; return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0; &#125;&#125;int main()&#123; vector&lt;int&gt; nums1 = &#123;1,3&#125;; vector&lt;int&gt; nums2 = &#123;2&#125;; double myanswer = findMedianSortedArrays(nums1,nums2); cout &lt;&lt; myanswer &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。 空间复杂度：O(1)。 方法二：划分数组（C++）通过12执行用时：24 ms, 在所有 C++ 提交中击败了35.62%的用户内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。当一个数组不出现在前一部分时，对应的值为负无穷，就不会对前一部分的最大值产生影响；当一个数组不出现在后一部分时，对应的值为正无穷，就不会对后一部分的最小值产生影响。 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if (nums1.size() &gt; nums2.size()) &#123; return findMedianSortedArrays(nums2, nums1); &#125; int m = nums1.size(); int n = nums2.size(); int left = 0, right = m, ansi = -1; // median1：前一部分的最大值 // median2：后一部分的最小值 int median1 = 0, median2 = 0; while (left &lt;= right) &#123; // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] int i = (left + right) / 2; int j = (m + n + 1) / 2 - i; // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j] int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]); int nums_i = (i == m ? INT_MAX : nums1[i]); int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]); int nums_j = (j == n ? INT_MAX : nums2[j]); if (nums_im1 &lt;= nums_j) &#123; ansi = i; median1 = max(nums_im1, nums_jm1); median2 = min(nums_i, nums_j); left = i + 1; &#125; else &#123; right = i - 1; &#125; &#125; return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;&#125;int main()&#123; vector&lt;int&gt; nums1 = &#123;1,3&#125;; vector&lt;int&gt; nums2 = &#123;2&#125;; double myanswer = findMedianSortedArrays(nums1,nums2); cout &lt;&lt; myanswer &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度：O(log min(m,n)))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。查找的区间是 [0,m]，而该区间的长度在每次循环之后都会减少为原来的一半。所以，只需要执行 log m 次循环。由于每次循环中的操作次数是常数，所以时间复杂度为 O(log m)。由于我们可能需要交换 nums1 和 nums2 使得 m≤n，因此时间复杂度是 O(log min(m,n)))。 空间复杂度：O(1)。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"LeetCode刷题（二）","slug":"LeetCode-2","date":"2020-07-07T15:39:12.000Z","updated":"2020-07-07T16:20:22.422Z","comments":true,"path":"2020/07/07/LeetCode-2/","link":"","permalink":"https://aaronyard.github.io/2020/07/07/LeetCode-2/","excerpt":"3. 无重复字符的最长子串（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1：123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。","text":"3. 无重复字符的最长子串（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1：123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例2：123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例3：1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 解法一：滑动窗口通过12执行用时：20 ms, 在所有 C++ 提交中击败了71.14%的用户内存消耗：7 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析123456设立左指针a和右指针bb指针向右侧伸缩｛ 对每个A[b]判断是否在之前的数组出现过； 如果出现，指针a指向出现过的位置的下一个位置； 更新右指针和最大长度；｝ 代码如下123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; int start(0), end(0), length(0), result(0); int size = s.size(); while (end &lt; size) &#123; char end_word = s[end]; for (int i = start; i &lt; end; i++) &#123; if (s[i] == end_word) &#123; start = i + 1; length = end - start; break; &#125; &#125; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n^2)，空间复杂度O(1)。 解法二：hashmap优化时间注：map的key存字符，但是value不存什么0或1了。直接存当前的有序下标，解决了多个字母出现的问题。 通过12执行用时：36 ms, 在所有 C++ 提交中击败了60.40%的用户内存消耗：8.7 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析1判断是否出现过时，利用hashmap优化时间。 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); unordered_map&lt;char, int&gt; hash; while (end &lt; sSize) &#123; char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (hash.find(tmpChar) != hash.end() &amp;&amp; hash[tmpChar] &gt;= start) &#123; start = hash[tmpChar] + 1; length = end - start; &#125; hash[tmpChar] = end; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n)，空间复杂度O(n)。 解法三：利用数组（桶）代替hashmap通过12执行用时：4 ms, 在所有 C++ 提交中击败了99.09%的用户内存消耗：7.9 MB, 在所有 C++ 提交中击败了100.00%的用户 思路解析1判断是否出现过时，利用桶来代替hashmap优化时间。 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;int lengthOfLongestSubstring(string s)&#123; //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); vector&lt;int&gt; vec(128, -1); while (end &lt; sSize) &#123; char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (vec[int(tmpChar)] &gt;= start) &#123; start = vec[int(tmpChar)] + 1; length = end - start; &#125; vec[int(tmpChar)] = end; end++; length++; result = length &gt; result ? length : result; &#125; return result;&#125;int main()&#123; string input = \"abcabcbb\"; int Maxlength = lengthOfLongestSubstring(input); cout &lt;&lt; Maxlength &lt;&lt; endl; return 0;&#125; 复杂度分析：时间复杂度O(n)，空间复杂度O(n)。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"LeetCode刷题（一）","slug":"LeetCode-1","date":"2020-07-06T14:58:26.000Z","updated":"2020-07-06T15:52:22.914Z","comments":true,"path":"2020/07/06/LeetCode-1/","link":"","permalink":"https://aaronyard.github.io/2020/07/06/LeetCode-1/","excerpt":"1. 两数之和（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0, 1]","text":"1. 两数之和（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0, 1] 通过12执行用时：12 ms, 在所有 C++ 提交中击败了87.82 %的用户内存消耗：8.3 MB, 在所有 C++ 提交中击败了100.00 %的用户 代码如下1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m_hash; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (m_hash.count(nums[i]) != 0) &#123; result = &#123; i,m_hash[nums[i]] &#125;; return result; &#125; else &#123; m_hash[target - nums[i]] = i; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; a = &#123; 11,2,15,7 &#125;; vector&lt;int&gt; b = twoSum(a, 9); cout &lt;&lt; b[0] &lt;&lt; b[1] &lt;&lt; endl; return 0;&#125; 思路解析我们可以通过遍历一次哈希表完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 复杂度分析：– 时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 – 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 2. 两数相加（中等）给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码如下（解法一）通过12执行用时：36 ms, 在所有 C++ 提交中击败了55.53 %的用户内存消耗：9.3 MB, 在所有 C++ 提交中击败了100.00 %的用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int carry = 0;//进位 ListNode* result = new ListNode(0); result-&gt;next = new ListNode(0); ListNode* cur = result-&gt;next; while (l1 != NULL || l2 != NULL || carry) &#123; if (l1 == NULL)l1 = new ListNode(0); if (l2 == NULL)l2 = new ListNode(0); cur-&gt;val = (l1-&gt;val + l2-&gt;val+ carry) % 10; carry = (l1-&gt;val + l2-&gt;val + carry) / 10; l1 = l1-&gt;next; l2 = l2-&gt;next; if (l1 != NULL || l2 != NULL || carry) &#123; cur-&gt;next = new ListNode(0); cur = cur-&gt;next; &#125; &#125; return result-&gt;next;&#125;int main()&#123; ListNode* a1 = new ListNode(2); a1-&gt;next = new ListNode(4); a1-&gt;next-&gt;next = new ListNode(3); ListNode* a2 = new ListNode(5); a2-&gt;next = new ListNode(6); a2-&gt;next-&gt;next = new ListNode(4); ListNode* b = addTwoNumbers(a1,a2); return 0;&#125; 代码如下（解法二）通过12执行用时：24 ms, 在所有 C++ 提交中击败了97.43 %的用户内存消耗：8.6 MB, 在所有 C++ 提交中击败了100.00 %的用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* addTwoNumbers2(ListNode* l1, ListNode* l2) &#123; int c = 0, temp = 0; ListNode* t1 = l1, * t2 = l2; while (t1-&gt;next != NULL &amp;&amp; t2-&gt;next != NULL) &#123; temp = (t1-&gt;val + t2-&gt;val + c) / 10; t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % 10; c = temp; t1 = t1-&gt;next; t2 = t2-&gt;next; &#125; if (t1-&gt;next == NULL &amp;&amp; t2-&gt;next == NULL) &#123; temp = t1-&gt;val + t2-&gt;val + c; if (temp &gt; 9) t1-&gt;next = new ListNode(temp / 10); t1-&gt;val = temp % 10; &#125; else &#123; if (t1-&gt;next == NULL) t1-&gt;next = t2-&gt;next; temp = (t1-&gt;val + t2-&gt;val + c) / 10; t1-&gt;val = (t1-&gt;val + t2-&gt;val + c) % 10; c = temp; t1 = t1-&gt;next; while (c != 0 &amp;&amp; t1-&gt;next != NULL) &#123; temp = t1-&gt;val + c; t1-&gt;val = temp % 10; c = temp / 10; t1 = t1-&gt;next; &#125; if (c != 0) &#123; if (t1-&gt;val + c &gt; 9) t1-&gt;next = new ListNode(1); t1-&gt;val = (t1-&gt;val + c) % 10; &#125; &#125; return l1;&#125;int main()&#123; ListNode* a1 = new ListNode(2); a1-&gt;next = new ListNode(4); a1-&gt;next-&gt;next = new ListNode(3); ListNode* a2 = new ListNode(5); a2-&gt;next = new ListNode(6); a2-&gt;next-&gt;next = new ListNode(4); ListNode* b = addTwoNumbers(a1,a2); return 0;&#125; 思路解析就像在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 伪代码如下： 123456789101112- 将当前结点初始化为返回列表的哑结点。- 将进位 carry 初始化为 0。- 将 p 和 q 分别初始化为列表 l1 和 l2 的头部。- 遍历列表 l1 和 l2 直至到达它们的尾端。--- 将 xx 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。--- 将 yy 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。--- 设定 sum = x + y + carry。--- 更新进位的值，carry = sum / 10。--- 创建一个数值为 (sum mod 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。--- 同时，将 pp 和 qq 前进到下一个结点。- 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。- 返回哑结点的下一个结点。 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 注意陷阱：若只考虑三位数相加，那么会出现val = (l1-&gt;val +l2-&gt;val) + carry / 10，但这样是错的，还要考虑5 + 5 = 10以及99 + 1 = 100等情况，则val = (l1-&gt;val +l2-&gt;val + carry) / 10才是对的。复杂度分析：– 时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n) 次。 – 空间复杂度：O(max(m, n))， 新列表的长度最多为 max(m,n)+1。","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"LeetCode刷题（简单版1）","slug":"LeetCodeEasy-1","date":"2020-06-22T15:55:28.000Z","updated":"2022-01-04T15:35:07.574Z","comments":true,"path":"2020/06/22/LeetCodeEasy-1/","link":"","permalink":"https://aaronyard.github.io/2020/06/22/LeetCodeEasy-1/","excerpt":"[7] 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例一12输入：x = 123输出：321","text":"[7] 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例一12输入：x = 123输出：321 示例二12输入：x = -123输出：-321 示例三12输入：x = 120输出：21 示例四12输入：x = 0输出：0 提示1-231 &lt;= x &lt;= 231 - 1 通过12Your runtime beats 49.05 % of cpp submissionsYour memory usage beats 27.97 % of cpp submissions (5.9 MB) 代码如下12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int reverse(int x) &#123; /* * 错误答案 * 案例： * Testcase * 1534236469 * Expected Answer * 0 * 分析：事先乘10导致数值溢出，以后需要多加注意！ * if(x == 0) return 0; * bool ispositive = true; * if(x&lt;0)&#123; * ispositive = false; * x = -x; * &#125; * int anw = 0;//最终答案 * while(x &gt; 0)&#123; * anw = anw * 10 + x%10; * x = (x - x%10)/10; * &#125; * if(ispositive == false) return -anw; * return anw; */ //Your runtime beats 49.05 % of cpp submissions //Your memory usage beats 27.97 % of cpp submissions (5.9 MB) int rev = 0; while (x != 0) &#123; if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123; return 0; &#125; int digit = x % 10; x /= 10; rev = rev * 10 + digit; &#125; return rev; &#125;&#125;;","categories":[{"name":"算法提升","slug":"算法提升","permalink":"https://aaronyard.github.io/categories/%E7%AE%97%E6%B3%95%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://aaronyard.github.io/tags/LeetCode/"}]},{"title":"游戏项目中的AI","slug":"GameAI","date":"2020-04-13T04:52:53.000Z","updated":"2020-07-05T02:47:53.270Z","comments":true,"path":"2020/04/13/GameAI/","link":"","permalink":"https://aaronyard.github.io/2020/04/13/GameAI/","excerpt":"项目中的AI前言在游戏开发中实现怪物AI逻辑的主要技术有两种：1、状态机 2、行为树。他们两者的实现机制不一样，其中状态机是“事件”机制，行为树是“轮询”机制。在项目开发中可以根据具体情况合理的选择两者来处理AI编写问题。 接下来将分两个部分对游戏中的AI进行讲解，1、状态机，2、行为树。 概述开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。 知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。","text":"项目中的AI前言在游戏开发中实现怪物AI逻辑的主要技术有两种：1、状态机 2、行为树。他们两者的实现机制不一样，其中状态机是“事件”机制，行为树是“轮询”机制。在项目开发中可以根据具体情况合理的选择两者来处理AI编写问题。 接下来将分两个部分对游戏中的AI进行讲解，1、状态机，2、行为树。 概述开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。 知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。 在行为系统中，有限状态机（FSM，Finite State Machine）最为经典，FSM模型的优势之一是简单。但是FSMs需要用转换（Transition）连接状态（State），因此，状态（State）失去了模块性（Modularity）。 行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构： 对于FSM，每个节点表示一个状态，而对于BT，每个节点表示一个行为。同样是由节点连接而成，BT有什么优势呢？ 在BT中，节点是有层次（Hierarchical）的，子节点由其父节点来控制。每个节点的执行都有一个结果（成功Success，失败Failure或运行Running），该节点的执行结果都由其父节点来管理，从而决定接下来做什么，父节点的类型决定了不同的控制类型。节点不需要维护向其他节点的转换，节点的模块性（Modularity）被大大增强了。实际上，在BT里，由于节点不再有转换，它们不再是状态（State），而是行为（Behavior）。 第一种-有限状态机1、有限状态机（FSM）的实现方式有三种： 面向过程的方式的if else用枚举配合switch case语句。用多态与虚函数（也就是状态模式） 2、状态模式的经典定义：允许对象在当内部状态改变是改变其行为，就好像对象改变了自己的类一样。 3、状态模式的实现分为三个要点： 为状态定义一个接口 为每个状态定义一个类 恰当地进行状态委托 4、通常来说，状态模式中状态对象的存放有两种实现存放思路: 静态状态。初始化时把所有可能的状态都new好，状态切换时通过赋值改变当前的状态实例化状态。每次切换状态时动态new出新的状态。 关于FSM的具体案例如下： 1、Unity的Mecanim动画系统就是通过状态模式来实现的 2、一个简单的战斗过程的状态机，如果用状态模式实现他的攻击逻辑就非常的方便，而且支持后期状态的扩展。 总结：状态模式暂时没有找到好的开源框架，但是状态模式不仅仅在AI方面使用，在游戏的框架中也被广泛使用，比如：UI框架，游戏主逻辑状态框架等等。 第二种-行为树什么是行为树如果了解过状态机，会知道在行为树之前，在实现AI用得比较多的技术是状态机，状态机理解起来是比较简单的，即一个状态过渡到另一个状态，通过判断将角色的状态改变即可，如果学习过Unity的Mecanim动画系统，会更加直观的理解。但是状态机在状态较多的情况下会使状态之间的切换变得异常繁琐，同时状态之间很难复用。在这种情况下，行为树被发明出来，行为树的优点如下： 1、行为树提供大量的流程控制方法，使得状态之间的改变更加直观； 2、整个游戏AI使用树型结构，方便查看与编辑； 3、方便调试和代码编写； 4、更好的封装性和模块性，让游戏逻辑更直观，开发者不会被那些复杂的连线绕晕。 5、最重要的：行为树方便制作编辑器，可以交由策划人员使用； 行为树的基本概念：1、执行每个节点都会有一个结果（成功，失败或运行） 2、子节点的执行结果由其父节点控制和管理 3、返回运行结果的节点被视作处于运行状态，处于运行状态的节点将被持续执行一直到其返回结束（成功或失败）。在其结束前，其父节点不会把控制转移到后续节点。 行为树原理行为树是一种树形结构，所以其可以分成3种节点类型： 1、红色的节点：根节点，没有父节点的节点； 2、蓝色的节点：组合节点，有父节点和子节点的节点； 3、白色的节点：叶节点，没有子节点的节点； 节点的返回每个节点都会有一个返回值，可能出现的返回值有3个，如下： 1、运行中：表示当前节点还在运行中，下一次调用行为树时任然运行当前节点； 2、失败：表示当前节点运行失败； 3、成功：表示当前节点运行成功； 下面我们来细说一下这几个节点： 根节点行为树的入口节点，可以是任意类型的节点； 组合节点行为树的组合节点是由下面几种类型来组成的： 1、选择节点/优先选择节点（Selector）该节点会从左到右的依次执行其子节点，只要子节点返回“失败”，就继续执行后面的节点，直到有一个节点返回“运行中”或“成功”时，会停止后续节点的运行，并且向父节点返回“运行中”或“成功”，如果所有子节点都返回“失败”则向父节点返回“失败”。 2、随机选择节点（Random Selector）之前的选择节点是有优先级顺序的，而随机选择节点的执行顺序是随机的。但每个节点只会执行一次，比如包含子节点：A、B、C、D、E；使用随机选择节点，执行顺序可能是：D、E、A、C、B或其他组合。其它规则同选择节点一致。 3、顺序节点（Sequence）该节点会从左到右的依次执行其子节点，只要子节点返回“成功”，就继续执行后面的节点，直到有一个节点返回“运行中”或“失败”时，会停止后续节点的运行，并且向父节点返回“运行中”或“失败”，如果所有子节点都返回“成功”则向父节点返回“成功”。 4、修饰节点（Decorator）修饰节点只包含一个子节点，用来以某种方式来改变这个子节点的行为。修饰节点的类型比较多，这里我们说一些比较常见的修饰节点： ① Until Success和Until Failure 循环执行子节点，直到返回“成功”或“失败”为止。 比如Until Success在子节点返回“运行中”和“失败”时都会向父节点返回“运行中”，返回“成功”时向父节点返回“成功”。 Until Failure在子节点返回“运行中”和“成功”时都会向父节点返回“运行中”，返回“失败”时向父节点返回“成功”。 ② Limit 执行子节点一定次数后强制返回“失败”。当子节点运行指定次数后还没有返回“失败”则该节点向父节点返回失败。 ③ Timer 子节点不会立即执行，而会在指定的时间到达后才开始执行。 ④ TimeLimit 指定子节点的最长运行时间，如果子节点在指定时间到达后还在运行则强制返回“失败”。 ⑤ Invert 对子节点的返回结果取“非”，即子节点返回“成功”则该节点返回“失败”，子节点返回“失败”则该节点返回成功。 5、并行节点（Parallel）不同于选择和顺序节点依次执行每个节点，并行节点是“同时”执行所有的节点，然后根据所有节点的返回值判断最终返回的结果。 这里的“同时”会迷惑住不少人，实际上，行为树是运行在单一线程上的，并不会在并行节点上开多个线程来进行真正的同时执行，那么“同时”的含义是什么？ 我们知道选择或顺序节点会依次执行所有的子节点，当子节点返回“成功”或“失败”后就会停止后续节点的执行，而并行节点也会依次执行所有的子节点，无论子节点返回“成功”或“失败”都会继续运行后续节点，保证所有子节点都得到运行后在根据每个子节点的返回值来确定最终的返回结果。 并行节点一般可以设定退出该节点的条件，比如： 1、当全部节点都返回成功时退出； 2、当某一个节点返回成功时退出； 3、当全部节点都返回成功或失败时退出； 4、当某一个节点返回成功或失败时退出； 5、当全部节点都返回失败时退出； 6、当某一个节点返回失败时退出； 叶节点1、条件节点（Condition）条件节点可以理解为一个if判断语句，当条件的测试结果为true时向父节点传递success，结果为false时向父节点传递failure； 该节点搭配一些组合节点可以完成各种判断跳转，比如搭配顺序节点，可以做出“是否看见敌人”-&gt;“向敌人开火”的AI； 2、行为节点（Action）行为节点用来完成具体的操作，比如，移动到目标点，执行开火等代码逻辑，多种情况下行为节点会返回running和success；行为节点也可能会使用多帧来完成； 子树的复用我们设计好的行为树可以在其他树中作为一颗子树来进行使用，最大可能的复用子树可以减少开发量。 总结：行为树的框架，网上有比较好的案例，如腾讯开源的behaviac。 Github地址：github.com/Tencent","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的事件系统","slug":"GameEventSys","date":"2020-04-11T13:52:53.000Z","updated":"2020-04-13T11:13:10.354Z","comments":true,"path":"2020/04/11/GameEventSys/","link":"","permalink":"https://aaronyard.github.io/2020/04/11/GameEventSys/","excerpt":"项目中的事件系统成熟的项目中对自己的事件都会进行封装，使得过程透明，使用者不必去了解其构成，只需要关心分发出来的事件，而事件的发出者也不关心谁会用到，只需要将事件发出即可。事件系统维系着项目中所有事件的分发，将游戏逻辑解耦，使得项目逻辑清晰，代码简单易懂。 通常事件系统并不复杂，反而很简单，包含了三个核心的方法： 注册 AddHander 注销 RemoveHander 发送 SendEvent","text":"项目中的事件系统成熟的项目中对自己的事件都会进行封装，使得过程透明，使用者不必去了解其构成，只需要关心分发出来的事件，而事件的发出者也不关心谁会用到，只需要将事件发出即可。事件系统维系着项目中所有事件的分发，将游戏逻辑解耦，使得项目逻辑清晰，代码简单易懂。 通常事件系统并不复杂，反而很简单，包含了三个核心的方法： 注册 AddHander 注销 RemoveHander 发送 SendEvent 使用枚举来作为事件类型 1public enum EEventType&#123;&#125; 事件是基于委托的，一个事件对应于多个委托delegate，利用委托的性质，事件系统将更加的简单明了。 1234//委托 事件的回调 对应于事件的数据结构public delegate void EventSysCallBack(EEventType eventId, object param1, object param2);public delegate void EventSysCallBack_(uint eventId, object param1, object param2);public delegate void EmptyCallBack(); 事件类的数据结构定义 1234567891011121314151617public class EventParamData&#123; private EEventType m_eventId = 0; private object m_param1 = null; private object m_param2 = null; public EventParamData(EEventType eventId, object param1, object param2) &#123; m_eventId = eventId; m_param1 = param1; m_param2 = param2; &#125; public EEventType GetEventId() &#123; return m_eventId; &#125; public object GetParam1() &#123; return m_param1; &#125; public object GetParam2() &#123; return m_param2; &#125;&#125; 接下来就是对于事件系统类EventSys的实现，整个系统继承于ISystem，ISystem继承于MonoBehaviour。 12345678910111213141516public class ISystem : MonoBehaviour&#123; public virtual void Init() &#123; &#125; public void BaseReset() &#123; Reset(); &#125; public virtual void Reset() &#123; &#125; public virtual void Release() &#123; &#125; public virtual void SysUpdate() &#123; &#125; public virtual void SysLateUpdate() &#123; &#125; public virtual void SysFixedUpdate() &#123; &#125; protected bool m_isControlUpdate = false; private int _m_randomNum = 0; public int m_randomNum &#123; get&#123; return _m_randomNum; &#125; set&#123; _m_randomNum = value; &#125; &#125; 在ISystem类中有两个虚方法需要在EventSys中实现，这两个虚方法分别是 12345//初始化方法public virtual void Init() &#123;&#125;//更新public virtual void SysUpdate() &#123;&#125; 事件系统中的事件是一个队列Queue，对列中存放的是一个EventParamData类型的数据，在每次执行SysUpdate的时候对队列中的所有元素执行出队操作，及时向其它系统发送事件，有新事件的时候执行入队操作，在注销事件时删除队列内相关的事件。为确保同一时间内能完整的运行完同一套事件，故而对事件加锁Lock，保证线程安全。 具体的代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class EventSys : ISystem&#123; private static String ms_lock = \"lock\"; private List&lt;EventSysCallBack&gt; m_allHander = new List&lt;EventSysCallBack&gt; (); private List&lt;EventSysCallBack&gt;[] m_eventArray = new List&lt;EventSysCallBack&gt;[(int)EEventType.Count]; private int m_eventNum = 0; private Queue m_eventQueue = new Queue(); public static EventSys Instance = null; private bool m_hasInit = false; public override void Init() &#123; if(m_hasInit) &#123; return; &#125; m_hasInit = true; m_eventQueue.Clear(); Instance = this; m_eventNum = (int)EEventType.Count; &#125; public override void SysUpdate() &#123; lock (ms_lock) &#123; while (m_eventQueue.Count &gt; 0) &#123; EventParamData data = m_eventQueue.Dequeue() as EventParamData; EEventType eventId = data.GetEventId(); SendEvent(eventId, data.GetParam1(), data.GetParam2()); &#125; &#125; &#125; public void AddAllHander(EventSysCallBack callBack) &#123; lock (ms_lock) &#123; m_allHander.Add (callBack); &#125; &#125; public void AddUintHander(uint eventid, object instance, EventSysCallBack_ callBack) &#123; AddHander((EEventType)eventid, (EEventType eventType, object param1, object param2) =&gt; &#123; callBack((uint)eventType, param1, param2); &#125;); &#125; public void AddHander(EEventType eventId, EventSysCallBack callBack) &#123; lock (ms_lock) &#123; if ((int)eventId &lt; m_eventNum) &#123; var eventList = m_eventArray[(int)eventId]; if (eventList != null) &#123; int count = eventList.Count; for (int i = 0; i &lt; count; i++) &#123; if(callBack == eventList[i]) &#123; return; &#125; &#125; eventList.Add(callBack); return; &#125; &#125; List&lt;EventSysCallBack&gt; t = new List&lt;EventSysCallBack&gt;(); t.Add(callBack); m_eventArray[(int)eventId] = t; &#125; &#125; public void RemoveHander(object target) &#123; lock (ms_lock) &#123; for (int i = m_eventNum - 1; i &gt;= 0; i--) &#123; var eventList = m_eventArray[i]; if (eventList != null) &#123; var eventCount = eventList.Count; for(int j = eventCount - 1; j &gt;= 0; j--) &#123; if(target == eventList[j].Target) &#123; eventList.RemoveAt(j); &#125; &#125; &#125; &#125; &#125; &#125; public void AddEvent(EEventType eventId, object param1=null, object param2=null) &#123; lock (ms_lock) &#123; m_eventQueue.Enqueue( new EventParamData(eventId, param1, param2 ) ); &#125; &#125; public void AddUintEvent(uint eventId, object param1 = null, object param2 = null) &#123; AddEvent((EEventType)eventId, param1, param2); &#125; //此函数只能在主线程调用 public void AddEventNow(EEventType eventId, object param1=null, object param2=null) &#123; SendEvent (eventId, param1, param2); &#125; public void AddUintEventNow(uint eventId, object param1 = null, object param2 = null) &#123; AddEventNow((EEventType)eventId, param1, param2); &#125; private void SendEvent(EEventType eventId, object param1, object param2) &#123; for(int i = 0; i &lt; m_allHander.Count; i++) &#123; try &#123; m_allHander[i](eventId, param1, param2); &#125; catch (Exception e) &#123; CNetSys.Instance.SendImportantLogWithBugly(true, \"[Exception]\" + e.ToString()); &#125; &#125; int targetIndex = (int)eventId; if(targetIndex &lt; m_eventNum) &#123; var eventList = m_eventArray[targetIndex]; if(eventList != null) &#123; int count = eventList.Count; for(int i = 0; i &lt; count; i++) &#123; try &#123; if(eventList != null &amp;&amp; i &lt; eventList.Count) &#123; eventList[i](eventId, param1, param2); &#125; &#125; catch (System.Exception e) &#123; CNetSys.Instance.SendImportantLogWithBugly(true, \"[Exception]\" + e.ToString()); &#125; &#125; &#125; &#125; &#125;&#125; 大致流程业务逻辑需要发事件时，调用AddEvent(…)接口，当下一帧到来，sysupdata(…)方法执行，事件被SendEvent(…)发送出去，设置了AddHander(…)的业务逻辑回调就会触发，进行相关的逻辑操作。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的全自动打包机制","slug":"AutomaticPackaging","date":"2020-04-06T07:27:18.000Z","updated":"2020-04-06T12:08:51.832Z","comments":true,"path":"2020/04/06/AutomaticPackaging/","link":"","permalink":"https://aaronyard.github.io/2020/04/06/AutomaticPackaging/","excerpt":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。","text":"项目中的全自动打包机制大部分成熟的线上项目，在项目成形期都会有一套完整的自动打包流程，用于解放人力（不用让所有人都了解打包机制，使打包过程透明）。 实际上，先后经历了多个线上项目，每个项目的自动打包流程其实大同小异。本质上都是通过jenkins运行带参的bat或者shell脚本来完成自动化打包流程的。 商业项目还会分渠道打包，打出相应的渠道包。在Assets文件夹外部创建一个文件夹来放所有需要对接的平台相关资源，各个平台资源对应着不同的目录。 由此，抽象出了一整套自动化打包流程。 前期准备工作1、各个渠道的sdk资源按渠道分类至各个渠道文件夹中，包括这个渠道打包所需要的【AndroidManife.xml、res、so、jar包、java代码】（Android）或【framework、.a文件、InfoPlisst、蕴含生命周期的UnityAppController.mm/AppDelegate.m文件】（ios）等资源文件。 2、一台单独打包机器（资金充足的话建议单独配打包机器），建议用MAC机，因为ios包只能用MAC机来打，而MAC机还能打安卓apk。 3、Jenkins，一个开源的可拓展的自动化服务器，关于Jenkins可以单独拿出来将一篇文章了，再此简单的说一下Jenkins的持续集成流程：提交代码–&gt;拉取代码–&gt;编译–&gt;打包–&gt;测试–&gt;反馈问题–&gt;开发处理–&gt;提交代码，从这一流程就可以窥探到Jenkins的便利。 4、打包所用的脚本：build.bat或者build.sh脚本。 5、unity项目代码中可供打包脚本调用的打包相关静态方法。 具体流程1、Jenkins中Build with Parameters里输入相应的打包参数，坐等打包完成，打包过程对你来说是透明的，完毕…哈哈，开个玩笑，接下用最通俗的语言带你揭秘打包流程。 2、全自动化打包流程最重要的在于打包脚本，接收到你的输入参数后开始工作，首先覆盖平台相关资源，其次拉取svn到指定版本，然后再将将指定平台写入代码中，最后关闭打包机上unity和资源管理器窗口。关闭unity尤为重要，不然unity会以进程被占用为由告诉你打包失败。 3、设置Unity宏定义，表明这个包是某个渠道的宏定义。 4、设置游戏版本号，便于后期维护发热更新。 5、构建游戏Aesstbundle资源：调用打包代码，构建资源输出到指定目录，将资源打成压缩包输出到resource目录下。 6、构建游戏安装包。 相关代码build.sh 123456789101112131415#!/bin/bash#define varUnityCmd=/Applications/Unity/Unity.app/Contents/MacOS/Unity CurrentPath=$(cd `(dirname $0)`; pwd)PROJECTHOME=$&#123;CurrentPath&#125;/../FUNCTION_NAME=\"\"BUILDHOME=\"\"APP_NAME=\"\"cmdBuildAB=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod BuildEditor.BuildAndroidAB\"$cmdBuildABcmd=\"$&#123;UnityCmd&#125; -quit -batchmode -projectPath $&#123;PROJECTHOME&#125; -executeMethod AutoBuild.$&#123;FUNCTION_NAME&#125; -outPath $&#123;BUILDHOME&#125;/$&#123;APP_NAME&#125; -logFile\"$cmd C#静态方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//打AssetBundle//state 0:apk 1: ios: 2: editor 3:iOS不压缩ab 4:不挪动UI 5:GOOGLE OBBpublic static void BuildAssetBundle(int state)&#123; DirectoryInfo direc = new DirectoryInfo(Application.streamingAssetsPath + \"/AssetsBundle\"); if (direc.Exists) &#123; direc.Delete(true); &#125; m_abDataLs.list.Clear(); m_options = BuildAssetBundleOptions.CollectDependencies; if(state == 0 || state == 10) &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; m_target = BuildTarget.Android; &#125; else &#123; m_options = BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.UncompressedAssetBundle; if(state == 1 || state == 3) &#123; m_target = BuildTarget.iPhone; &#125; else if(state == 2) &#123; m_target = BuildTarget.StandaloneWindows; &#125; &#125; if (state == 0 || state == 1) &#123; //移动打包资源 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); AutoBuild.MoveUIResToTemp(); &#125; if (state == 5) &#123; //移除一部分资源去打obb包 AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileNameObb, AutoBuild.DirecPrefabFileNameObb); &#125; if (state == 3 || state == 4) &#123; // 只移动Resource/Prefab AutoBuild.RemoveRessToTmp(AutoBuild.SourcePrefabFileName, AutoBuild.DirecPrefabFileName); &#125; //打AssetBundle BuildAB(state); if (state != 3) &#123; //压缩AssetBundle AssetBundleCompress(); &#125;&#125;//打apkpublic static void Build_Apk(int XXqudao)&#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, \"PLAT_SDK_XXqudao\"); PlayerSettings.bundleIdentifier = \"com.xxx.xxx.xxx\"; BuildAndroid(XXqudao);&#125;//移动相关的资源static void BuildAndroid(int XXqudao)&#123; //移动相关平台sdk资源文件夹 MovePluginDir(XXqudao); //替换一些DLL文件 ReplaceDll(\"Android\", \"DLL\"); //替换一些包体内需要用到的图片icon文件 ReplaceLoadingImage(XXqudao); //开始build BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions(); buildPlayerOptions.scenes = new[] &#123; \"Assets/Scene1.unity\", \"Assets/Scene2.unity\" &#125;; buildPlayerOptions.locationPathName = m_outPath; buildPlayerOptions.target = BuildTarget.Android; buildPlayerOptions.options = BuildOptions.None; BuildReport report = BuildPipeline.BuildPlayer(buildPlayerOptions); BuildSummary summary = report.summary; if (summary.result == BuildResult.Succeeded) &#123; Debug.Log(\"Build succeeded: \" + summary.totalSize + \" bytes\"); &#125; if (summary.result == BuildResult.Failed) &#123; Debug.Log(\"Build failed\"); &#125; //将editor使用的DLL恢复 RecoveryDll(\"DLL\"); //恢复sdk资源文件夹 RecoveryPluginDir();&#125; 写在最后这里只是提供一个大体的思路，实际上在自动化流程中还是有很多大大小小的坎坷的，比如一些已经成形的项目，其项目目录结构需要单独进行适配，一些渠道打包需要单独进行调整等，这些都是要考虑到的。 关于sdk：建议单独分出一个集成sdk的部门，用于将各个渠道的sdk集成到一个主的sdk上，游戏项目只需要接入一个sdk即可，使得sdk接入工作透明化，游戏开发人员专注于游戏业务逻辑的开发，更加高效。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"游戏项目中的小包更新机制","slug":"AssetsPackage","date":"2020-04-05T12:21:28.000Z","updated":"2020-04-07T04:21:52.782Z","comments":true,"path":"2020/04/05/AssetsPackage/","link":"","permalink":"https://aaronyard.github.io/2020/04/05/AssetsPackage/","excerpt":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考：","text":"项目中的小包更新机制大部分成熟的线上的MMORPG项目，其包括的特效、图集、预制等资源的体积大小必定是庞大臃肿的，这个在业界也是公认的。 如果有打过安卓谷歌包的，想必都清楚谷歌有一个明文规定，上传至谷歌开发者后台的包体大小不能大于100M。对于包体大小大于100M的项目，Google官方也提供了一个方案，Google官方提供了Jobb工具用来生成obb文件，工具可以在 Android\\sdk\\tools\\bin文件夹下找到，生成后于apk文件一起上传至开发者后台，待审核通过发布后供玩家下载。 另一方面，经过调查，国内玩家在下载游戏的时候更偏向于包体偏小的apk。这个时候，另辟蹊径的方案诞生了，以我经历的两款成熟的线上项目为案例，有两个方案供大家参考： 方案一没有一个官方的名字，姑且叫它强制小包法叭。 在打apk的时候，将游戏用到的代码、闪屏图、loading图、主场景、登录场景、表格、开场动画等最基本的资源提前准备好，在打包时替换进去，这样包体不会很大，玩家所需的拓展资源则通过项目里的热更新机制加载。 这个方法有一个缺点，由于包体内所携带的资源并不完整，只能保证游戏可以运行不会崩溃，更多的功能资源包则需要在登录游戏之前下载。若热更新较大则会“吓跑”一些新玩家（不成文规定：新发布游戏的热更新包体宜小于30M），为了减少这一影响，第二种补充方案应运而生了。 方案二游戏内小包资源法，作为方案一的补充，它对玩家更友好。 将项目内容分为必须功能和非必须功能，如玩家信息系统、公告系统、技能系统、排行榜系统、基本的新手任务系统以及主城场景等游戏正常运行所必须的或占资源不多的功能系统可以统一将预制图集资源打进包里。但是类似宠物系统、武将系统、野怪系统等占用较多预制资源分类打进AB小包中，用一个json文件来管理资源列表。 在loading主场景的时候，异步检测线上小包资源的json配置是否存在，若存在且为wifi环境则异步下载资源并解压预加载，主界面也会显示相应的窗口。若玩家当前网络环境不满足下载资源的要求，则会在非必须的功能入口处做出限制，告知需要加载资源包才能体验完整的游戏功能，并且会在加载完毕资源后给予一定的奖励。 这样玩家在初始阶段流失的相应较少，体验更佳，对玩家更为友好。 热更新机制热更新机制已经在另一篇文章中详细阐述了，再此就不重复介绍了。–&gt;热更新机制 游戏内小包资源法1、小包有对应的资源版本号，在游戏打包前设定相应的资源版本号，而在拉取小包资源的时候也是以资源版本号作为索引去寻找相应的json配置文件。 2、商业游戏最重要的是游戏安全，可以在写入json配置文件列表的脚本中加入相应的文件大小及MD5等信息作为校验，这样就不会轻易被第三方非法修改。 3、在小包解压时，有概率会出现一些文件解压失败，损失一部分资源，或者玩家不小心删掉了一些资源文件，这个时候在重新下载所有小包资源就不明智了。在游戏中给玩家提供一个主动校验资源的功能，根据现有资源文件名遍历json配置资源列表来寻找需要缺失的文件，异步下载并解压。 4、游戏内小包资源法与热更新机制在本质上是一样的，都是通过unity的AssetBundle加载机制来实现的。 小包资源的加载状态123456789101112public enum AssetsPackageState&#123; None,//初始状态，最初的未加载状态 ReadFileEnd,//读取完json配置文件 DownLoadStart,//开始下载josn文件列表中的小包资源文件 DownLoadStop,//暂停下载josn文件列表中的小包资源文件，并保存当前的下载进度 DownLoadComplete,//小包资源下载完成 DecompressStart,//小包资源开始解压 DecompresFail,//小包资源解压失败 AssetsReady,//资源校验已准备好 AssetsCheck,//资源校验中（成功时会通过回调告知玩家校验结果）&#125; 无感知下载小包资源在加载进入主主场景时，检测是否需要加载资源，根据网络环境并自动加载,代码流程大致如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//初始化检测功能public void CheckInitDownLoad()&#123; //不是初始化状态，说明进入主场景后已经检查过了，不必再走下面的逻辑 if (m_curAssetsPackageState != AssetsPackageState.None) &#123; return; &#125; if (IsAssetsPackageReady()) &#123; m_isDecompressSuc = true; m_isDownLoadSuc = true; m_curAssetsPackageState = AssetsPackageState.AssetsReady; &#125; else &#123; if (m_curAssetsPackageState == AssetsPackageState.None) &#123; LoginCheckDownLoadInfo(); &#125; &#125;&#125;// 资源包是否下载解压好public bool IsAssetsPackageReady()&#123; if(m_data.assetPackage != null) &#123; return m_data.assetPackage.isAssetsPackageReady; &#125; return false;&#125;//用于登录检查下载资源private void LoginCheckDownLoadInfo()&#123; //创建下载目录 m_availablePath = GetPathForPlatform(platform, TargetAssetsBundlPath); if (!Directory.Exists(m_availablePath)) &#123; Directory.CreateDirectory(m_availablePath); &#125; if (m_updateStruct == null) &#123; GetUpdateStructForSvr(InitUpateFileInfo); &#125; else &#123; InitUpateFileInfo(); &#125; &#125;//拉取下载文件清单信息private void GetUpdateStructForSvr(Action succCB = null)&#123; var url = \"....\";//json文件的url DownloadSmallFileTask(url, (string text) =&gt;//下载并解析json文件 &#123; m_updateStruct = JsonMapper.ToObject&lt;UpdateStruct&gt;(text);//将json数据转为C#结构 if (m_updateStruct != null) &#123; if (succCB != null) succCB(); &#125; &#125;); //succCB批次任务执行成功回调,failCB批次任务执行失败回调,netConnectCheckCB网络连接检查回调,tryTimeLimit任务失败后尝试次数上限,value=0默认没有上限，不为0时，超过上限后结束任务执行 StartDownloadSmallFile(succCB, failCB, netConnectCheckCB, tryTimeLimit);&#125;public class UpdateInfo&#123; public string name; public int size; public string md5; public int desize; public string demd5; public UpdateInfo() &#123; name = \"\"; size = 0; md5 = \"\"; desize = 0; demd5 = \"\"; &#125;&#125;//初始化更新文件信息private void InitUpateFileInfo()&#123; //遍历json中的下载信息，统计已下载，总下载，初始化需要下载文件列表 for (int i = 0; i &lt; m_updateInfo.Count; i++)//遍历json数据转换后的list &#123; var updateInfo = m_updateInfo[i]; InitFileReadTask(m_updateInfo[i], m_availablePath);//添加异步下载任务 m_needDeleteFileList.Add(m_availablePath + m_updateInfo[i].name); &#125;&#125;//初始化文件读取任务private void InitFileReadTask(UpdateInfo updateInfo, string path)&#123; string fileName = \"ABC.ab\"; string url = \"https://www.AAA.com/ABC.ab\"; string decompressFileName = \"abc\"; //下载文件读取 m_totalSize += updateInfo.size; AddReadFileTask(fileName, updateInfo.md5, updateInfo.size, //读取成功回调 () =&gt; &#123; m_curSize += updateInfo.size; &#125;, //读取失败回调 (TaskWorkStatus status) =&gt; &#123; AddDownloadBigFileTask(fileName, url, updateInfo.md5, updateInfo.size, () =&gt; &#123; m_childDownSize = 0; m_curSize += updateInfo.size; &#125;, (TaskWorkStatus downStatus) =&gt; &#123; m_childDownSize = 0; &#125;, (long curSize) =&gt; &#123; m_childDownSize = curSize; &#125; ); &#125; ); //解压后文件读取 var unDecompressFile = new CUnzipFile(fileName, decompressFileName, updateInfo.desize); m_totalDecompressSize += updateInfo.desize; AddReadFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;, (TaskWorkStatus status) =&gt; &#123; AddDecompressFileTask(decompressFileName, updateInfo.demd5, updateInfo.desize, unDecompressFile, () =&gt; &#123; m_curDecompressSize += updateInfo.desize; &#125;); &#125; );&#125;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"数据库面试指南","slug":"数据库/数据库面试指南","date":"2020-04-01T14:02:45.000Z","updated":"2020-09-04T15:50:20.428Z","comments":true,"path":"2020/04/01/数据库/数据库面试指南/","link":"","permalink":"https://aaronyard.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"一、数据库基础知识1. 为什么要使用数据库数据保存在内存 优点： 存取速度快 缺点： 数据不能永久保存","text":"一、数据库基础知识1. 为什么要使用数据库数据保存在内存 优点： 存取速度快 缺点： 数据不能永久保存 数据保存在文件 优点： 数据永久保存 缺点： 速度比内存操作慢，频繁的IO操作。 查询数据不方便 数据保存在数据库 数据永久保存 使用SQL语句，查询方便效率高。 管理数据方便 2. 数据库的三级模式结构 内模式：也称存储模式。数据物理结构和存储方式的描述，是数据在数据库中的组织方式 模式：也称逻辑模式。是数据库中全体数据成员的逻辑结构和特征的描述 外模式：也称用户模式。是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述 3. 什么是 SQL结构化查询语言(Structured Query Language) 简称 SQL，是一种数据库查询语言。 作用：用于存取数据、查询、更新和管理关系数据库系统。 4. 什么是MySQL?MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。 5. MySql 有哪些数据类型 varchar 和 char 的区别 CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR存储的内容超出设置的长度时，内容会被截断。 VARCHAR用于存储可变长字符串，它比定长类型更节省空间。VARCHAR存储的内容超出设置的长度时，内容同样会被截断。 对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。 对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。 6. 超键、候选键、主键、外键 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：即最小超键，即没有冗余元素的超键。候选键中的元素称为主属性 主键：候选键中选出一个作为主键，一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 7. 什么是数据字典数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典中的相应信息 8. 关系型数据库和非关系型数据库比较 ⭐关系型数据库： 采用了关系模型来组织数据的数据库，以行和列形式存储数据，以便于用户理解。 通用的 SQL 语言使得操作关系型数据库非常方便。 关系型数据库遵循 ACID 原则。 常见的关系型数据库比如 MySQL，Oracle 关系型数据库存在的问题： 网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘 I/O 是一个很大的瓶颈 网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。因此，关系型数据不适合持久存储海量数据 很难进行横向扩展（增加服务器），也就是说想要提高数据处理能力，要使用性能更好的计算机（纵向扩展） 性能欠佳：导致关系型数据库性能欠佳的最主要原因就是多表的关联查询，为了保证数据库的ACID特性，必须尽量按照范式要求设计数据库，关系数据库中的表存储的往往是一个固定的、格式化的数据结构 而非关系型数据库就可以很好的解决关系型数据库很难解决的大数据问题 非关系型数据库 NoSQL： 非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。 支持分布式存储，容易进行横向扩展 不遵循 ACID 特性（不提供对事务的处理） 常见的非关系型数据库比如 Redis、MongoDB、Elasticsearch 9. 数据库连接池① 概述数据库连接池是负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是每次访问数据库的时候都需要重新建立一次连接。 ② 为什么要使用连接池数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 ③ 传统的连接机制与连接池运行机制区别执行一个SQL命令 不使用数据库连接池的步骤： TCP建立连接三次握手 MySQL认证三次握手 真正的SQL执行 MySQL关闭 TCP四次握手关闭 可以看到，为了执行一条SQL，却多了非常多网络交互，应用需要频繁的创建连接和关闭连接。 使用数据库连接池的步骤： 第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。 二、关系数据库，SQL语句更多详见： 【二】关系数据库 【三】关系数据库标准语言SQL 1. SQL 语句主要分为哪几类 数据定义语言 DDL（Data Definition Language）：CREATE、DROP、ALTER，主要是对表结构、视图、索引等的操作 数据查询语言：DQL（Data Query Language）：SELECT 数据操纵语言：DML（Data Manipulation Language）：INSERT、DELETE、UPDATE 数据控制语言：DCL（Data Control Language）：GRANT、REVOKE、COMMIT、ROLLBACK 2. in 和 exists 的区别12345select id from Studentwhere id exists (select id from SC);select id from Stduentwhere id in (select id from SC); in 先进行子查询 select id from SC，再进行外查询 select id from Student exists 先执行外查询，再执行子查询 in 语句是把外表和内表作连接 而 exists 语句是对外表作循环，每次循环再对内表进行查询 exists 适合子查询的表比外查询大的查询语句 如果内表和外表差不多大，那么 in 和 exists 的效率差别不大 3. 多表连接的查询方式 内连接 inner join: 只连接匹配的行（默认） 左外连接 left outer join: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 右外连接 right outer join: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 全外连接 outer join: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 交叉连接 cross join: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 4. MySql 分页 limitLIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。 LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1) 1SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： 1SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. 如果只给定一个参数，它表示返回最大的记录行数目： 1SELECT * FROM table LIMIT 5; //检索前 5 个记录行 limit 和 offset 连用 1select * from table limit 2 offset 1; //跳过前面1条数据，检索2条数据 5. 什么是视图，视图的优缺点1234567# 建立计算机系学生视图，并要求插入/修改/删除操作时，保证该视图只有计算机系学生create view CS_Studentasselect *from Studentwhere Sdept = 'CS'with check option; 视图是从一个或几个基本表（或视图）导出的表。 它与基本表不同，是一个虚表。 数据库中只存放视图的定义，不存放视图对应的数据，这些数据任然存放在原来的基本表中。所以一旦基本表中的数据变化，那么视图中的数据也会相应变化。 其实视图就好像一个窗口，透过它可以看到自己想要看到的数据及其变化 视图的优点： 视图能够简化用户的操作 视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性 适当利用视图可以更清晰的表达查询 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定数据的逻辑独立性 数据的逻辑独立性是指当数据库数据库构造时，如增加新的关系或对原来关系增加新的字段等，用户的应用程序不会受到影响 视图的缺点： 查询视图时，必须把对视图的查询转化为对基本表的查询。如果这个视图是由一个复杂的多表查询所定义，那么即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。 当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改，如果视图涉及多个表的话，由于完整性约束，可能是无法修改的 三、数据库安全性和完整性1. 安全性和完整性的区别 ⭐数据库的安全性：保护数据库防止不合法使用造成的数据泄露、更改或破坏 数据库的完整性：防止数据库中存在不符合语义 / 不正确的数据信息 2. 数据库安全性控制机制 用户身份鉴别 存取控制 GRANT 授予权限 12345# 把查询Student表的权限授给用户User1，并允许他将此权限授予其他用户grant selecton table Studentto User1with grant option; REVOKE 收回权限 1234# 收回用户User1对Student表的查询权限，并级联收回User1授予的其他用户的该权限revoke selecton table Studentfrom User1 CASCADE; 视图机制 VIEW 审计 / 跟踪审查 AUDIT 设置审计功能 123# 对修改Student表结构和修改Student表数据的操作进行审计AUDIT alter,updateon Student; NOAUDIT 取消审计功能 123# 取消取Student 表的一切审计noaudit alter,updateon Student; 数据加密 3. 完整性约束 实体完整性约束 主键必须存在且不为空 1primary key (Sno,Cno) 参照完整性约束 外键要么不存在，要么存在且不为空 1foreign key(Sno) references Student(Sno) 用户自定义完整性约束 NOT NULL：字段的内容不能为空 UNIQUE：字段内容不能重复，一个表允许有多个 Unique 约束 PRIMARY KEY：主键 FOREIGN KEY：外键 CHECK：控制字段的取值范围 1Sex char(2) check(Sex in('男','女')), //性别属性只能取男或女 4. 触发器触发器是用户定义在关系表上的一类由事件驱动的特殊过程，可用于保证数据库的完整性。 触发器是指一段代码，当触发某个事件时，自动执行这些代码。 触发器仅限于数据库中增 删 改三种操作 在MySQL数据库中有如下六种触发器： Before Insert After Insert Before Update After Update Before Delete After Delete 触发器示例：cource表中删除一个元组，若该元组的主键是sc表中的外键，则卷回删除该元组的操作。 1234567CREATE TRIGGER mytrigger BEFORE DELETE ON cource referencing old as o for each rowwhen (exists (select * from sc where cno = o.cno))ROLLBACK; 四、关系数据库设计理论1. 关系模式设计中的四种数据语义问题 / 异常 数据冗余：比如选课表（教师，学生）一个教师需对选他课的所有学生都重复一次 教师A 学生A 教师A 学生B 教师A 学生C 更新异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。比如修改了第一个元组的教师A的工号，但是下面元组教师A的信息并没有得到修改 删除异常：删除一个信息，那么也会丢失其它信息。比如删除第一个元组，那么学生A的信息也会丢失 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 2. 函数依赖 - 三大范式 + BCNF函数依赖： 比如关系模式 S(Sno, Cno, Name, Grade) 假设 主键是（Sno，Cno)，有如下关系模式 (Sno, Cno) ——&gt; Grade：Grade 完全依赖于主键 Sno ——&gt; Name：Name 部分依赖于主键 范式理论：（解决四种数据语义问题 / 四种异常） 第一范式 1 NF：属性不可分。可以认为任何表都属于第一范式，因为每个表的最小单位为表中的各个属性。 第二范式 2 NF：在满足 1 NF 的条件下，消除非主属性对主键的部分函数依赖 第三范式 3 NF：在满足 2 NF 的条件下，消除非主属性对主键的传递函数依赖 修正的第三范式 BCNF：在满足第二范式的条件下，消除所有属性对主属性的传递依赖。即如果一个属性/属性组 A 决定其他属性/属性组B，则 A 必须包含主键 满足 BCNF 则一定满足 3NF，反之不一定 3. E-R 图的表示方法实体之间的联系： 1：1 关系：比如一个班级对应一个班长，一个班长只对应一个班级 1：n 关系：比如一个老师教授多门课程，一门课程只对应一个老师 n：n 关系：比如一门课程由若干个学生选修，一个学生可选修若干门课程 E-R 图基本表示方法： 实体型用矩形表示 属性用椭圆表示 联系用菱形表示 4. E-R 图如何转换为数据库表E-R 图转换为数据库表，就是要把 E-R 图转换为对应的关系模式，转换的一般原则如下： 一个实体型转换为一个关系模式 关系的属性就是实体的属性 关系的码就是实体的码 一个 1：1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并 一个 m：n 联系可以转换为一个独立的关系模式 关系的属性：与该联系相连的各实体的码以及联系本身的属性 关系的码：各实体型码的组合 三个或三个以上实体间的一个多元联系可以转换为一个关系模式 关系的属性：与该多元联系相连的各实体的码以及联系本身的属性 关系的码：各实体码的组合 具有相同码的关系模式可合并 目的：减少系统中的关系个数 五、查询处理和优化 ⭐1. 查询处理的具体流程 查询分析 对 sql 语句进行扫描，词法分析+语法分析，判断查询语句是否符合 SQL 语法规则 查询检查 语义检查，即检查数据库对象，如关系名、属性名是否存在且有效 查询优化 优化器选择一个高效执行的查询处理策略，以达到最好的查询优化效果 查询执行 代码生成器生成执行这个查询计划的代码，然后加以执行，并返回查询结果 2. 多表连接时的处理算法以下面这条 SQL 语句为例： 1select * from Student,SC where Student.Sno = SC.Sno; ① 嵌套循环算法 nested loop最简单可行的算法。 取 Student 表的一个元组，与 SC 表的所有元组进行比较，凡满足连接条件的元组就进行连接并且作为结果输出。 然后再取 Student 表的下一个元组，与 S 的所有元组比较，直至 Student 表的所有元组与 SC 表的所有元组比较完毕为止。 ② 排序-归并算法 sort-merge等值连接常用的算法，如果 Student 表和 SC 表已经按连接属性排好序了，则可按序比较两个表的连接属性，找出匹配的所有元组。 核心思想：分别从两个表中取出一行元组进行比较，如果匹配就连接起来放入结果集；如果不匹配，将较小的那个元组丢弃，继续匹配这个表的下一行，依次处理直到将两表的数据取完。 如果 Student 表 和 SC 表在做连接操作之前没有按连接属性进行排序，则我们需要事先为之排序，由于排序是开销很大的操作，在此情况下是否值得使用排序归并法，那就需要权衡了。 ③ 索引连接算法 index join 在 SC 表上已经建立了 Sno 的索引 对 Student 中的每一个元组，在 SC 表中通过 Sno 的索引查找对应的 SC 元组，把相匹配的两个表中的元组连接起来。循环执行，直到 Student 表扫描结束 ④ 散列连接算法 hash join 🚨 Oracle 支持 hash join，MySQL 不支持 用来处理等值连接。把连接属性作为 hash 的 value，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。 创建阶段：创建 hash 表。对包含较少元组的表进行处理，把他的元组按 hash 函数分散到 hahs 桶中（采用拉链法） 连接阶段：对另一个表进行 hash。并把这个表中元组和上一个表中相匹配的元组（同义词）连接起来。如果一个桶中只有 Student 或者 SC 的元组，则不进行连接。 3. 查询优化的方法Ⅰ 代数优化代数优化就是通过对关系代数式的等价变换来提高查询效率 代数优化改变的是查询语句中操作的次序和组合，但不涉及底层的存取路径 最常用的优化原则是尽量缩减查询过程中的中间结果。由于选择、投影等一元操作分别从水平或垂直方向减少关系的大小，而连接、并等二元操作不但操作本身的开销较大，而且很可能产生大的中间结果。因此，再做查询优化时，总是让选择和投影先做，再做连接等二元操作。在连接时，也是先做小关系之间的连接，再做大关系之间的连接。 常见的对关系表达式进行查询优化的方法有： 选择运算尽可能先做 若投影运算和选择运算都是对同一个关系进行操作，则将投影运算和选择运算同时进行 把投影同其前或后的双目运算符结合起来 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个来连接运算（连接，特别是等值连接，要比同样关系上的笛卡尔积省很多时间） 找出公共子表达式（比如查询视图的时候，定义视图的表达式就是公共子表达式） Ⅱ 物理优化物理优化就是选择高效合理的操作算法或者存取路径来达到查询优化的目标 选择的方法如下 基于规则的启发式优化 基于代价估算的优化：选择代价最小的执行计划 两者结合的优化方法 ① 基于规则的启发式优化🚩 启发式优化：指的是在大部分情况下使用，但不是在所有情况下都是最好的规则 1）对于选择操作的启发式规则： 对于小关系，使用全表顺序扫描，即使选择列上有索引 对于大关系，启发式规则有： 选择条件是 主键 = 值，采用主键索引 选择条件是 非主属性 = 值，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描 选择条件是 非等值查询或范围查询，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描 使用 AND 连接的合取选择条件，如果有涉及这些属性的组合索引，则优先使用索引，否则使用全表顺序扫描 对于 OR 连接的析取选择条件，一般使用全表顺序扫描 2）对于连接操作的启发式规则： 如果两个表都已经按照连接属性排序，则使用排序-合并算法 如果一个表在连接属性上有索引，则使用索引连接算法 如果上面两个规则不适用，且其中一个表较小，则使用 hash join 算法 最后可以使用嵌套循环算法 ② 基于代价估算的优化基于代价的优化方法要计算各种操作算法的执行代价，它与数据库的状态密切相关。为此在数据字典中存储了优化器需要的统计信息，主要包括以下几个方面： 六、事务处理 - 数据库恢复技术 ⭐1. 什么是数据库事务？事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 一个程序包含多个事务。 事务最经典也经常被拿出来说例子就是转账了。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。 万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 2. 事务的 ACID 特性 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的. 隔离性（Isolation）一个事务的执行不能被其他事务干扰，即一个事务的内部操作即使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。接下来的操作和故障不应该对其执行结果有任何影响 3. 事务的ACID特性遭到破坏的因素 多个事务并发执行，互相干扰 事务在运行过程中被强行终止 4. 数据库恢复技术数据库恢复技术就是把数据库从错误状态恢复到某一已知的正确状态。 恢复的基本原理十分简单。可以用一个词来概括，冗余。就是说数据库中任何一部分被破坏或者不正确的数据都可以根据存储在系统别处的冗余数据来重建。 数据转储：数据转储就是管理员定期的将整个数据库复制到磁带、磁盘或其他存储介质上。这些备用的数据称为后备副本 backup 重装后备副本只能将数据库恢复到转储时的状态，其之后的事务操作都必须重新执行一遍才能恢复到故障发生时的状态。 登记日志文件：日志文件中需要登记的内容包括： 各个事务的开始标记 各个事务的结束标记 各个事务的更新操作 登记日志文件时必须遵循两条原则 登记的次序必须严格按照并发事务执行的时间次序 必须先写日志文件，后进行数据库操作 5. 数据库如何保证事务的 ACID 特性 原子性实现原理 - Undo Log 为了实现原子性，需要通过日志：将所有对数据更新操作都写入日志，如果一个事务中的一部分已经操作成功，但以后的操作由于断电/系统崩溃/其他软硬件错误或者用户提交了rollback 导致无法进行，则通过回溯日志，将已经执行成功的操作撤销 undo，从而达到全部操作失败的目的，使得数据库恢复到一致性的状态，可以继续被使用。 持久性实现原理 - Redo Log 和Undo Log 相反，Redo（重做） Log 记录的是新数据的备份。在事务提交前，只是将Redo Log 持久化即可，不需要数据持久化。当系统崩溃时，虽然数据没有持久化，但Redo Log 已经持久化了。系统可以根据Redo Log 将数据更新到最新的状态。 隔离性实现原理 - 锁 当然，保证事务的隔离性，即并发控制不止可用封锁协议，还有时间戳、多版本控制等等。 七、事务处理 - 并发控制 ⭐1. 并发事务带来的问题 脏读：事务T1修改了一份数据，还没有提交操作，这时事务T2读取了这份数据，由于某些原因事务T1回滚了他的修改操作使得数据恢复到原来，这样事务T2读取的数据就是脏数据 丢失修改：事务T1修改了一份数据，还没有提交操作，这时事务T2也修改了这份数据，这样就导致事务T1 的修改结果丢失了 不可重复读：事务 T1 读取一份数据，然后 事务 T2 修改了该数据，事务 T1 再一次读取了该数据，这样，事务 T1 两次读取的这份数据的结果是不一样的，称为不可重复读 幻读：幻读与不可重读类似，不过幻读侧重于数据的增加和删除，不可重读侧重于修改。事务 T1 读取了一份数据，然后事务 T2 给这个数据添加了几条记录，事务 T1 再一次读取该数据，发现多了一些原本不存在的数据，就好像发生了幻觉一样。 2. 事务的隔离级别SQL 标准为事务定义了四个不同的隔离级别以满足事务的 ACID 特性，由低到高依次为 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 （该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。） 这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 隔离级别 脏读 不可重复读 幻影读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × Mysql InnoDB 存储引擎 默认采用的 REPEATABLE_READ 可重读 隔离级别 Oracle 默认采用的 READ_COMMITTED 读取已提交 隔离级别 3. 乐观锁和悲观锁数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时，不破坏事务的 ACID 特性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 🚨 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在修改数据之前先锁定，再修改。实现方式：悲观锁主要是 共享锁 或 排他锁（见下文） 乐观锁：乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 4. 什么是锁当数据库有并发事务的时候，可能会相互干扰，这时候需要一些机制来保证事务访问的次序，锁机制就是这样的一个机制。 所谓封锁就是事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁，在事务 T释放它的锁之前，其他事务不更新此对象。 5. 锁的类别 排他锁 / 写锁 X 锁 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和修改。 加X锁期间其它事务不能对 A 加任何锁。这就保证了其他事务在该事务释放X锁之前不能读取和修改A 共享锁 / 读锁 S 锁 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。 加S锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。这就保证了其他事务可以读A，但在该事务释放S锁之前不能对A进行修改 意向锁（意向锁的引入是为了解决多粒度封锁时，检查封锁冲突效率低下问题） IS 锁 如果对一个数据对象加 IS 锁，则表示它的后裔结点想要加 S 锁 IX 锁 如果对一个数据对象加 IX 锁，则表示它的后裔结点想要加 X 锁 SIX 锁 如果对一个数据对象加 SIX 锁，则表示对他加 S 锁，再加 IX 锁 6. 多粒度封锁封锁对象的大小称为 封锁粒度 granularity MySQL 中提供了两种封锁粒度：行级锁 以及 表级锁 。 行级锁 row-level locking 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 table-level locking 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 因此如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为 多粒度封锁 multiple granularity locking 首先我们需要知道多粒度树：多粒度树的根节点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度 下图给出了一个三级粒度树 多粒度封锁协议允许多粒度树中的每个结点被独立的加锁，对一个结点加锁意味着这个结点的所有后裔结点都被加以同样的锁 显示封锁：应事务的要求直接加到数据对象上的锁 隐式封锁：该数据对象没有被独立加锁，继承上级结点的锁 系统检查封锁冲突时不仅要检查显示封锁，还要检查隐式封锁。 显然，这样的检查方法效率很低，为此人们引进了意向锁（见上个问题） 7. 什么是死锁 / 活锁，怎么解决 死锁：两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环等待的现象。 解决死锁的方法： 死锁预防：破坏死锁产生的条件 一次封锁法：每个事务必须一次性将所有需要的数据全部加锁，否则不能执行 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序进行封锁 死锁检测： 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 等待图法：如果图中存在回路，则表示系统中出现了死锁 死锁处理： 一般采取的死锁解除策略是：选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去。 活锁：事务T1 封锁了数据 1，事务 T2请求封锁数据1，于是 T2等待，T3 也请求封锁数据1，当事务 T1 释放了对数据 1 的封锁后，批准了 T3 的请求，于是 T2 继续等待，T4 请求封锁数据1，当事务 T3 释放了对数据 1 的封锁后，批准了 T4 的请求，于是 T2 继续等待。。。。T2 可能永远等待，即一个事务等待的时间过长而影响事务的执行，这就是活锁。 解决活锁的方法：先来先服务 8. 封锁协议 三级封锁协议：运用 X 锁和 S 锁进行加锁的时候应遵守的协议规则 一级封锁协议 事务修改数据之前，必须加 X 锁，事务结束释放 X 锁 二级封锁协议 在一级封锁协议的基础上，事务读取数据前，必须加 S 锁，读取完马上释放 S 锁 三级封锁协议 在一级封锁协议的基础上，事务读取时间前，必须加 S 锁，直到事务结束才释放 S 锁 两段锁协议：所有事务必须分两个阶段对数据项进行加锁和解锁，两端锁协议用来实现并发调度的可串行性，从而保证调度的正确性 扩展阶段（加锁）：在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁 收缩阶段（解锁）：在释放一个封锁的时候，事务不再申请和获得任何其他锁 9. 并发调度的可串行性数据库管理系统对并发事务不同的调度可能会产生不同的结果，只有串行调度才能得到正确的结果 可串行化调度：多个事务并发调度的结果和按次序串行执行的结果相同，则这个并发调度就是可串行化调度 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 冲突可串行化调度：冲突操作是指不同的事务对同一个数据的读写操作和写写操作 不同事务或者同一事务的冲突操作时不能交换的。 一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度B，则称调度B是冲突可串行化的调度。 若一个调度是冲突可串行化调度，那么一定是可串行化调度 八、数据库编程数据库编程就是用编程方法对数据库进行操纵的技术，SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足（没有逻辑控制能力），提高应用系统和数据库管理系统间的互操作性。 1. 什么是存储过程？有哪些优缺点？存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 优点 存储过程是预编译过的，执行效率高。 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 安全性高，执行存储过程需要有一定权限的用户。 存储过程可以重复使用，减少数据库开发人员的工作量。 缺点 调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。 移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。 2. 什么是游标游标主要用于嵌入式 SQL，一条 SQL 语句可以产生或处理多条记录；而主语言是面向记录的，一组主变量一次只能存放一条记录。为此引入游标来协调这两种不同的处理方式 游标是面向集合的，游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。 九、索引 ⭐1. 什么是索引索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。 索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。 2. 索引的创建12create [unique][cluster] index 索引名on 表名 (列名[次序]，列名[次序]...) unique 表示此索引的每一个索引值只对应唯一的数据记录 cluster 表示该索引是聚集索引，详见后文 示例： 1234create unique index sno_index on student(sno);create unique index cno_index on cource(cno);# sc表按学号升序和课程号降序建立唯一索引create unique index sc_index on sc(sno asc, cno desc); 3. 为什么要使用索引，索引的优缺点分析① 索引的优点 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的 。 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 ② 索引的缺点 创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。 占用物理存储空间 ：索引需要使用物理文件存储，也会耗费一定空间。 ③ 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 数据库的存储介质一般由多个磁盘阵列组成。数据在磁盘阵列上的分布也是数据库物理设计的内容之一，这就是所谓的分区设计 partition design。分区设计的一般原则如下： 减少访盘冲突，提高 I/O 并行性 分散热点数据，均衡 I/O 负荷 保证关键数据的快速访问，缓解系统的瓶颈 4. B+树原理 ⭐① 数据结构B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，所有叶子节点位于同一层并且不带任何信息，所有索引信息和相应的数据都存储在分支结点中（既存放 键(key) 也存放 数据(data)） B+树是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。B+树中叶节点包含关键字的全部信息（键(key) 和数据(data)），其他非叶结点/分支结点仅起索引作用（仅存储key）。并将关键字按照大小顺序排列，相邻叶子结点按照大小顺序相互链接起来（支持顺序查找）。 B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。 ② 操作进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。（插入删除操作详细见 数据结构【五】查找） ③ 与红黑树的比较红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： （一）更少的查找次数 平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 （二）利用磁盘预读特性 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 ④ 与Hash索引的比较 Hash索引定位快 Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。 Hash冲突问题 不过对于数据库来说这还不算最大的缺点。 Hash索引不支持顺序和范围查询是它最大的缺点。⭐ 试想一种情况: 1SELECT * FROM tb1 WHERE id &lt; 500; B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。 而Hash索引是根据hash算法来定位的，需要对所有数据进行一遍hash才能得到查询结果，显然是不现实的。这就是Hash最大的缺点了。 5. 索引类型① 主键索引数据表的主键列使用的就是主键索引。 一张数据表有且只能有一个主键，并且主键不能为null，不能重复。 在mysql的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。 ② 辅助索引/二级索引二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引，普通索引，前缀索引等索引属于二级索引。 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 6. 聚集索引与非聚集索引① 聚集索引定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引，主键索引属于聚集索引。 举例： 地址 id username score 0x01 1 小明 90 0x02 2 小红 80 0x03 3 小华 92 .. .. .. .. 0xff 256 小英 70 数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。 聚集索引的优点： 聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 聚集索引的缺点： 依赖于有序的数据 ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。 ② 非聚集索引定义：该索引中索引的逻辑顺序与磁盘上的物理存储顺序不同，一个表中可以拥有多个非聚集索引。 二级索引属于非聚集索引。 MYISAM引擎的表的.MYI文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据。 非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 非聚集索引的优点 更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的 非聚集索引的缺点 跟聚集索引一样，非聚集索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。 总结来说，对于B+树，如果是聚集索引，那么叶子节点的data将存放数据，如果是非聚集索引，那么data将存放指向数据的指针 7. MySQL主要使用的两种索引① B+树索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，即聚集索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚集索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 ② 哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 8. 索引创建原则 单列索引 单列索引即由一列属性组成的索引。 联合索引(多列索引) 联合索引即由多列属性组成索引。 *最左前缀原则 *⭐ 假设创建的联合索引由三个字段组成: 1ALTER TABLE table ADD INDEX index_name (num,name,age) 那么当查询的条件有为 : num / (num AND name) / (num AND name AND age)时，索引才生效。 所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。 9. 索引创建注意点① 最左前缀原则 虽然目前较高的Mysql版本好像不遵守最左前缀原则，索引也会生效。 但是我们仍应遵守最左前缀原则，以免版本迭代带来的麻烦。 ② 选择合适的字段 不为NULL的字段索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。 被频繁查询的字段我们创建索引的字段应该是查询操作非常频繁的字段。 被作为条件查询的字段被作为WHERE条件查询的字段，应该被考虑建立索引。 被经常频繁用于连接的字段经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。 ③ 不适合创建索引的字段 被频繁更新的字段应该慎重建立索引虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。 不被经常查询的字段没有必要建立索引 尽可能的考虑建立联合索引而不是单列索引因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。 注意避免冗余索引冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引。 如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。 考虑在字符串类型的字段上使用前缀索引代替普通索引前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。 10. 索引优化 独立的列 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 多列索引 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 索引列的顺序 让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值的个数 / 记录总数 (最大值为 1)。 此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 前缀索引 对于BLOB、TEXT 和 VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 覆盖索引 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！ 覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。 如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。 再如普通索引，如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。那么name的索引就称为覆盖索引 11. 百万级别或以上的数据如何删除索引是单独存在的文件，所以当我们对数据的增加、修改、删除时，都会产生额外的对索引文件的操作，这些操作需要消耗额外的 I/O，降低增删改的效率。 对于百万级别的数据来说，删除数据的速度和已建立的索引数量成正比。 所以，删除数据之前，我们需要先删除索引，再删除数据。 十、存储引擎 Storage engine存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。 1. InnoDB是 MySQL 默认的事务型存储引擎，提供了对数据库 ACID 特性的支持，并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。 主索引是聚集索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 2. MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 3. 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 同时支持行级锁和表级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"LeetCode","slug":"数据库/LeetCode","date":"2020-03-31T14:02:45.000Z","updated":"2020-09-04T15:50:23.679Z","comments":true,"path":"2020/03/31/数据库/LeetCode/","link":"","permalink":"https://aaronyard.github.io/2020/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93/LeetCode/","excerpt":"💾 LeetCode 数据库部分题目 175. 组合两个表 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State","text":"💾 LeetCode 数据库部分题目 175. 组合两个表 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State 需要保留Person表中未连接的数据 123select FirstName,LastName,City,Statefrom Person left outer join Addresson Person.PersonId = Address.PersonId; 176. 第二高的薪水 方法一：使用聚集函数 123select max(Salary) SecondHighestSalaryfrom Employeewhere Salary &lt; (select max(Salary) from Employee); 方法二：使用 limit 123456select ( select distinct Salary from Employee order by Salary desc limit 1 offset 1) as SecondHighestSalary; limit x offset y：跳过 y 条数据查询 x 条数据 177. 第N高的薪水 12345678910CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN set N = N - 1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary desc limit N,1 );END 178. 分数排名 我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合 H 里就只有99一个元素，个数为1，因此你的Rank为1。 12345select s1.Score, count(distinct(s2.Score)) Rankfrom Scores s1, Scores s2where s1.Score&lt;=s2.Scoregroup by s1.Idorder by Rank; 180. 连续出现的数字 至少连续出现三次的数字则必定id连续三次或三次以上 123select distinct a.Num as ConsecutiveNumsfrom Logs a,Logs b,Logs cwhere a.Num=b.Num and b.Num=c.Num and a.id=b.id-1 and b.id=c.id-1; 181. 超过经理收入的员工 自连接，第一张表的 Managerid = 第二张表的 id 1234select Name as Employeefrom Employee as awhere Salary &gt; (select Salary from Employee b where b.id = a.Managerid); 182. 查找重复的电子邮箱 利用 group by - having 123select Email from Persongroup by Emailhaving count(Email) &gt; 1; 183. 从不订购的客户 12select c.Name as Customers from Customers cwhere c.Id not in (select distinct o.CustomerId from Orders o); 184. 部门工资最高的员工 123456789101112select d.Name as Department, e.Name as Employee, e.Salary from Employee e,Department d where e.DepartmentId=d.id and (e.Salary,e.DepartmentId) in ( select max(Salary),DepartmentId from Employee group by DepartmentId); 185. 部门工资前三高的所有员工 先定义找出前三高薪水的查询语句，即不超过三个值比这个薪水大。 1234567SELECT e1.Salary FROM Employee AS e1WHERE 3 &gt; (SELECT count(DISTINCT e2.Salary) FROM Employee AS e2 WHERE e1.Salary &lt; e2.Salary AND e1.DepartmentId = e2.DepartmentId) ; 举个栗子：当 e1 = e2 = [4,5,6,7,8] e1.Salary = 4，e2.Salary 可以取值 [5,6,7,8]，count(DISTINCT e2.Salary) = 4 e1.Salary = 5，e2.Salary 可以取值 [6,7,8]，count(DISTINCT e2.Salary) = 3 e1.Salary = 6，e2.Salary 可以取值 [7,8]，count(DISTINCT e2.Salary) = 2 e1.Salary = 7，e2.Salary 可以取值 [8]，count(DISTINCT e2.Salary) = 1 e1.Salary = 8，e2.Salary 可以取值 []，count(DISTINCT e2.Salary) = 0 最后 3 &gt; count(DISTINCT e2.Salary)，所以 e1.Salary 可取值为 [6,7,8]，即集合前 3 高的薪水 再把两个表连接，获得各个部门工资前三高的员工 123456789101112select d.Name as Department, e.Name as Employee, e.Salary as Salaryfrom Employee e, Department dwhere e.DepartmentId = d.Id and 3 &gt; ( select count(distinct e2.Salary) from Employee e2 where e.Salary &lt; e2.Salary and e.DepartmentId = e2.DepartmentId )order by d.Id, e.Salary desc; 196. 删除重复的电子邮箱 方法一： 12345678delete from Personwhere Id not in ( select Id from( select min(Id) as id from Person group by Email ) as temp); 需要套一层临时表，因为查询语句的输出不能作为更新语句的输入 方法二： 1234# 如果用了表别名，delete后要加别名delete p1 from Person p1,Person p2where p1.Email = p2.Email and p1.Id &gt; p2.Id; 197. 上升的温度 MySQL 使用 DATEDIFF 来比较两个日期类型的值。 1234select w1.Id from Weather w1, Weather w2where DATEDIFF(w1.RecordDate,w2.RecordDate) = 1 AND w1.Temperature &gt; w2.Temperature;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库编程","slug":"数据库/10-数据库编程","date":"2020-03-30T14:02:45.000Z","updated":"2020-09-04T15:50:27.340Z","comments":true,"path":"2020/03/30/数据库/10-数据库编程/","link":"","permalink":"https://aaronyard.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","excerpt":"数据库编程就是用编程方法对数据库进行操纵的技术，SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足（没有逻辑控制能力），提高应用系统和数据库管理系统间的互操作性。 使用 SQL 编程来访问和管理数据库中数据的方式主要有： 嵌入式 SQL （ESQL） 过程化 SQL （PL/SQL） 存储过程和自定义函数 开放数据库互连（ODBC） Java 数据库连接 （JDBC） 一、嵌入式 SQL","text":"数据库编程就是用编程方法对数据库进行操纵的技术，SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足（没有逻辑控制能力），提高应用系统和数据库管理系统间的互操作性。 使用 SQL 编程来访问和管理数据库中数据的方式主要有： 嵌入式 SQL （ESQL） 过程化 SQL （PL/SQL） 存储过程和自定义函数 开放数据库互连（ODBC） Java 数据库连接 （JDBC） 一、嵌入式 SQL 1. 嵌入式 SQL 的处理过程嵌入式 SQL 就是将 SQL 语句嵌入程序语言中，被嵌入的程序设计语言比如 Java 就称为宿主语言 / 主语言。 数据库对 嵌入式 SQL 一般采取预编译方法处理，识别出嵌入式 SQL 语句，将其转换为主语言调用语句。 为了能快速区分 SQL 语句与主语言语句，所有 SQL 语句必须加前缀。 主语言 C 1EXEC SQL &lt;SQL语句&gt;; 主语言 Java 1# SQL &#123;&lt;SQL语句&gt;&#125;; 2. 嵌入式 SQL 语句与主语言之间的通信SQL 语句负责操纵数据库，宿主语言负责控制逻辑流程。这时程序中会含有两种不同计算模型的语句，它们之间该如何通信呢？ SQL 语句执行后，系统将包含描述系统当前状态和运行环境的各种数据送到 SQL 通信区，应用程序从 SQL 通信区取出这些状态信息，据此决定接下来执行的语句 主语言向 SQL 提供参数，主要用主变量实现 SQL 语句中使用的宿主语言的程序变量称为主变量 将 SQL 语句的处理结果交给宿主语言处理，主要用主变量和游标实现 游标是面向集合的，一条 SQL 语句可以产生或处理多条记录；而主语言是面向记录的，一组主变量一次只能存放一条记录。为此引入游标来协调这两种不同的处理方式 3. 游标使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 1234DECLARE 游标名 CURSOR FOR SELECT语句;declare mycursor cursor for select col1 from mytable; 打开游标； 1open 游标名 推进游标，取出数据； 1FETCH 游标名 INTO 主变量 [指示变量] [,主变量 [指示变量]] [ ] 表示可选的 主变量就是 select 语句查询的对应列名 12fetch mycursor into ret;select ret; 关闭游标； 1close 游标名 二、过程化 SQL1. 定义和执行定义 1DEClARE 变量/游标/常量/异常等 执行 12345BEGIN SQL语句、过程化SQL的流程控制语句EXCEPTION 异常处理部分END; 2. 流程控制① 条件控制语句IF 语句 123IF 条件 THEN SQL语句;END IF; IF - ELSE 语句 12345IF 条件 THEN SQL语句;ELSE SQL语句;END IF; 嵌套的 IF 语句 THEN和ELSE子句中还能再包含 IF 语句 ② 循环控制语句LOOP 123LOOP SQL 语句;END LOOP; WHILE-LOOP 123WHILE 条件 LOOP SQL 语句;END LOOP; FOR-LOOP 123FOR count IN [REVERSE] 循环下界1 循环上界2 LOOP SQL 语句;END LOOP; 小于循环下界或者大于循环上界就退出循环，指定了 REVERSE 则反之 三、存储过程存储过程是由 过程化 SQL 编写的过程，这个过程经编译和优化后存储在数据库服务器中，因此称它为存储过程，使用时只要调用即可 使用存储过程的好处： 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。可以使用 delemiter 自定义结束符 包含 in 输入参数（默认）、out 输出参数 和 inout 输入/输出参数 三种参数。 给变量赋值都需要用 select into 语句。 创建存储过程： 12create procedure myprocedure(参数)as 过程化SQL块 执行存储过程： 1CALL/PERFORM PROCEDURE 过程名(参数1,参数2...); 删除存储过程： 1DROP PROCEDURE 过程名(); 存储过程示例： 从账户1转账到账户2，Account(Accountnum 账户号码, Total 余额) 12345678910111213141516171819202122232425262728# 参数：转入账户、转出账户、转账额度create or replace procedure transfer(inAccount int, outAccount int, amount float)as declare totalDepositOut float; // 转出账户的额度 totalDepositIn float; //转入账户的额度 inAccountnum int; // 转入账户号码BEGIN select Total into totalDepositOut from Account where Accountnum = outAccount IF totalDepositOut IS NULL THEN //如果转出账户没有存款 ROLLBACK; RETURN; END IF; IF totalDepositOut &lt; amount THEN // 转出账户余额 &lt; 需转额度 ROLLABCK; RETURN; END IF; SELECT Accountnum INTO inAccount From Account WHERE Accountnum = inAccount; //给参数 转入账户 赋值 IF inAccountnum IS NULL THEN // 转入账户不存在 ROLLBACK; RETURN; END IF; UPDATE Account SET Total = Total - amount WHERE Accountnum = outAccount; //修改转出账户余额 UPDATE Account Set Total = Total + amount WHERE Accountnum = inAccount; //修改转入账户余额 COMMIT;END;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"事务处理-并发控制","slug":"数据库/9-事务处理-并发控制","date":"2020-03-29T14:02:45.000Z","updated":"2020-09-04T15:50:32.383Z","comments":true,"path":"2020/03/29/数据库/9-事务处理-并发控制/","link":"","permalink":"https://aaronyard.github.io/2020/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/9-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"本章以及上一章的并发控制都是关于事务处理技术的。 事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。 事务处理技术主要包括 数据库恢复技术（上一章） 并发控制技术","text":"本章以及上一章的并发控制都是关于事务处理技术的。 事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。 事务处理技术主要包括 数据库恢复技术（上一章） 并发控制技术 一、并发事务带来的问题 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 1. 脏读（Dirty read）当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据” ，依据 “脏数据” 所做的操作可能是不正确的。 （T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。） 2. 丢失修改（Lost update）指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 （T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。） 3. 不可重复读（no-repeatable read）一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 （T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同） 4. 幻读（Phantom read）幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 （T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同） ⚠ 不可重复度和幻读区别： 不可重复读的重点是修改，幻读的重点在于新增或者删除。 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）： 事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）： 假如某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 二、封锁并发控制的主要技术有封锁 locking、时间戳 timestamp、乐观控制法 optimistic scheduler 和多版本控制 MVCC 等 封锁是众多数据库产品采用的基本方法。 所谓封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁，在事务T释放它的锁之前，其他事务不更新此对象。 确切的控制由封锁的类型决定，如下 1. 封锁类型基本的封锁类型有两种：排他锁 X 锁 和 共享锁 S锁 ① 排他锁 - X 锁/写锁一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和修改。 加X锁期间其它事务不能对 A 加任何锁。这就保证了其他事务在该事务释放X锁之前不能读取和修改A ② 共享锁 - S 锁/读锁一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。 加S锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。这就保证了其他事务可以读A，但在该事务释放S锁之前不能对A进行修改 ③ 数据锁相容矩阵 2. 封锁协议 - 三级封锁协议在运用X锁和S锁对数据对象加锁的时候，还需要约定一些规则。比如何时申请X锁或S锁、持锁时间、何时释放等。这些规则称为封锁协议。此处介绍的是三级封锁协议，后续还有两段锁协议 ① 一级封锁协议事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 但不能解决读脏数据和不可重复读的问题，因为在一级封锁协议中，仅仅读数据而对其进行修改是不需要进行加锁的 ② 二级封锁协议在一级的基础上，要求读取数据 A 时必须加 S 锁, 读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 但不能解决不可重复读问题，因为读完数据后就释放S锁，其他事务可以再加锁进行修改 ③ 三级封锁协议在一级协议的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 ④ 三级封锁协议总结 三、活锁和死锁和操作系统一样，封锁的方法可能引起活锁和死锁问题 1. 活锁 避免活锁的方法就是采用先来先服务的策略。 2. 死锁事务T1封锁数据R1，事务T2封锁数据R2，T1请求R2, T2请求R1，于是事务T1等待事务T2释放锁，事务T2也等待事务T1释放锁，两个事务循环等待，永远不能结束。如上图 b 所示 3. 死锁的处理和预防对于死锁问题，要么采取措施预防死锁发生，要么允许死锁发生，检测到死锁后采取策略解除死锁 ① 死锁的预防破坏产生死锁的条件 一次封锁法 每个事务必须一次性将所有需要的数据全部加锁，否则不能执行 顺序封锁法 预先对数据对象规定一个封锁顺序，所有事务都按照整个顺序进行封锁 ② 死锁的检测和处理 超时法 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 等待图法 事务等待图是一个有向图 G = (T, U) ，T是结点的集合，每个结点表示正在运行的事务；U为边的集合，每条边表示事务等待的情况，T1——&gt;T2 表示 T1 正在等待 T2. 如果图中存在回路，则表示系统中出现了死锁 数据库检测到死锁后，一般采取的死锁解除策略是：选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去。 四、并发调度的可串行性数据库管理系统对并发事务不同的调度可能会产生不同的结果，只有串行调度才能得到正确的结果 1. 可串行化调度多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为 可串行 serializable 调度。 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 示例： 2. 冲突可串行化调度冲突操作是指不同的事务对同一个数据的读写操作和写写操作 不同事务或者同一事务的冲突操作时不能交换的。 一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度B，则称调度B是冲突可串行化的调度。 若一个调度是冲突可串行化调度，那么一定是可串行化调度 五、两段锁协议目前数据库管理系统普遍采用 两段锁 TwoPhase Locking 协议（简称 2PL）的的方法实现并发调度的可串行性，从而保证调度的正确性 两段锁协议就是指所有事务必须分两个阶段对数据项进行加锁和解锁 扩展阶段：在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁 收缩阶段：在释放一个封锁的时候，事务不再申请和获得任何其他锁 六、封锁的粒度封锁对象的大小称为 封锁粒度 granularity MySQL 中提供了两种封锁粒度：行级锁 以及 表级锁 。 表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。 行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 因此如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为 多粒度封锁 multiple granularity locking 1. 多粒度封锁首先我们需要知道多粒度树：多粒度树的根节点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度 下图给出了一个三级粒度树 多粒度封锁协议允许多粒度树中的每个结点被独立的加锁，对一个结点加锁意味着这个结点的所有后裔结点都被加以同样的锁 显示封锁：应事务的要求直接加到数据对象上的锁 隐式封锁：该数据对象没有被独立加锁，继承上级结点的锁 系统检查封锁冲突时不仅要检查显示封锁，还要检查隐式封锁。 显然，这样的检查方法效率很低，为此人们引进了意向锁 2. 意向锁意向锁表示如果对一个结点加锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁 例如：对任一元组加锁时，必须先对它所在的关系或者数据库加意向锁 下面介绍三种常用的意向锁 ① IS 锁如果对一个数据对象加 IS 锁，则表示它的后裔结点想要加 S 锁 ② IX 锁如果对一个数据对象加 IX 锁，则表示它的后裔结点想要加 X 锁 ③ SIX 锁如果对一个数据对象加 SIX 锁，则表示对他加 S 锁，再加 IX 锁 例如对某个表加 SIX 锁，则表示该事务先要读整个表，读表过程中不允许其他事务进行修改；读表的同时还会对该表中的个别元组进行修改，所以加 IX 锁，表示表下面的元组想要加X锁。 ④ 数据锁相容矩阵 从上图我们可以看出锁的强弱程度，即对其他锁的排斥程度。一个事务在申请封锁的时候，以强锁代替弱锁时安全的，反之则不然 总结如下： X 锁 不兼容任何锁 任意IS / IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁 这里兼容关系针对的是表级锁，而 表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。） 七、事务的隔离级别事务具有隔离性，理论上说事务之间的执行不应该相互影响，其读数据库的影响应该和他们串行时执行一样。完全的隔离性会导致系统并发性能很低，降低对资源的利用率，因而实际上会对隔离性的要求会有所放松。 SQL 标准为事务定义了四个不同的隔离级别，从低到高依次是： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 （该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。） 隔离级别 脏读 不可重复读 幻影读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化) 隔离级别。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。 InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化) 隔离级别。 八、DBMS保证事务的ACID特性原理结合上一章和本章的内容，我们来总结一下数据库管理系统是如何保证事务的ACID特性的。 首先，事务的原子性、持久性、隔离性都是为了实现事务的一致性 1. 原子性实现原理 - Undo Log为了实现原子性，需要通过日志：将所有对数据更新操作都写入日志，如果一个事务中的一部分已经操作成功，但以后的操作由于断电/系统崩溃/其他软硬件错误或者用户提交了rollback 导致无法进行，则通过回溯日志，将已经执行成功的操作撤销 undo，从而达到全部操作失败的目的，使得数据库恢复到一致性的状态，可以继续被使用。 2. 持久性实现原理 - Redo Log和Undo Log 相反，Redo（重做） Log 记录的是新数据的备份。在事务提交前，只是将Redo Log 持久化即可，不需要数据持久化。当系统崩溃时，虽然数据没有持久化，但Redo Log 已经持久化了。系统可以根据Redo Log 将数据更新到最新的状态。 3. 隔离性实现原理 - 锁当然，保证事务的隔离性，即并发控制不止可用封锁协议，还有时间戳、多版本控制等等。 基于锁的并发控制流程： 事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排它锁）。 申请锁的请求被发给锁管理器。锁管理器根据当前页是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁。 若锁被授予，则申请锁的事务可以被继续执行；若被拒绝，则申请锁的事务将进行等待，直到锁被其它事务释放。 可能出现的问题： 死锁：多个事务持有锁并循环等待其它事务的锁导致所有的事务都无法继续执行。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"事务处理-数据库恢复技术","slug":"数据库/8-事务处理-数据库恢复技术","date":"2020-03-28T14:02:45.000Z","updated":"2020-09-04T15:50:38.968Z","comments":true,"path":"2020/03/28/数据库/8-事务处理-数据库恢复技术/","link":"","permalink":"https://aaronyard.github.io/2020/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93/8-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/","excerpt":"本章以及下一章的并发控制都是关于事务处理技术的。 事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。 事务处理技术主要包括 数据库恢复技术 并发控制技术（下一章）","text":"本章以及下一章的并发控制都是关于事务处理技术的。 事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元。 事务处理技术主要包括 数据库恢复技术 并发控制技术（下一章） 一、事务的基本概念1. 事务事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 一个程序包含多个事务。 事务最经典也经常被拿出来说例子就是转账了。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。 万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 事务的开始和结束可以由用户显示控制，在SQL中，定义事务的语句有3条 BEGIN TRANSACTION; ： 事务以此语句开始 COMMIT; : 提交事务的所有操作 RLLBACK;：回滚 事务一般以 commit 或者 rollback 结束 2. 事务的ACID特性 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的. 隔离性（Isolation）一个事务的执行不能被其他事务干扰，即一个事务的内部操作即使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。接下来的操作和故障不应该对其执行结果有任何影响 3. 事务的ACID特性遭到破坏的因素事务时恢复和并发控制的基本单位，保证事务ACID特性是事务管理的重要任务，事务ACID特性可能遭到破坏的因素有： 多个事务并发执行，相互干扰 事务在运行过程中被强行终止 二、数据库恢复技术作用数据库恢复技术就是把数据库从错误状态恢复到某一已知的正确状态。 数据恢复技术是衡量系统性能优劣的重要指标 三、故障的种类1. 事务内部的故障事务内部的故障更多是非预期的、不能由应用程序处理的故障。一般我们所说的事务故障都是指这类非预期故障。 事务故障意味着事务没有到达预期的终点（commit 或者 rollback）因此，数据库可能处于不正确的状态。 恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务已经做出的任何对数据库的修改。这类恢复操作称为 事务撤销 UNDO 2. 系统故障系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。 例如，特定类型的硬件错误(CPU故障) 、操作系统故障、DBMS代码错误、系统断电等。这类故障影响正在运行的所有事务，但不破坏数据库。此时主存内容，尤其是数据库缓冲区 中的内容都被丢失，所有运行事务都非正常终止。发生系统故障时，一些 尚未完成的事务的结果可能已送入物理数据库，从而造成数据库可能处于不正确的状态。为保证数据库的一致性，需要清除这些事务对数据库的所有修改。所以系统重新启动后， 恢复子系统除需要撤销所有未完成的事务外， 还需要重做(REDO)所有已提交的事务，以将数据库真正恢复到一致状态 3. 介质故障系统故障称为软故障，介质故障称为硬故障。 硬故障指外存损坏，比如磁盘损坏等 4. 计算机病毒 四、恢复的实现技术恢复的基本原理十分简单。可以用一个词来概括，冗余。就是说数据库中任何一部分被破坏或者不正确的数据都可以根据存储在系统别处的冗余数据来重建。 恢复机制涉及的两个关键问题就是： 如何建立冗余数据（数据转储 + 登记日志文件 logging） 如何利用冗余数据实现数据库恢复 1. 数据转储数据转储就是管理员定期的将整个数据库复制到磁带、磁盘或其他存储介质上。这些备用的数据称为后备副本 backup 重装后备副本只能将数据库恢复到转储时的状态，其之后的事务操作都必须重新执行一遍才能恢复到故障发生时的状态。 转储十分耗时，不能频繁进行。 2. 登记日志文件日志文件中需要登记的内容包括： 各个事务的开始标记 各个事务的结束标记 各个事务的更新操作 登记日志文件时必须遵循两条原则 登记的次序必须严格按照并发事务执行的时间次序 必须先写日志文件，后进行数据库操作","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"查询处理和优化","slug":"数据库/7-查询处理和优化","date":"2020-03-27T14:02:45.000Z","updated":"2020-09-04T15:50:41.892Z","comments":true,"path":"2020/03/27/数据库/7-查询处理和优化/","link":"","permalink":"https://aaronyard.github.io/2020/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/7-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/","excerpt":"一、查询处理查询处理是数据库管理系统把用户提交上来的查询语句转换成高效的查询执行计划。 关系数据库管理系统查询处理可以分为4个阶段： 查询分析 查询检查 查询优化 查询执行 1. 查询分析首先对查询语句进行扫描、语法分析和词法分析。从查询语句中识别出语言符号，如SQL关键字、属性名和关系名等，进行语法检查和语法分析，判断查询语句是否符合SQL语法规则","text":"一、查询处理查询处理是数据库管理系统把用户提交上来的查询语句转换成高效的查询执行计划。 关系数据库管理系统查询处理可以分为4个阶段： 查询分析 查询检查 查询优化 查询执行 1. 查询分析首先对查询语句进行扫描、语法分析和词法分析。从查询语句中识别出语言符号，如SQL关键字、属性名和关系名等，进行语法检查和语法分析，判断查询语句是否符合SQL语法规则 2. 查询检查对合法的查询语句进行语义检查，即检查数据库对象，如关系名、属性名是否存在和有效。 还要根据用户权限和完整性约束定义对用户的存取权限进行检查。如果用户没有相应权限或者违反了完整性约束，就拒绝执行该查询。 检查过后将SQL查询语句转成内部表示即等价的关系代数表达式，一般用 查询树 / 语法分析树 来表示扩展的关系代数表达式 3. 查询优化查询优化就是优化器选择一个高效执行的查询处理策略，以获得最好的查询优化效果 按照优化的层次分为代数优化和物理优化 4. 查询执行根据优化器得到的执行策略生成查询执行计划，由代码生成器生成执行这个查询计划的代码，然后加以执行，并返回查询结果 二、实现查询操作的算法1. 选择操作的实现① 全表扫描算法 table scan适用于规模较小的表。 对于大规模的表，当选择率较低时，这个算法的效率很低 ② 索引扫描算法 index scan如果选择条件中的属性上有索引，可以用索引扫描算法，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组 2. 连接操作的实现 / 多表连接以下面这条 SQL 语句为例： 1select * from Student,SC where Student.Sno = SC.Sno; ① 嵌套循环算法 nested loop最简单可行的算法。 取 Student 表的一个元组，与 SC 表的所有元组进行比较，凡满足连接条件的元组就进行连接并且作为结果输出。 然后再取 Student 表的下一个元组，与 S 的所有元组比较，直至 Student 表的所有元组与 SC 表的所有元组比较完毕为止。 ② 排序-归并算法 sort-merge等值连接常用的算法，如果 Student 表和 SC 表已经按连接属性排好序了，则可按序比较两个表的连接属性，找出匹配的所有元组。 核心思想：分别从两个表中取出一行元组进行比较，如果匹配就连接起来放入结果集；如果不匹配，将较小的那个元组丢弃，继续匹配这个表的下一行，依次处理直到将两表的数据取完。 如果 Student 表 和 SC 表在做连接操作之前没有按连接属性进行排序，则我们需要事先为之排序，由于排序是开销很大的操作，在此情况下是否值得使用排序归并法，那就需要权衡了。 ③ 索引连接算法 index join 在 SC 表上已经建立了 Sno 的索引 对 Student 中的每一个元组，在 SC 表中通过 Sno 的索引查找对应的 SC 元组，把相匹配的两个表中的元组连接起来。循环执行，直到 Student 表扫描结束 ④ 散列连接算法 hash join 🚨 Oracle 支持 hash join，MySQL 不支持 用来处理等值连接。把连接属性作为 hash 的 value，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。 创建阶段：创建 hash 表。对包含较少元组的表进行处理，把他的元组按 hash 函数分散到 hahs 桶中（采用拉链法） 连接阶段：对另一个表进行 hash。并把这个表中元组和上一个表中相匹配的元组（同义词）连接起来。如果一个桶中只有 Student 或者 SC 的元组，则不进行连接。 三、查询优化每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。 查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统可以比用户程序的优化做的更好。 1. 代数优化代数优化就是通过对关系代数式的等价变换来提高查询效率 代数优化改变的是查询语句中操作的次序和组合，但不涉及底层的存取路径 最常用的优化原则是尽量缩减查询过程中的中间结果。由于选择、投影等一元操作分别从水平或垂直方向减少关系的大小，而连接、并等二元操作不但操作本身的开销较大，而且很可能产生大的中间结果。因此，再做查询优化时，总是让选择和投影先做，再做连接等二元操作。在连接时，也是先做小关系之间的连接，再做大关系之间的连接。 常见的对关系表达式进行查询优化的方法有： 选择运算尽可能先做 若投影运算和选择运算都是对同一个关系进行操作，则将投影运算和选择运算同时进行 把投影同其前或后的双目运算符结合起来 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个来连接运算（连接，特别是等值连接，要比同样关系上的笛卡尔积省很多时间） 找出公共子表达式（比如查询视图的时候，定义视图的表达式就是公共子表达式） 2. 物理优化物理优化就是选择高效合理的操作算法或者存取路径来达到查询优化的目标 选择的方法如下： 基于规则的启发式优化 基于代价估算的优化：选择代价最小的执行计划 两者结合的优化方法 ① 基于规则的启发式优化🚩 启发式优化：指的是在大部分情况下使用，但不是在所有情况下都是最好的规则 1）对于选择操作的启发式规则： 对于小关系，使用全表顺序扫描，即使选择列上有索引 对于大关系，启发式规则有： 选择条件是 主键 = 值，采用主键索引 选择条件是 非主属性 = 值，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描 选择条件是 非等值查询或范围查询，并且选择列上有索引，估算查询结果的元组数目，如果比例较小，可以使用索引，否则仍然使用全表顺序扫描 使用 AND 连接的合取选择条件，如果有涉及这些属性的组合索引，则优先使用索引，否则使用全表顺序扫描 对于 OR 连接的析取选择条件，一般使用全表顺序扫描 2）对于连接操作的启发式规则： 如果两个表都已经按照连接属性排序，则使用排序-合并算法 如果一个表在连接属性上有索引，则使用索引连接算法 如果上面两个规则不适用，且其中一个表较小，则使用 hash join 算法 最后可以使用嵌套循环算法 ② 基于代价估算的优化基于代价的优化方法要计算各种操作算法的执行代价，它与数据库的状态密切相关。为此在数据字典中存储了优化器需要的统计信息，主要包括以下几个方面：","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库设计之E-R图","slug":"数据库/6-数据库设计之E-R图","date":"2020-03-26T14:02:45.000Z","updated":"2020-09-04T15:50:44.587Z","comments":true,"path":"2020/03/26/数据库/6-数据库设计之E-R图/","link":"","permalink":"https://aaronyard.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B9%8BE-R%E5%9B%BE/","excerpt":"P.P.S.Chen 提出的 E-R 模型使用 E-R 图来描述现实世界的概念模型。E-R 模型涉及的主要概念包括实体、属性、实体之间的联系等 实体 entity：客观存在并可相互区别的事物，比如一个学生，一门课，学生的一次选课 属性：实体所具有的特性，比如学生的身高 码：唯一标识实体的属性集，比如学生的学号 实体型： 实体名+属性名，比如 学生（学号，姓名，性别）就是一个实体型 实体集：同一类型的实体的集合，比如全体学生 联系 relationship：实体之间的联系（有一对一，一对多，多对多等多种类型）","text":"P.P.S.Chen 提出的 E-R 模型使用 E-R 图来描述现实世界的概念模型。E-R 模型涉及的主要概念包括实体、属性、实体之间的联系等 实体 entity：客观存在并可相互区别的事物，比如一个学生，一门课，学生的一次选课 属性：实体所具有的特性，比如学生的身高 码：唯一标识实体的属性集，比如学生的学号 实体型： 实体名+属性名，比如 学生（学号，姓名，性别）就是一个实体型 实体集：同一类型的实体的集合，比如全体学生 联系 relationship：实体之间的联系（有一对一，一对多，多对多等多种类型） 一、实体之间的联系1. 两个实体6-型之间的联系可分为以下三种： ① 一对一联系 1：1例如一个班级一个只有班长，班长和班级之间具有一对一联系 ② 一对多联系 1：n例如一个班级中有若干个学生，且每个学生只在一个班级中学习，班级与学生之间具有一对多联系 ③ 多对多联系 m：n例如一门课程同时有若干个学生选修，而一个学生可以选修多个课程，则课程和学生之间具有多对多联系 2. 两个以上实体型之间的联系两个以上实体型之间的联系也存在一对一，一对多，多对多的联系 例如，对于课程，教师，参考书三个实体型，一门课程可以有若干个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的 又如：对于供应商，项目，零件三个实体型，一个供应商可以给多个项目供应零件，每个项目可以使用多个供应商提供的零件，每种零件可由不同供应商提供，则供应商、项目、零件三者之间的关系就是多对多的联系 3. 单个实体型内的联系同一个实体型内的各实体之间也存在一对一、一对多、多对多的联系。 例如：职工实体型内部具有领导和被领导的联系，即某一职工领导若干名职工，而一个职工仅被另外一个职工直接领导，因此这是一对多的联系 二、E-R 图1. 基本表示方法E-R 图提供了表示实体型、属性、联系的方法 例如： 2. 实例下面用 E-R 图来表示某个工厂物资管理的概念模型 E-R 图如下： 三、E-R 图向关系模式的转换1. 转换的一般原则转换的一般原则： 一个实体型转换为一个关系模式 关系的属性就是实体的属性 关系的码就是实体的码 一个 1：1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并 一个 m：n 联系可以转换为一个独立的关系模式 关系的属性：与该联系相连的各实体的码以及联系本身的属性 关系的码：各实体型码的组合 三个或三个以上实体间的一个多元联系可以转换为一个关系模式 关系的属性：与该多元联系相连的各实体的码以及联系本身的属性 关系的码：各实体码的组合 具有相同码的关系模式可合并 目的：减少系统中的关系个数 2. 实例物资管理的 E-R 图如下： 一个实体型转换为一个关系模式： 供应商（供应商号，姓名，地址，电话号，账号） 项目（项目号，预算，开工日期） 零件（零件号，名称，规格，单价，描述） 仓库（仓库号，面积，电话号） 三个或三个以上实体间的一个多元联系可以转换为一个关系模式： 供应（供应商号，项目号，零件号，供应量） 一个 1：n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并 职工（职工号，姓名，年龄，职称，仓库号，领导职工号） 一个 m：n 联系可以转换为一个独立的关系模式 库存（仓库号，零件号，库存量）","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"关系数据库设计理论","slug":"数据库/5-关系数据库设计理论","date":"2020-03-25T14:02:45.000Z","updated":"2020-09-04T15:50:47.354Z","comments":true,"path":"2020/03/25/数据库/5-关系数据库设计理论/","link":"","permalink":"https://aaronyard.github.io/2020/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/5-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/","excerpt":"针对一个具体问题，应该如何构造一个适合于它的数据库模式呢？ 一、异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 不符合范式的关系，会产生很多异常，主要有以下四种异常：","text":"针对一个具体问题，应该如何构造一个适合于它的数据库模式呢？ 一、异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 不符合范式的关系，会产生很多异常，主要有以下四种异常： 数据冗余：例如 学生 -2 出现了两次。 更新异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 数据依赖是一个关系内部属性和属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间的相关联系。其中最重要的是函数依赖和多值依赖。 一个模式的数据依赖会有哪些不好的性质，如何改造一个不好的模式，这就是规范化要讨论的内容 二、规范化1. 规范化的目的 关系数据库进行规范化的目的：使结构更合理，解决数据中可能出现的异常情况（比如数据冗余、更新异常、删除异常、插入异常），从而增强数据的稳定性和灵活性 关系模式进行规范化的原则：遵从概念单一化“一事一地”原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。 关系模式进行规范化的方法：将关系模式投影分解成两个或两个以上的关系模式。 2. 函数依赖（functional dependency，FD）① 概念记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 在一个关系中，任意元组，若属性 A1,A2….An 一样，则属性 B1,B2…Bm 必一样，那么称 A1,A2…An 函数决定 B1,B2…Bm。 记号为 A1,A2...An → B1,B2...Bm Ai与Bi有函数依赖） 如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小集合，那么该集合就称为 键码。 对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A&#39;-&gt; B，那么 A-&gt;B 就是 部分函数依赖，否则就是 完全函数依赖。 对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。 ② 范式理论关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。 范式理论是为了解决以上提到四种异常。 高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。 一个低一级的范式的关系模式通过模式分解可以转换为若干个高一级的关系模式的集合，这个过程就叫 规范化（normalization） Ⅰ 第一范式 (1NF)定义： 属性不可分。可以认为任何表都属于第一范式，因为每个表的最小单位为表中的各个属性。 Ⅱ 第二范式 (2NF)定义： 在满足第一范式前提下，在所有函数依赖表达式中，不存在 任何 候选键的真子集 决定 非主属性。即消除 非主属性 对于 主键 的 部分依赖，使得非主属性完全依赖于主键 一个关系模式不符合2NF定义，会导致如下问题 插入异常 删除异常 修改复杂 实例： 有关系模式 S-L-C（Sno,Cno,Sdept,Sloc,Grade)，其中Sloc为学生住处，并且每个系的学生住在同一个地方。则函数依赖有 （Sno,Cno) — F —&gt; Grade Sno ——&gt; Sdept，(Sno, Cno) — P —&gt; Sdept Sno ——&gt; Sloc，(Sno, Cno) — P —&gt; Sloc Sdept ——&gt; Sloc 函数依赖关系图如图所示 非主属性Sdept、Sloc并不完全函数依赖于主键/码，因此不符合2NF定义 解决的办法是用 投影 分解原先的关系模式 S-L-C（Sno,Cno,Sdept,Sloc,Grade)，分解为： SC(Sno, Cno, Grade) S-L(Sno, Sdept, Sloc) 这样就使得非主属性对主键是完全函数依赖了，满足第二范式 Ⅲ 第三范式（3NF）定义: 在满足第二范式前提下，在所有函数依赖表达式中，所有 非主属性 不传递依赖于 候选键，这里 A → B ， B → C 则称 C 传递依赖于 A 一个关系模式不符合3NF定义，会导致如下问题(同2NF) 插入异常 删除异常 修改复杂 实例： 在上面的实例关系模式 S-L(Sno, Sdept, Sloc) 中存在传递依赖，Sno ——&gt; Sdept, Sdept——&gt; Sloc, Sloc传递依赖于Sno 解决的方法同样是投影分解，将 S-L 分解为 S-D (Sno, Sdept) D-L (Sdept, Sloc) 分解后的关系模式 S-D 和 D-L 中不再存在传递依赖，满足第三范式3NF Ⅳ 修正的第三范式（BCNF）定义：在满足第二范式的条件下，消除所有属性对主属性的传递依赖。即如果一个属性/属性组 A 决定其他属性/属性组B，则 A 必须包含主键 关系模式 R 属于 3NF，但 R 不一定属于 BCNF 下面给出几个例子说明属于3NF的关系模式有的属于BCNF，有的不属于BCNF 实例： 关系模式C(Cno, Cname , Pcno)，他只有一个码Cno，且没有任何属性对Cno部分依赖或传递依赖，C属于3NF，同时C中Cno是唯一决定因素，所以C属于BCNF 有如下函数依赖：(S，J) —&gt; T，(S，J) —&gt; J，T —&gt; J。这里的(S，J) (S，J) 都是主码 该关系模式是 3NF，因为没有任何非主属性对主码传递依赖； 不是 BCNF，因为 T 作为决定因素（T 决定 J）但是并不包含主码。 3. 多值依赖① 概念以上完全是在函数依赖的范畴内讨论问题，属于BCNF的关系模式是否就很完美了呢？下面来看一个例子 ② 范式理论Ⅰ 4NF4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖 4. 规范化总结规范化的思想是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的分离。 三、关系数据库设计习题设有关系模式 R(A,B,C,D,E,F),其函数依赖集为： F={E→D, C→B, CE→F, B→A}. 请回答如下问题： 指出R的所有候选键并说明原因； 按照上述函数依赖画出下述函数依赖图 得出：（C, E) 为唯一的候选键，因为只需要这两个元素就可以唯一的确定所有元素 R最高属于第几范式,为什么? 第三范式需要满足无传递依赖，显示不属于第三范式； 第二范式需要满足无部分函数依赖，E——&gt;D，(C, E) —P—&gt; D, D部分依赖于主键（C，E)，所以不属于第二范式； 所以R属于第一范式 分解R为3NF. 1NF ——&gt; 2NF 消除部分函数依赖 R1(C，E，B，A，F) + R2(E，D) 2NF ——&gt;3NF 消除传递函数依赖 分解为 R3(C, E, F, B) + R4 (B, A) + R2 (E，D)","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库安全性和完整性","slug":"数据库/4-数据库安全性和完整性","date":"2020-03-24T14:02:45.000Z","updated":"2020-09-04T15:50:50.120Z","comments":true,"path":"2020/03/24/数据库/4-数据库安全性和完整性/","link":"","permalink":"https://aaronyard.github.io/2020/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7/","excerpt":"一、数据库安全性1. 什么是数据库的安全性数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。 对数据安全性产生威胁的因素主要有以下几个方面 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全环境的脆弱性 2. 数据库安全性控制","text":"一、数据库安全性1. 什么是数据库的安全性数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。 对数据安全性产生威胁的因素主要有以下几个方面 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全环境的脆弱性 2. 数据库安全性控制 数据库有关的安全性控制主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等技术 ① 用户身份鉴别用户身份鉴别是数据库管理系统提供的最外层安全保护措施，每个用户在系统中都有一个用户标识，每个用户标识由用户名和用户标识号UID两部分组成。UID在系统的整个生命周期中是唯一的。系统内部记录着所有合法用户的标识。 每个用户要求进入系统时，由系统进行核对，通过鉴定后才提供使用数据库管理系统的权限。 用户身份鉴别的方法主要有以下几种： 静态口令鉴别 静态口令一般由用户自己设定，鉴别使输入正确口令即可获得权限 动态口令鉴别 每次鉴别时均需使用动态产生的新口令登录数据库管理系统。比如短信验证码登录 生物特征鉴别 比如指纹、虹膜鉴别 智能卡鉴别 智能卡由用户随身携带，插入专用的读卡器进行身份验证 ② 存取控制数据库安全最重要的一点就是确保只能有资格的用户授予访问权限，这主要通过存取控制机制实现。存取控制机制主要包括定义用户权限和合法权限检查两部分 权限授予和收回 GRANT 授予权限 不允许循环授权，即被授权者不能把权限再授回授权者或者其祖先 示例： 1234567891011121314151617181920# 把查询Student表的权限授给用户User1，并允许他将此权限授予其他用户grant selecton table Studentto User1with grant option;# 把对Student表和Cource表的全部操作权限授予用户User2和User3grant all privilegeson table Student,Courceto User2,User3;# 把对表SC的查询权限授予所有用户grant selecton table SCto public;# 把查询Student表和修改学生学号的权限授予用户User4grant update(Sno),selecton table Studentto User4; REVOKE 收回权限 123456789# 收回Uer4修改学生学号的权限revoke update(Sno)on table Studentfrom Uer4;# 收回用户User1对Student表的查询权限，并级联收回User1授予的其他用户的该权限revoke selecton table Studentfrom User1 CASCADE; ③ 视图机制还可以为不同的用户定义不同的视图，把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。 示例： 1234567891011121314# 建立计算机学生的视图，并把对该视图的select权限授予User1,对该视图的所有操作权限授予User2create view CS_Studentasselect *from Studentwhere Sdept = 'CS';grant selecton CS_Studentto User1;grant all privilegeson CS_Studentto User2; ###④ 审计 / 跟踪审查 审计功能把用户对数据库的所有操作自动记录下来放入审计日志（audit log)中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等 AUDIT 设置审计功能 123# 对修改Student表结构和修改Student表数据的操作进行审计AUDIT alter,updateon Student; NOAUDIT 取消审计功能 123# 取消取Student 表的一切审计noaudit alter,updateon Student; ⑤ 数据加密加密的基本思想是根据一定的算法原始数据——明文（plain text) 变换为不可直接识别的格式——密文（cipher text），从而使得不知道解密算法的人无法获知数据的内容。 二、数据库完整性1. 什么是数据库的完整性数据的完整性是指数据的正确性和相容性。 数据的正确性：数据是符合现实世界语义，反映当前实际状况的 数据的相容性：数据库同一对象在不同关系表中的数据是符合逻辑的 例如：学生的学号必须唯一，性别只能是男或女等等 为了维护数据库的完整性，DBMS必须提供如下功能 提供定义完整性约束条件的机制 提供完整性检查的方法 进行违约处理 2. 数据库完整性和安全性的区别 数据的完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。 因此完整性检查和控制的防范对象是不合语义的、不正确的数据，防止它们进入数据库； 数据的安全性是保护数据库防止恶意破坏和非法存取。 因此安全性控制的防范对象是非法用户和非法操作，防止他们对数据库数据的非法存取 3. 实体完整性主键必须存在且不为空 ① 定义实体完整性12345create table Student( Sno char(9) primary key, Sname char(20) not null, Ssex char(2)); 1234567# 将SC表中的Sno,Cno属性组定义为主键create table SC( Sno char(9) not null, Cno char(9) not null, Grade smallint, primary key(Sno,Cno)); ② 实体完整性检查和违约处理 检查主键是否唯一，如果不唯一则拒绝插入或修改 检查主键的各个属性是否为空，只要有一个为空则拒绝插入或修改 4. 参照完整性外键要么不存在，要么存在就不为空 ① 定义参照完整性12345678create table SC( Sno char(9) not null, Cno char(9) not null, Grade smallint, primary key (Sno,Cno), foreign key(Sno) references Student(Sno), foreign key(Cno) references Cource(Cno)); ②参照完整性检查和违约处理 当上述的不一致发生时，系统可以采用以下策略 拒绝执行 NO ATION：默认策略 级联操作 CASCADE 当删除或修改被参照表的一个元组导致与参照表的不一致时，删除或修改参照表中的所有导致不一致的元组。 例如：删除Student表中001学生，则SC表中关于001的记录也全部删除 设置为空值 当删除或修改被参照表的一个元组导致与参照表的不一致时，将不一致的属性设置为空值 5. 用户自定义完整性① 属性上的约束条件当不满足属性约束条件的时候，操作将被拒绝执行 不允许空值 1234create table SC( Sno char(9) not null, ...); 列值唯一 12345create table Dept( Deptno numeric(2), Dname char(9) unique not null, //列值唯一且不能为空 ...); 用check 短语指定列值应该满足的条件 123456create table Student( Sno char(9) primary key, Ssex char(2) check(Ssex in('男','女')), //性别属性只能取男或女 Grade smallint check(Grade &gt;= 0 and Grade &lt;= 100), //分数属性只能取值0-100 ...); ② 元组上的约束条件元组级的约束可以设置不同属性之间的相互约束条件。 当不满足这些约束条件的时候，操作将被拒绝执行 123456create table Student( Sno char(9), Sname char(9) not null, primary key(Sno), check(Ssex = '女' or Sname not like 'Ms.%') //性别是女或者名字不以MS.%开头则可以通过check检查); 6. 命名完整性约束 Constraint① 完整性约束命名constraint 命名完整性约束，方便增加和删除一个完整性约束条件 格式：constrain 完整性约束条件名 完整性约束条件 完整性约束条件包括 not null unique primary key foreign key check 示例 123456789create table Student( Sno numberic(9) constraint c1 check (Sno between 100-1000), Sname char(9) constraint c2 not null, Sage numeric(3) constraint c3 check(Sage &lt; 30), constrain StudentKey primary key(Sno) ); ② 修改表中的完整性约束1234567# 去除对年龄小于30的约束alter table Student drop constraint c3;# 添加年龄小于40的约束alter table Student add constraint c4 check(Sage &lt; 40); 7. 断言 ASSERTION关键词：ASSERTION 任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行 示例： 1234567# 限制数据库课程最多60名学生选修create assertion asse_sc_db_num check (60 &gt;= (select count(*) from Cource,SC where SC.Cno = Cource.Cno and Couce.Cname = '数据库') ); 8. 触发器 Trigger触发器是用户定义在关系表上的一类由事件驱动的特殊过程 ① 创建触发器触发器仅限于数据库中增 删 改三种操作 触发器定义如下： 1234567create trigger 触发器名 before/after 触发事件 /*指明触发器的激活时间*/ on 表名 /*触发器只能定义在基本表上，不能定义在视图上*/ [referencing 引用名] 可选的 for each row/statement /*定义触发器的类型，指明动作体执行的频率*/ when SQL语句 动作 before/after：触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。 触发事件： insert：触发器包含一个名为 NEW 的虚拟表。 delete ：触发器包含一个名为 OLD 的虚拟表，并且是只读的。 update：触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。 也可以是 update of &lt; 触发列名1，触发列名2 ... &gt; 引用名： 触发器事件既然是数据库更新操作，这些操作的执行势必会引起数据库中某些值的改变，即由旧值变成新值，这些新旧值称为过渡值。在触发器的条件和动作中可以引用这些过渡值 OLD【ROW】AS 旧元组别名 （row旧元组名是可选的） NEW【ROW】AS 新元组别名 OLD TABLE AS 旧表别名 NEW TABLE AS 旧表别名 触发器类型： for each row：行级触发器 for each statement : 语句级触发器 比如修改一个Teacher表中的deptno字段（一共1000条记录） update teacher set deptno = 5; 若是行级触发器，update后触发动作执行一次 若是语句级触发器，触发动作将执行1000次 示例： cource表中删除一个元组，若该元组的主键是sc表中的外键，则卷回删除该元组的操作。 1234567CREATE TRIGGER mytrigger BEFORE DELETE ON cource referencing old as o for each rowwhen (exists (select * from sc where cno = o.cno))ROLLBACK; ② 删除触发器1DROP TRIGGER 触发器名 ③ 触发器实现参照完整性比如有三个表：student（学生表），cource（课程表），sc（选修表），其中sc定义了两个外键sno和cno以及其完整性约束，试写出触发器实现该参照完整性约束的规则 首先分析：有哪些操作会影响到本例的完整性约束 sc 表的 insert 操作 cource 表的 delete 操作 student 表的 delete 操作 sc 表的 update（sno, cno) 操作 cource 表的 update（cno) 操作 student 表的 update（sno) 操作 对上述6中操作分别定义6条规则，实现参照完整性约束 规则1： 1234567891011create trigger referential_integrity_checkbefore insert on screferencing new as nwhen (not(exists(select * from student where sno = n.sno) and exists(select * from cource where cno = n.cno) ) )rollback; 如果 sc 表中插入元组，其外键在 student 和 cource 表中均不存在，则卷回插入该元组操作 规则2： 12345678create trigger cource_deletebefore delete on courcereferencing old as ofor each rowwhen (exists(select * from sc where o.cno = sc.cno) )rollback; 如果 cource 表中删除一个元组，若该元组是 sc 表中的外键，则卷回删除该元组的操作（此处我们假定在sc表的定义中，外键 cno 使用了 restrict 选项） 规则3： 123456789create trigger student_deletebefore delete on studentreferencing old as ofor each rowwhen(exists(select * from sc where sc.sno = o.sno) )delete from scwhere sc.sno = o.sno; 假设在 sc 表的定义中，外键 sno 的定义中采用了 cascade 选项，即当在 student 表中删除一个元组的时候，则在 sc 表中删除引用该元组主键作为外键的所有元组 规则4： 123456789101112create trigger sc_fk_updatebefore update of sno,cno on screferencing new as nfor each rowwhen(not(exists(select * from student where sno = n.sno) and exists(select * from cource where cno = n.cno) ) )rollback; 对于 sc 表的更新操作，若更新的外键 sno 或者 cno 在 student 和 cource 表中无相应的主键供其引用，则卷回更新该元组的操作 规则5： 123456789create trigger cource_cno_updatebefore update of cno on courcereferencing old as ofor each rowwhen(exists(select * from sc where sc.cno = o.cno) ) rollback; 对于 cource 表的 更新操作，在修改主键cno的同时，如果sc表中有元组正引用修改前的cno值作为外键，则卷回该操作 规则6： 12345678create trigger student_sno_updatebefore update of sno of studentreferencing old as ofor each rowwhen (exists(select * from sc where sc.sno = o.sno) )rollback; 对于 student 表的更新操作，在修改主键sno的同时，如果sc表中有元组正引用修改前的sno值作为外键，则卷回该操作","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"关系数据库标准语言SQL","slug":"数据库/3-关系数据库标准语言SQL","date":"2020-03-23T14:02:45.000Z","updated":"2020-09-04T16:01:02.885Z","comments":true,"path":"2020/03/23/数据库/3-关系数据库标准语言SQL/","link":"","permalink":"https://aaronyard.github.io/2020/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/","excerpt":"一、数据定义关系数据库系统支持三级模式结构，其模式，外模式，内模式中的基本对象有模式、表、视图和索引，所以SQL的数据定义功能包括模式定义、表定义、视图和索引的定义 1. 模式的定义与删除① 模式定义","text":"一、数据定义关系数据库系统支持三级模式结构，其模式，外模式，内模式中的基本对象有模式、表、视图和索引，所以SQL的数据定义功能包括模式定义、表定义、视图和索引的定义 1. 模式的定义与删除① 模式定义 1create schema 模式名 authorization 用户名; 示例： 为用户WANG定义一个 学生-课程 模式 S-T 1create schema \"S-T\" authorization WANG; 定义模式实际上就是定义了一个命名空间，可以在这个空间的基础上进一步定义数据库对象，基本表，视图，索引等 示例： 为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 table1 12345create schema \"TEST\" authorization ZHANGcreate table table1(col1 smallint, col2 int, col3 char(20) ); ② 删除模式1drop schema 模式名 CASCADE | RESTRICT CASCADE | RESTRICT 必选其一 CASCADE表示删除模式的同时会删除该模式下的所有数据库对象 RESTRICT 表示若该模式下存在数据库对象，则拒绝执行删除操作 2. 基本表的定义、删除、修改 数据库的创建和使用： CREATE DATABASE test;USE test; ① 定义基本表 CREATE 示例： 1234567891011121314CREATE TABLE mytable ( # int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, # int 类型，不可为空，默认值为 1，不为空 col1 INT NOT NULL DEFAULT 1, # 变长字符串类型，最长为 45 个字符，可以为空 col2 VARCHAR(45) NULL, # 日期类型，可为空 col3 DATE NULL, # 设置主键为 id PRIMARY KEY (`id`) # 定义外键,被参照表是mytable2 FOREIGN KEY(col1) REFERENCES mytable2(col1)); SQL标准支持多种数据类型： ② 修改基本表 ALTER 示例： 向Student表中添加入学时间列 1alter table student add entrance_date DATE; 将年龄的数据类型由字符型转为整数 1alter table student alter column age INT; 增加课程名称必须取唯一值的约束条件 1alter table student add unique(cname); ③ 删除基本表1DROP TABLE 表名 [RESTRICT | CASCADE]; 默认是 RESTRICT 3. 索引的建立和删除① 建议索引12create [unique][cluster] index 索引名on 表名 (列名[次序]，列名[次序]...) unique 表示此索引的每一个索引值只对应唯一的数据记录 cluster 表示该索引是聚集索引，详见 后序 面试指南 - 索引 章节相关内容 示例： 1234create unique index sno_index on student(sno);create unique index cno_index on cource(cno);# sc表按学号升序和课程号降序建立唯一索引create unique index sc_index on sc(sno asc, cno desc); ② 修改索引1alter index 旧索引名 rename to 新索引名 ③ 删除索引1drop index 索引名 4. 数据字典数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典中的相应信息 二、数据查询select 语句的一般格式： 以下所有示例全都使用下述三个表 Student(Sno,Sname, Sage, SDept) 学生表 Cource (Cno, Cname) 课程表 SC(Sno,Cno,Grade) 选修表 1. 单表查询单表查询是指仅涉及一个表的查询 ① 查询表中的若干列查询全体学生的学号和姓名 12select Sno, Snamefrom Student; 目标列表达式 也可以是表达式 12select Sname, 2020 - agefrom Student; 用户可以为查询的列定义别名 12select Sname, 2020 - age Birthdayfrom Student; ② 选择表中的若干元组消除取值重复的行 distinct使用 distinct 关键字 去除重复记录 12select distinct Snofrom SC; 查询满足条件的行使用 where 子句，常用的查询条件如下： 比较 123select snamefrom studentwhere age &lt;= 20; 确定范围 1234# 查询年龄在20-33岁之间的学生姓名和年龄select sname,agefrom studentwhere age between 20 and 33; 确定集合 1234# 查询计算机系和数据系的学生姓名和性别select sname,genderfrom studentwhere dept in ('CS','Math'); 字符匹配 1234# 查询姓欧阳且全名为三个汉字的学生的姓名select sname from studentwhere sname like '欧阳_'; 涉及空值的查询 1234# 查询所有有成绩的学生姓名select snamefrom studentwhere grade is not null; 多重条件查询 and 和 or 可用来连接多个查询条件，and 的优先级高于 or，不过可以用 括号来改变优先级 1234# 查询计算机系年龄20以下的学生姓名select sname from studentwhere sdept = 'CS' and sage &lt; 20; ③ order by 子句 desc 降序 asc 升序 默认 1234# 院系按升序排，年龄按降序排select *from studentorder by sdept,sage desc; ④ top12345678# 查询成绩第一的学生姓名select Snamefrom Studentwhere Sgrade = ( select top 1 Sgrade from Student order by Sgrade desc); 12345678910# 查询第21-30行的数据，id主键自增，但可能不连续# 先查询出前20行的数据，后查询去除这20行的10行数据select top 10 *from studentwhere id not in( select top 20 id from student order by id)order by id; ⑤ 聚集函数 函数名 功能 COUNT 对元组计数 TOTAL 求总和 MAX 求最大值 MIN 求最小值 AVG 求平均值 示例： 1234567# 查询学生总人数select count(*)from student;# 查询选修了课程的学生人数(学生每选一门可都会在选修表中有记录)select count(distinct Sno) as numbersfrom sc; 🚨 起别名 as 可写可不写 ⑥ group by 子句group by 分组：把具有相同的数据值的行放在同一组中。 分组后聚集函数将作用于每一组，即每一组都有一个聚集函数值 示例： 1234# 求各个课程号及相应的选课人数select Cno, count(Sno)from scgroup by Cno; 如果分组后还需要对这些组进行过滤，则使用 HAVING 短语 12345# 查询选修了三门以上课程的学生学号select Snofrom scgroup by snohaving count(*) &gt; 3; 1234567# 有两个表Study(sno,cno)和Student(sno,sname)，查询选修了2或3门课的学生select * from Student swhere s.sno in( select stu.sno from Studty stu group by stu.sno having count(*) &gt;= 2); WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 having 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行 WHERE 代码时，可能尚未确定列值。 where 不可以使用聚集函数。一般需用聚集函数才会用 having SQL标准要求HAVING 必须引用 GROUP BY 子句中的列或用于合计函数中的列。 ⚠ GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前 12345SELECT col, COUNT(*) AS numFROM mytablewhere col &gt; 2GROUP BY colORDER BY num; 2. 连接查询若一个查询同时涉及两个以上的表，则称为连接查询 ① 等值与非等值连接查询 示例： 1234567891011# 查序每个学生及选修课的情况select Student.*, SC.*from Student, SCwhere Student.sno = SC.sno;# 查询选修2号课程且成绩在90分以上的所有学生的学号和姓名select Student.sno,snamefrom Student,SCwhere Student.sno = SC.sno and SC.cno = 2 and SC.grade &gt; 90; ② 自身连接一个表与自己进行连接 示例： 123select FIRST.Cno,SECOND.Cpnofrom Cource FIRST, Cource Secondwhere FIRST.Cpno = SECOND.Cno; ③ 外连接保存悬浮元组（即不满足条件的元组也保存下来）上一节已经讲过 OUTER JOIN LEFT OUTER JOIN RIGHT OUTER JOIN ④ 多表连接两个以上的表进行连接 12345# 查询每个学生的学号，姓名，选修的课程名即成绩select Student.Sno,Sname,Cname,Gradefrom Student,Cource,SCwhere Student.Sno = SC.Sno AND SC.Cno = Cource.Cno; 3. 嵌套查询在 SQL 语言中，一个 select-from-where 语句称为一个查询块。 将一个查询块套在另一个查询块的 where 子句或 HAVING 短语的条件中的查询称为嵌套查询 ① 带有 in 谓词的子查询1234567# 查找与小明所在同一个系的学生select Sno,Sname,Sdeptfrom Studentwhere Sdept in (Select Sdept From Student Where Sname = \"小明\"); ② 带有比较运算符的子查询123456# 找出每个学生超过他自己选修课程平均成绩的课程号select Sno,Cnofrom SC xwhere grade &gt;= (select AVG(grade) from Sc y where y.Sno = x.Sno); ③ 带有 ANY(SOME)或 ALL 谓词的子查询子查询返回单值时可以用比较运算符，但返回多值时要用 ANY（有的系统用SOME）或 ALL 谓词修饰符。而使用ANY 或 ALL谓词时必须同时使用比较运算符。 示例： 12345678# 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄select Sname,Sagefrom Studentwhere Sage &lt; ANY(select Sage from Student where Sdept = 'CS') and Sdept &lt;&gt; ‘CS'; ④ 带有 EXISTS 谓词的子查询EXISTS 代表存在，带有该谓词的子查询不返回任何数据，只产生逻辑真值 true 或逻辑假值 false exists 引导的内层查询如果 能查出数据，则继续外层查询 not exists 引导的内层查询如果 查不出数据，则继续外层查询 exists 的查询步骤是顺序执行，并不会先做子查询，与 in 相反。 顺序执行，如果exists 的查询结果为真，则将最外层的查询结果添加进最终结果集。对外表进行循环 示例： 123456789# 查询所有选修了1号课程的学生姓名select Snamefrom Studentwhere exists( select * from SC where Sno = Student.Sno and Cno = 1); 由exists引出的子查询，其目标列表达式通常都用 * ，因为该子查询只返回 true 或 false，给出列名无实际意义 12345678910111213141516# 查询选修了全部课程的学生姓名select Snamefrom Studentwhere not exists( # 首先我们要直到一共有哪些课程 select * from Cource where not exists( # 其次，我们需要统计选修了所有课程的学生号 select * from SC where Sno = Student.Sno and Cno = Cource.Cno )); 由于没有全程量词，可将题目的意思转化为 没有一门课程是他不选修的 exists 可以理解为一个循环 12345678910for(循环从Student表拿一行学生数据)&#123; for(循环从Course表拿一行课程信息)&#123; for(循环在SC表拿一行进行比对)&#123; SC表中的这条数据判断： SC.Sno == Student.Sno ， SC.Cno == Course.Cno; /*是否SC表中的学号 = Student表中的学号 且 SC表中的Cno = Course表中的Cno*/ &#125; &#125;&#125; 12345678910111213141516171819# 查询至少选修了学生001选修的全部课程的学生号码select distinct Sno# 代表学生X的表from SC SCXwhere not exists( select * from SC SCY where SCY.Sno = '001' and not exists( select * from SC SCZ # 匹配学号 where SCZ.Sno = SCX.Sno and # 001选修了该课程 SCZ.Cno = SCY.Cno )); 翻译为：不存在这样的课程y，001选修了，而学生x没有选修 exists 和 in 的区别： 例如： select * from Awhere id in(select id from B) exists()适合B表比A表数据大的情况 当A表数据与B表数据一样大时, in与exists效率差不多,可任选一个使用. 详细可参考：👉 SQL语句中exists和in的区别 4. 集合查询select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。集合操作主要包括 并 UNION 交 INTERSECT 差 EXCEPT 参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同 1234567891011121314151617181920212223242526# 查询计算机系的学生及年龄不大于19的学生select *from Studentwhere Sdept = 'CS'UNIONselect *from Studentwhere Sage &lt;= 19;# 也可以用INTERSECTselect *from Studentwhere Sdept = 'CS'INTERSECTselect *from Studentwhere Sage &lt;= 19;# 也可以用EXCEPTselect *from Studentwhere Sdept = 'CS'EXCEPTselect *from Studentwhere Sage &gt; 19; 5. 基于派生表的查询子查询不仅可以出现在where子句中，还可以出现在子句中，这时子查询生成的临时派生表成为主查询的查询对象 (必须为派生关系置顶一个别名) 1234# 找出每个学生超过自己选修课程平均成绩的课程号select Sno,Cnofrom SC,(select Sno,AVG(Grade) from SC group by Sno) as Avg_SC(avg_sno,avg_grade); 三、数据更新1. 插入数据① 插入元组12insert into Student(Sno,Sname,Sgender,Sdept,Sage)values('123','小红','男','CS',20); 若不指出要添加的属性，则需要添加表中的所有属性 ② 插入子查询结果12345# 对每一个系，求学生的平均年龄，并把结果存入表 Dept_ageinsert into Dept_age(Sdept,Avg_age)select Sdept,AVG(Sage)from Studentgroup by Sdept; 2. 修改数据① 修改某个元组的值1234# 修改学号001的年龄update Studentset Sage = 15where Sno = '001'; ② 修改多个元组的值123# 将所有学生年龄加1岁update Stduentset Sage = Sage + 1; ③ 带子查询的修改语句12345678# 将计算机系全体学生成绩置0update Studentset Sgrade = 0where Sno in( select Sno from Student where Sdept = 'CS'); 3. 删除数据① 删除某个元组1234# 删除学号001学生记录delete from Studentwhere Sno = '001'; ② 删除多个元组123# 删除所有学生记录delete from student; ③ 带子查询的删除语句12345678# 删除计算机系所有学生的选课记录delete from SCwhere Sno in( select Sno from Student where Sdept = 'CS'); 12345678910# 删除重复数据，只保留一条记录（除id以外，其余全部相同）-- ② 删除除了分组中最小id以外的所有值，即重复数据 --delete from Studentwhere id not in( select id from( -- ① 按照除id以外的任意属性就行分组排列，并选出每个分组中的最小id -- select MIN(id) from Student group by Sname )temp); 🚨 注意： 12345delete from test where id not in( select Min(id) from test group by name); 这样写在 MySQL 中会报错， You can&#39;t specify target table for update in FROM clause 不允许使用同一表中查询的数据作为同一表的更新数据。 我们需要在select外面套上一层，让数据库认为我们不是使用同一个表的查询数据作为更新数据 四、空值的处理1. 空值的产生比如：插入语句中没有赋值的属性，其值为空值 123insert into Student(Sno,Cno)values('123','323');# 除了Sno,Cno 外其余属性就是空值 2. 空值的判断IS NULL / IS NOT NULL 1234# 查询漏填信息的学生select *from Studentwhere Sname is null or Sgender is null or Sage is null or Sdept is null; 3. 空值的约束条件 属性定义中有 NOT NULL 约束条件时不能取空值 加了 UNIQUE 限制的属性不能取空值 主键不能取空值 五、视图视图是从一个或几个基本表（或视图）导出的表。 它与基本表不同，是一个虚表。 数据库中只存放视图的定义，不存放视图对应的数据，这些数据任然存放在原来的基本表中。所以一旦基本表中的数据变化，那么视图中的数据也会相应变化。 其实视图就好像一个窗口，透过它可以看到自己想要看到的数据及其变化 1. 建立视图 ① 建立在单个表上的视图1234567# 建立计算机系学生视图，并要求插入/修改/删除操作时，保证该视图只有计算机系学生create view CS_Studentasselect *from Studentwhere Sdept = 'CS'with check option; 由于加上了 with check option 子句，以后对视图进行 修改 / 添加 / 删除 操作时，DBMS都会自动加上 Sdept = ‘CS’ 这个条件 若一个视图是从单个基本表导出的，并且只是去掉了某些行某些列，但保留了主键，则称这类视图为 行列子集视图。 上述视图 CS_Student 就是一个行列子集视图 ② 建立在多个表上的视图12345678# 建立计算机系选修了1号课程的学生的视图（包括学号，姓名，成绩）create view CS_S1(View_Sno,View_Sname,View_Grade)asselect Student.Sno,Sname,Gradefrom Student,SCwhere Student.Sno = SC.Sno and Sdept = 'CS' and SC.Cno = '1'; 由于视图的属性列中包含了两个表的同名列 Sno，所以必须在视图名后面说明视图的各个属性列名 ③ 建立在视图上的视图123456# 建立计算机系选修了1号课程 且 成绩在90分以上的学生的视图create view CS_S2asselect View_Sno,View_Sname,View_Gradefrom CS_S1where View_Grade &gt;= 90; 2. 删除视图1drop view 视图名； 若该视图上还导出了一个视图，则删除视图操作拒绝执行 或者可以使用 CASCADE进行级联删除，删除该视图和由它导出的所有视图 1drop view 视图名 CASCADE; 3. 查询视图视图的查询和表的查询是一样的 12345678910111213# 建立计算机系学生视图，并要求插入/修改/删除操作时，保证该视图只有计算机系学生create view CS_Studentasselect *from Studentwhere Sdept = 'CS'with check option;# 查询选修了1号课程的计算机系学生select CS_Student.Sno,Snamefrom CS_Student,SCwhere CS_Student.Sno = SC.Sno and SC.Cno = '1'; 4. 更新视图更新视图和更新表操作基本一致，不过有些时候视图是不允许更新的 5. 视图的优点 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定数据的逻辑独立性 数据的逻辑独立性是指当数据库数据库构造时，如增加新的关系或对原来关系增加新的字段等，用户的应用程序不会受到影响 视图能够对机密数据提供安全保护 适当利用视图可以更清晰的表达查询 6. 视图的缺点 查询视图时，必须把对视图的查询转化为对基本表的查询。如果这个视图是由一个复杂的多表查询所定义，那么即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。 当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改，如果视图涉及多个表的话，由于完整性约束，可能是无法修改的 六、SQL语句综合习题有如下四个表： 供应商表 S（Sno,Sname, Status, City） 零件表 P （Pno,Pname,Color,Weight） 工程项目表 J (Jno,Jname,City) 供应情况表 SPJ (Sno,Pno,Jno,Qty) 找出所有供应商姓名和所在城市 12select Sname,City from S; 找出所有零件的名称、颜色、重量 12select Pname,Color,Weightfrom P; 找出使用供应商S1所供应零件的工程号码 123select distinct Jnofrom SPJwhere Sno = 'S1'; 找出工程项目J2使用的各种零件的名称及其数量 1234select P.Pname,SPJ.QTYfrom SPJ,Pwhere SPJ.Pno = P.Pno and SPJ.Jno = 'J2'; 找出上海厂商供应的所有零件号码 1234select Pno from SPJ,Swhere SPJ.Sno = S.Sno and S.City = '上海'; 找出使用上海产的零件的工程名称 12345select Jnamefrom SPJ,S,Jwhere S.Sno = SPJ.Sno and J.Jno = SPJ.Jno and S.City = '上海'; 找出没有使用天津产的零件的工程号码 12345678select distinct Jnofrom SPJwhere Jno not in( select distinct Jno from SPJ,S where SPJ.Sno = S.Sno and S.City = '天津'); 把全部红色零件的颜色改成蓝色 123update Pset Color = '蓝色'where Color = '红色'; 由S5供给J4的零件P6改为由S3供应 12345Update SPJset Sno = 'S3'where Sno = 'S5' and Jno = 'J4' and Pno = 'P6'; 从供应商中删除供应商号是S2的记录，并从供应关系中删除相应的记录 12345delete from Swhere Sno = 'S2';delete from SPJwhere Sno = 'S2'; 请将(S2，J6，P4，200)插入供应情况关系 12insert into SPJvalues(S2,J6,P4,200);","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"关系数据库","slug":"数据库/2-关系数据库","date":"2020-03-22T14:02:45.000Z","updated":"2020-09-04T15:50:57.078Z","comments":true,"path":"2020/03/22/数据库/2-关系数据库/","link":"","permalink":"https://aaronyard.github.io/2020/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"一、关系关系模型的数据结构非常简单，只包含单一的数据结构 —— 关系。在用户看来，关系模型中的数据的逻辑结构是一张扁平的二维表 相关概念：（上一节已经给出了一些概念） 1. 域 domain域是一组相同数据类型的值的集合 比如人的年龄 1 - 120 岁","text":"一、关系关系模型的数据结构非常简单，只包含单一的数据结构 —— 关系。在用户看来，关系模型中的数据的逻辑结构是一张扁平的二维表 相关概念：（上一节已经给出了一些概念） 1. 域 domain域是一组相同数据类型的值的集合 比如人的年龄 1 - 120 岁 2. 笛卡尔积 cartesian product笛卡尔积是域上的一种集合运算 定义有点晦涩，看下面一个例子就懂了 3. 关系学生（学号，姓名，年级）就是一个关系 如果只有一个属性，则称为单元关系/一元关系 如果有2个属性，则称为二元关系 若关系中的某一属性组的值能够唯一的标识一个元组（注意其子集是不能的），则称该属性组称为候选码 / 候选键 / 键。 如果一个关系有多个候选码，则选定其中一个作为主码 / 主键 候选码的各个属性称为主属性，不包含在主属性中的其他属性称为非主属性/非码属性 常在主键的主属性下加下划线，以标出主键 如果关系中的属性或属性组不是本关系的键，而是引用其他关系或本关系的键，则称为外键 二、关系的完整性关系模型的完整性规则是对关系的某种约束条件。任何关系在任何时刻都要满足这些语义约束 实体完整性 参照/引用完整性 用户自定义完整性 1. 实体完整性关系数据库中的每个元组应该是可区分的、唯一的。这样的约束条件用实体完整性来保证 实体完整性规则：每个关系都应有至少一个主属性，且主属性不能为空值 例如：选修（学号，课程号，成绩）关系中，学号和课程号不能为空值 2. 参照/引用完整性参照完整性规则：外键要么是空缺的，要么是引用实际存在的主键值 3. 用户自定义完整性任何关系数据库系统都应支持实体完整性和参照完整性。除此之外，用户还可以自定义完整性约束。 三、关系代数关系代数是抽象的查询语言，它用对关系的运算来表达查询。 关系代数的运算对象是关系，运算结果亦是关系 关系代数用到的运算符包括两类：集合运算符和专门的关系运算符 1. 传统的集合运算传统的集合运算是二目运算，包括并、差、交、笛卡尔积 4 种运算 ① 并 unionR U S = {t | t ∈ R V t ∈ S} ② 差 except ③ 交 intersection ④ 笛卡尔积 cartesian product 综合示例 2. 专门的关系运算符专门的关系运算包括选择、投影、连接、除运算等 ① 选择 selection选择元组 示例：查询学生表Student中年龄小于20岁的学生的所有信息 1σ age&lt;20 (Student) ② 投影 projection选择列 ⚠ 注意：投影操作会去除列中的重复行 示例：查询学生表Student中都有哪些系 1Ⅱ Sdept (Student) ③ 连接 join连接也称 θ 连接。从两个关系的笛卡尔积中选取属性间满足一定条件的元组 连接运算中有两种常用连接： 等值连接：θ 为 = 的连接运算称为等值连接。他是从关系R与S的笛卡尔积中选取A、B 属性值相等的那些元组 自然连接：自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉 示例： 在做自然连接的时候，两个关系中的某些元组可能会被抛弃，这些被舍弃的元组就称为悬浮元组。 如果要把悬浮元组也留在结果中，而在其他属性上填NULL，那么这种连接就叫做外连接 outer join 左外连接 left join：只保留左表的悬浮元组 右外连接 right join：只保留右表的悬浮元组 ④ 除运算R ÷ S = T 表示 T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与 S 的元组的 所有组合 都在 R中 示例：可以理解为在R中查找B、C属性和S中的B、C属性相同的，A属性的值 T中包含所有在R但不在S中的属性及其值 A在R中而不在S中，所以保留A属性，去掉 B、C、D三个属性 且T的元组和S的元组的所有组合都在R中 a1: a1 b1 c2 / a1 b2 c1 / a1 b2 c3 都在 R中 a2 : a2 b1 c2 不在 R 中 PASS! a3：a3 b1 c2 不在 R 中 PASS! a4：a4 b1 c2 不在 R 中 PASS！ 3. 关系代数习题① 设有如下四个表：S（供应商表）P（零件表）J（工程项目表）SPJ（供应情况表） ② 设有如图所示的关系S、SC 和 C, 试用关系代数表达式表示下列查询语句: 检索”程军”老师所授课的课程号(C#)和课程名(CNAME) ⅡC#,CNAME (σ TEACHER = ‘程军’(C) ) 检索年龄大于21的男学生学号(S#)和姓名(SNAME) ⅡS#,SNAME (σ AGE &gt; ‘21’ ∧ SEX = ‘男’(S) ) 检索至少选修”程军”老师所授全部课程的学生姓名(SNAME) 关键字：至少 —— 用除法 ⅡSNAME ( ( ⅡS#,C#(SC) ÷ ⅡC#(σ TEACHER = ‘程军’(C)) ) ⚮ S ) 检索”李强”同学不学课程的课程号(C#) 关键字：不 —— 用减法 ⅡC#(C) - ⅡC#( σSNAME = ‘李强’(S) ⚮ SC ) 检索全部学生都选修的课程的课程号(C#)和课程名(CNAME) ⅡC#,CNAME(ⅡS#,C#(SC) ÷ ⅡS#(S) ⚮ C ) 检索选修课程包含”程军”老师所授课程之一的学生学号(S#) ⅡS#(σTEACHER = ‘程军’(C) ⚮ SC) 检索选修课程号为k1和k5的学生学号(S#) ⅡS#,C#(SC) ÷ ⅡC#(σ C#=k1 ∨ C# = k2(C)) 检索选修全部课程的学生姓名(SNAME) 关键字：全部 —— 用除法 ⅡSNAME( ( ⅡS#,C#(SC) ÷ ⅡC#(C) ) ⚮ S) 检索选修课程包含学号为2的学生所选修的全部课程的学生学号(S#) ⅡS#,C#(SC) ÷ ⅡC#(σ S# = 2(SC) ) 所有学号, 课程号 ÷ 学号为2的学生选修的课程号 检索选修课程名为’C语言’的学生学号(S#)和姓名(SNAME) ⅡS#,SNAME(ⅡS#( SC ⚮ (σCNAME = ‘C语言’(C)) ) ⚮ S) 检索没有一门课程成绩不及格的学生学号、姓名 ⅡS#,SNAME( (ⅡS#(S) - ⅡS#(σ GRADE &lt; 60(SC) ) ⚮ S )","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库系统概述","slug":"数据库/1-数据库系统概述","date":"2020-03-21T14:02:45.000Z","updated":"2020-09-04T15:50:16.856Z","comments":true,"path":"2020/03/21/数据库/1-数据库系统概述/","link":"","permalink":"https://aaronyard.github.io/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"一、 数据库的四个基本概念 数据 data 数据库 DataBase / DB 数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统 DataBase Management System / DBMS DBMS 是位于用户和操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。","text":"一、 数据库的四个基本概念 数据 data 数据库 DataBase / DB 数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统 DataBase Management System / DBMS DBMS 是位于用户和操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。 数据管理系统的主要任务就是科学的组织和存储数据，高效的维护和获取数据 主要功能如下： 数据定义功能 DBMS提供数据定义语言（DDL），用户通过它可以方便的对数据库中的数据对象的组成和结构进行定义 数据组织，存储和管理 数据操作功能 DBMS 还提供数据操作语言（DML），用户可以使用它操纵数据，实现CRUD 数据库的事务管理和运行管理 保证事务的正确性，保证数据的安全性、完整性、多用户对数据的并发使用以及发生故障后的系统恢复 数据库的建立和维护功能 其他功能 二、数据库系统的特点 数据结构化 数据库的主要特征之一，也是数据库系统与文件系统的本质区别 数据的共享性高、冗余度低且易扩充 数据独立性高 数据由数据管理系统统一管理和控制 DBMS提供以下几方面的数据控制功能 数据的安全性保护 数据的完整性检查 并发控制 数据库恢复：DBMS必须具有将数据库从错误状态恢复到某一正确状态的功能 ​ 三、数据模型数据模型是对现实世界数据特征的抽象。也就是说数据模型是用来描述数据、组织数据和对数据进行操作的 1. 两类数据模型根据模型应用的目的不同，可以将模型划分为两大类：概念模型、逻辑模型和物理模型 ① 概念模型按用户的观点对数据和信息建模，主要用于数据库设计 涉及的概念： 实体 entity：客观存在并可相互区别的事物，比如一个学生，一门课，学生的一次选课 属性：实体所具有的特性，比如学生的身高 码：唯一标识实体的属性集，比如学生的学号 实体型： 实体名+属性名，比如 学生（学号，姓名，性别）就是一个实体型 实体集：同一类型的实体的集合，比如全体学生 联系 relationship：实体之间的联系（有一对一，一对多，多对多等多种类型），实体之间的联系可用 E-R 图 表示，见 【六】数据库设计之E-R图 ② 逻辑模型和物理模型按计算机系统的观点进行建模，主要用于数据库管理系统的实现 层次模型 网状模型 关系模型 面向对象数据模型 对象关系数据模型 半结构化数据模型 2. 关系模型关系模型是最重要的一种数据模型。 从用户观点来看，关系模型由一组关系组成，每个关系的数据结构是一张规范化的二维表 关系模型相关的术语： 关系：一个关系对应一张表 元组 tuple : 表中的一行即一个元组 属性 attribute : 表中的一个列名即一个属性 码 key ：表中的某个属性组，可以唯一确定一个元组，该属性组就称为码。比如上表中的学号就就是该关系的码 域 domain：域是一组具有相同数据类型的值的集合。比如人的年龄是1-120岁，属性的取值范围来自该属性对应的域 关系模式：对关系的描述，一般表示为 关系名（属性名1，属性名2….）。比如学生（学号，姓名，年龄，性别，年纪）。关系模式必须是规范化的，不允许表中还有表，每个属性都应该是不可分的 四、数据库系统的三级模式结构 内模式 模式 外模式 1. 内模式内模式也称存储模式，一个数据库中只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式 2. 模式模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图 3. 外模式外模式也称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 外模式通常是模式的子集，一个模式可以有多个外模式 如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式的描述就是不同的。 外模式是保证数据库安全的一个有力措施。每个用户只能看见和访问对应的外模式中的数据，数据库的其余数据是不可见的。 五、数据库系统的组成 硬件平台及数据库 软件 人员","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据结构面试指南","slug":"数据结构/数据结构面试指南","date":"2020-03-19T14:02:45.000Z","updated":"2020-09-04T15:49:51.767Z","comments":true,"path":"2020/03/19/数据结构/数据结构面试指南/","link":"","permalink":"https://aaronyard.github.io/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"一、基本概念1. 什么是数据结构简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。 2. 数据结构三要素逻辑结构：数据元素之间的逻辑关系","text":"一、基本概念1. 什么是数据结构简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。 2. 数据结构三要素逻辑结构：数据元素之间的逻辑关系 线性结构（一对一关系）：线性表、栈、队列 非线性结构（一对多关系）：树、图、集合 存储结构（物理结构）：数据结构在计算机中的表示，是用计算机语言实现的逻辑结构 顺序存储 链式存储 索引存储 散列存储 数据的运算：施加在数据上的运算，包括运算的定义和实现。运算的定义针对逻辑结构，运算的实现针对存储结构。 3. 什么是算法算法是对特定问题求解步骤的一种描述，它是指令的有限序列。 算法的5个重要特性： 有穷性：一个算法必须在执行有穷步之后结束，且每一步都在有限时间内完成 确定性：算法中的每条指令必须有确切的含义，不会产生二义性 可行性：算法中描述的操作都是通过已经实现的基本运算执行有限次来实现的 输入：一个算法有零个或多个输入（可以没有输入） 输出：一个算法有一个或多个输出（至少存在一个输出） 4. 算法效率的度量 时间复杂度 一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 T(n)，n 表示问题的规模，T(n) 是问题规模的函数。时间复杂度 = T(n) 的数量级 空间复杂度 该算法耗费的存储空间 5. 数据结构和算法之间的关系算法是对特定问题的求解步骤，在计算机中表现为指令的有穷序列。 算法 + 数据结构 = 程序。 算法只有在合适的数据结构中才能发挥作用，数据结构的不同，会影响算法的选择和效率。 二、线性表1. 数组/顺序表和链表的区别从逻辑结构上来看 数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费 链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。 从内存存储的角度看 数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小； 链表从堆中分配空间，自由度大但是申请管理比较麻烦。 从访问方式类看 数组在内存中是连续的存储，逻辑上相邻，物理位置也相邻，因此可以实现随机存取，利用下标索引进行访问； 链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。 2. 相关算法题 顺序表相关算法 链表相关算法 三、栈和队列1. 栈和队列的区别 队列先进先出，栈先进后出。 对插入和删除操作的”限定”不同。 栈是限定只能在表的同一端进行插入和删除操作的线性表。 队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 遍历数据速度不同。 栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。 队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多 2. 什么是队列的假上溢现象，如何解决队列从队尾入队，从队头出队。 每次出队队头指针+1，当队头指针 = maxnum 时，出现假溢出现象。即队列中尚有足够的空间，但元素确不能入队。 解决方法： 建立一个足够大的存储空间以避免溢出，但这样做空间使用率低，浪费存储空间 移动元素：每当出队一个元素，就将移动队列中所有的已有元素向队头移动一个位置 循环队列：将队头和队尾看作是一个首尾相接的循环队列 3. 循环队列的优缺点 循环队列的优点： 可以有效的利用资源。用数组实现队列时，如果不移动，随着数据的不断读写，会出现假满队列的情况。即尾数组已满但头数组还是空的；循环队列也是一种数组，只是它在逻辑上把数组的头和尾相连，形成循环队列，当数组尾满的时候，要判断数组头是否为空，不为空继续存放数据。 循环队列的缺点： 循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件front == rear来判别队列是”空”是”满”。 解决这个问题有两个办法： 增加一个参数，用来记录数组中当前元素的个数； 第二个办法是，少用一个存储空间，也就是数组的最后一个存数空间不用，当（rear+1）%maxsize=front 时，队列满 这也就是为什么循环队列的顺序表中要空一个位置（用来区分队列空和队列满）。 4. 堆和栈的区别首先：讨论的堆和栈是内存中的 堆区 和 栈区，而不是数据结构中的堆和栈 C++中的内存区域分为5个区：堆区、栈区、全局/静态存储区、常量存储区、代码程序区 栈（stack）：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限。 堆（heap）：由程序员控制内存的分配和释放的存储区，是不连续的存储空间，堆的分配(new)和释放(delete)有程序员控制，容易造成二次删除和内存泄漏，堆的分配方式类似于链表 123void fun()&#123; int *p = new int[5];&#125; 在上述代码中就包含了堆和栈，看到new，我们就知道分配了一块堆内存，那么指针p呢，它分配的是一块栈内存。即在栈内存中存放了一个指向一块堆内存的指针p 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间 常量存储区（const）：存放常量字符串的存储区，只能读不能写 程序代码区：存放源程序二进制代码 了解上述知识后我们再来明确堆和栈的区别： 不同点 栈 堆 ① 管理方式不同 编译器自动分配和释放 程序员手动分配(new)和释放(delete) ② 空间大小不同 可分配的栈区内存空间较小 可分配的堆区内存较大。一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的 ③ 能否产生碎片不同 栈不存在碎片问题，因为它是严格的先进先出，在某个数据弹出之前，它上面的后进入的内容已经被全部弹出了 对于堆来说，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的内存碎片 ④地址生长方向不同 生长方向向下，向着内存地址减小的方向增长 生长方向向上，向着内存地址增加的方向增长 ⑤分配方式不同 栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配，动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 堆都是动态分配的，没有静态分配的堆。 ⑥ 分配效率不同 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 堆则是C/C++函数库提供的，它的机制是很复杂的，堆的效率比栈要低得多 四、树1. 二叉树的存储方式 顺序存储结构： 用一个数组来存储一颗二叉树，二叉树中的结点值按照编号依次存入一个一维数组中。 适用于完全二叉树，若用于一般的二叉树则会浪 费大量 存储空间。 链式存储结构： 二叉树中的每一个结点用一个链结点来存放，拥有左右孩子结点 2. 什么是堆？有什么作用？定义： 堆是一种数据结构，可以把堆看成一个完全二叉树，并且这个完全二叉树满足： 任何一个非叶节点的值都不大于（或不小于）其左右子树的结点的值。若父亲大孩子小，则为大顶堆，若 父亲小孩子大，则为小顶堆。 作用： 应用于堆排序 3. 完全二叉树若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 4. 完全二叉树的判定思路： 完全二叉树的结点编码是连续的，根据层次遍历，把所有结点依次入队，包括空结点，若空结点之后还有非空结点，就不是完全二叉树 代码： 12345678910111213141516171819202122bool isComplete(BiTree T)&#123; if(!T) return true; InitQueue(Q); BiTNode *p = T; EnQueue(Q,T); while(!isEmpty(Q))&#123; DeQueue(Q,p); if(p)&#123; EnQueue(Q,p-&gt;lchild); EnQueue(Q,p-&gt;rchild); &#125; else&#123; while(!isEmpty(Q))&#123; DeQueue(Q,p); if(p) return false; &#125; &#125; &#125; return true;&#125; 5. 二叉排序树 BST定义： 二叉排序树又称二叉搜索树，它或者是一颗空树，或者满足一下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于根节点的值； 若右子树不空，则右子树上所有结点的值均大于根节点的值； 左右子树也分别是二叉排序树。 查找过程： 若根结点的关键字值等于查找的关键字，成功。 否则，若小于根结点的关键字值，递归查左子树。 若大于根结点的关键字值，递归查右子树。 若子树为空，查找不成功。 6. 二叉排序树的判定思路：二叉排序树的中序遍历序列一定为递增序列 代码： 12345678910111213//利用中序遍历为递增bool isBST(BiTree T)&#123; if(T==NULL) return true; else&#123; bool bl = isBST(T-&gt;lchild); if(bl==false || pre&gt;T-&gt;data) return false; pre = T-&gt;data; bool br = isBST(T-&gt;rchild); return br; &#125;&#125; 7. 平衡二叉树 AVL定义：平衡二叉树又称AVL树，是一种特殊的二叉排序树，其左右子树都是平衡二叉树，且左右子树的高度差的 绝对值不超过1. 平衡因子： 左子树高度减去右子树高度的差。 平衡调整： 先找到失去平衡的最小子树，即以距离插入结点最近，且平衡因子绝对值大于 1 的结点作为为根节点的子树，分为LL,LR,RL,RR四种调节方式。 8. 平衡二叉树的判定思路：平衡二叉树的每一个结点都是平衡的，利用后序遍历按照左右根的次序依次判断是否平衡二叉树 1234567891011121314151617181920int isAVL(BiTree T,int &amp;h,int &amp;balance)&#123; int bl,br,hl,hr; //左右子树的高度和平衡性 if(T==NULL)&#123; balance = 1; h = 0; &#125; else if(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)&#123; //左右孩子均不存在 balance = 1; h = 1; &#125; else&#123; isAVL(T-&gt;lchild,hl,bl); //判定左子树 isAVL(T-&gt;rchild,hr,br); //判定右子树 h = hl&gt;hr?hl:hr; if(bl&amp;&amp;br &amp;&amp; abs(hl-hr)&lt;2) //若左右子树均平衡且高度差小于等于1 balance = 1; else balance = 0; &#125;&#125; 9. 哈夫曼树（最优二叉树）定义： 给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 构造方法： 假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 w1、w2、…、wn，则哈夫 曼树的构造规则为： 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其 左、右子树根结点权值之和； 从森林中删除选取的两棵树，并将新树加入森林； 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 特点： 权值越大的结点，距离根节点越近； 树中没有度为一的结点。 应用： 哈夫曼编码，减少编码的长度。哈夫曼编码就是长度最短的前缀编码 五、图1. 图的相关概念 图：由结点的有穷集合V和边的集合E组成。 类别：有向图和无向图。 顶点的度：出度和入度。 有向完全图和无向完全图： 若有向图有n个顶点，则最多有 n(n-1) 条边，则称为有向完全图 无向图有n个顶点，则最多有 n(n-1)/2 条边，则称为无向完全图。 路径：相邻顶点序偶所构成的序列。 简单路径：序列中的顶点不重复出现的路径。 回路：路径中第一个顶点和最后一个顶点相同的路径。 连通： 无向图中，如果Vi到Vj有路径，则称这两个顶点连通。如果图中任意两个顶点之间都连通，则称该图为连通图。 有向图中，如果 Vi 到 Vj 有路径，且反过来 Vj 到 Vi 也有路径，则称这两个顶点强连通。如果图中每一对顶点 Vi 和 Vj，从 Vi到 Vj 和 Vj 到 Vi 都有路径，则称该图为强连通图。 2. 图的存储方式 邻接矩阵：是图的顺序存储结构，用两个数组分别存储数据元素（顶点）信息和数据元素之间的关系（边/弧）的信息。一维数组存储顶点集，二维数组存储边集。图的邻接矩阵表示是唯一的，无向图的邻接矩阵是对称 的。 邻接表：是图的链式存储结构，一个单链表表示该顶点的边表；各个单链表的头指针和顶点采用顺序存储连接起来表示顶点表 十字链表：有向图的另一种链式存储结构。 邻接多重表：无向图的链式存储结构。 3. 邻接矩阵和邻接表对比 邻接矩阵 邻接表 ① 顺序存储 ① 链式存储 ② 无向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的度 ② 无向图的同一条边在邻接表中存储的两次。如果想要知道顶点的度，只需要求出所对应链表的结点个数即可。 ③ 有向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的出度（入度） ③ 有向图中每条边在邻接表中只出现一次，求顶点的出度只需要遍历所对应链表即可。求入度则需要遍历其他顶点的链表。 ④ 无向图的邻接矩阵是对称的 邻接矩阵的优点是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边。而其缺点是如果顶点之间的边比较少，会比较浪费空间，因为是一个 n∗n 的矩阵。 邻接表的优点是节省空间，只存储实际存在的边，可以方便的找出一顶点的所有领边。其缺点是求解顶点的入度时，就可能需要遍历一个链表。 4. 深度优先搜索遍历和广度优先搜索遍历的过程BFS: 类似于层次遍历 基本思想 ：利用 队列 实现。 首先访问起始顶点 V 并将其入队 V出队，并遍历V的所有邻接点 w1，w2，….，wn并依次入队 w1出队，并遍历 w1 的全部邻接点(不包括已经被访问的点) w2出队，并遍历w2的全部邻接点(不包括已经被访问的点) ……. 以此类推 DFS: 类似于先序遍历 基本思想：利用 递归/栈 实现。当不能继续向下访问时，依次回退到最近的被访问结点 首先访问顶点V，并将其标记为已访问 然后访问与顶点V的其中一个未被访问的邻接点W，并将其标记为已访问 再访问W的其中一个未被访问的邻接点，并将其标记为已访问 依次类推….. 当一个顶点所有的邻接顶点都被访问过时，则依次退回最近被访问过的顶点 图的深度遍历是否唯一 不一定唯一。因为我们可以取图中任一顶点进行深度遍历。 5. 最小生成树及相关算法最小生成树的定义： 一个包含原图中所有结点的连通图的生成树就是原图的极小连通子图，并且拥有保持图连通的最少的边。如果在最小生成树中添加一条边，必定成一个环。 N个结点的最小生成树有 N 个结点，N-1 条边。 相关算法： Prim 算法 每次都在互相连通的基础上选取相对最小的边。需保证无环 Kruscal 算法 每次选取最小的边，无须保证此过程是否连通。需保证无环 5. 最短路径及相关算法① Dijkstra 算法 该算法可以求得某一顶点到其余各顶点的最短路径。 算法思想： 设有两个顶点集合 S 和 T，其中集合 S 中存放的是图中已找到最短路径的顶点，集合 T 中存放 的是图中的剩余顶点。 初始状态时，集合 S 中只包含源点 V0，然后不断从集合 T 中选取到顶点 V0 路径最短的顶点 Vu 并加入集合 S 中，之后的路径可通过该结点 集合 S 每加入一个新的顶点 Vu，都要修改 V0 到集合 T 中各个顶点的最短路径的长度值。 不断重 复这个过程，直至集合T中的顶点全部并入到 S 中为止。 ② Floyd算法 每次都试图在路径上添加新的中间结点 7. 拓扑排序什么图可以进行拓扑排序？ 有向无环图 基本思想 ：每次去除一个入度为0的结点和该与顶结点相连的边 若图中存在一条A——&gt;B的路径，则在拓扑排序中表示B事件在A事件的后面 六、查找1. 总览 顺序结构 顺序查找 折半查找：仅适用于有序的顺序表 分块查找：索引顺序查找 树形结构 二叉排序树 平衡二叉树 B / B+ 树 红黑树 散列结构 散列表 字符串模式匹配 KMP 算法 1. 常见的哈希函数构造方法 直接定址法 H(key) = a*key + b 数字分析法 平方取中法 除留余数法 H(key) = key % p (p为不大于m的最大质数) 2. 什么是哈希冲突？处理冲突的方法散列（哈希）表： 根据关键码值(Key value)而直接进行访问的数据结构。根据给定的关键字来计算出关键字在表中的地址，以加快查找的速度。 哈希冲突：指的是多个关键字映射同一个地址的情况。 解决办法： 开放定址法 ① 线性探查法（产生堆积问题）：冲突发生时顺序查找下一个位置 ② 平方探查法（不能探查到哈希表上所有的地址，但至少能探查到一半的地址） 链地址法 所有的同义词都存储在一个线性链表中。 3. KMP 算法在一个字符串中查找是否包含目标的匹配字符串。其主要思想是每趟比较过程让子串先后滑动一个合适的位置。当发生不匹配的情况时，不是右移一位，而是移动（当前匹配的长度– 当前匹配子串的部分匹配值）位。使用一个next数组维护每个字符对应的移动位数。 4. M阶B树和M阶B+树的主要区别B/B+树一种平衡的多路查找树，一般被用在文件系统（我们常说的B树其实是叫 B- 树） B 树 M阶 B+ 树 M阶 ① 关键字个数 + 1 = 子树个数 ① 关键字个数 = 子树个数 ② 根节点至少2棵子树（1个关键字），至多M棵子树（M-1个关键字） ② 根节点至少2棵子树（2个关键字），至多M棵子树（M个关键字） ③ 除根节点的分支结点至少 M/2 取上整 棵子树（至少 M/2 取上整 - 1 个关键字），至多 M 棵子树（至多 M - 1个关键字） ③ 除根节点的分支结点至少 M/2 取上整 棵子树至少 M/2 取上整 -个关键字），至多 M 棵子树至多 M 个关键字） ④ B 树的叶节点不带任何信息，所有的信息（key，value）都存在分支结点中 ④ B+树叶子结点携带所有结点的全部信息（key，value），且按照大小顺序通过指针链接起来，分支结点仅携带索引信息（key）起索引作用。所以B+ 树的查找更稳定，因为每次都是从根节点到叶节点的查找路径 下图为 B+ 树 七、排序1. 排序算法总览① 插入排序：O(n^2) 直接插入 稳定 边查边移动。把待排序的记录按照关键字的大小逐个插入到已经排好序的有序序列中，直到所有的记录都插入完为止 折半插入 稳定 先查后移。将直接插入排序中 寻找待排记录在有序序列中的位置的方法 改为采用折半查找。 仅仅减少了查找排序的比较次数，元素的移动次数并未改变 希尔排序 不稳定 又称缩小增量排序。把记录按照下标的一定增量进行分组，对每组使用直接插入排序算法进行排序。 随着增量的减少，每组包含的关键字越来越多，当增量减为 1 时，整个序列被分为一组，算法便终止。 ② 交换排序 冒泡排序 O(n^2) 稳定 从前往后（从后往前）两两比较相邻的元素，若为逆序，则交换，直到序列比较完，最小（大）的元素浮现在末端（顶端）称为一组冒泡。 下一趟冒泡时，前一趟已经确定的最小（大）元素不再参加冒泡排序，待排序列减少一个元素。 冒泡排序在数列有序时最快，数列反序时最慢 快速排序 O(nlog2n) 不稳定 1）从数列中选取一个元素作为基准 pivot，一般选取第一个元素； 2）重新排序，比基准小的数都在基准的前面，比基准大的数都在基准的后面。一趟排序完成后，这个基准元素就位于他的最终位置了； 3）然后对基准前面子序列和后面子序列使用相同地方法进行递归排序，每趟排序都能确定一个元素的最终位置。 ③ 选择排序：不稳定 简单选择 O(n^2) 每次排序都从未排序列中选取最小元素放在相应位置，第 i 次排序即从 i - n 中选取最小元素与 A[i] 交换，一共循环 i - 1 次。 每次排序后数列都是局部有序的。 选择排序是最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。 堆排序 O(nlog2n) 1）构造堆：将无序序列构建成一个堆，根据升序降序需求决定转换成大根堆还是小根堆。（从最后一个非叶结点开始，调整该结点和他的孩子结点，然后依次从下往上进行调整，直到这个堆的父结点都大（小）于它们的孩子结点）； 2）堆排序：将堆顶元素和最后一个叶子结点进行交换，将最大（小）元素沉到数组末端，然后重新构造堆。重复这个过程直到整个序列有序 ④ 归并排序：O(nlog2n) 稳定归并的含义是将两个或两个以上的有序表合并成一个新的有序表 和选择排序一样，归并排序不受输入数据的影响，时间复杂度始终是 O(nlog2n) ⑤ 基数排序：稳定基数排序可用于比较整数。原理是将整数按照位数切割成不同的数字，然后按每个位数分别进行比较（个位数和个位数比较，十位数和十位数比较） 2. 各类排序算法对比 3. 如何选择排序算法选择排序算法准则： 一般而言，需要考虑的因素有以下四点： 设待排序元素的个数为n. 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 当n较大，内存空间允许，且要求稳定性：归并排序 当n较小，可采用直接插入或直接选择排序。 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。 简单选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序 一般不使用或不直接使用传统的冒泡排序。 基数排序：它是一种稳定的排序算法，但有一定的局限性 关键字可分解。 记录的关键字位数较少，如果密集更好 如果是数字时，最好是无符号的 4. 冒泡排序算法的改进设置一个 flag 位，用于标识这趟排序有没有发生交换，如果本趟遍历后没有发生交换，则说明元素已经有序了，则退出排序过程。 5. 快排、堆排、归并排序对比 时间复杂度：这三个排序算法平均时间复杂度都是O(nlog2n)，快排在数据有序的情况下最坏时间复杂度可达到O(n^2) 空间复杂度：归并排序需要额外的数组开销，因为需要一个辅助数组对数据进行归并排序 稳定性：快排和堆排是不稳定的，归并排序稳定 6. 堆和二叉排序树的区别 堆的特点是双亲结点的关键字必然大于（小于）该孩子结点的关键字，但这两个孩子结点的关键字没有次序规定。 中序遍历二叉树得到的结果为有序序列，而堆不一定能得到一个有序的序列。 7. 排序相关算法题 排序的相关算法","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"排序","slug":"数据结构/6-排序","date":"2020-03-17T14:02:45.000Z","updated":"2020-09-04T15:49:54.866Z","comments":true,"path":"2020/03/17/数据结构/6-排序/","link":"","permalink":"https://aaronyard.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6-%E6%8E%92%E5%BA%8F/","excerpt":"总览 一、插入排序 O(n^2)1. 直接插入排序 稳定算法思想：边查边移： 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。","text":"总览 一、插入排序 O(n^2)1. 直接插入排序 稳定算法思想：边查边移： 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。 算法图解： 具体代码：123456789101112template &lt;class T&gt;void Sort(T a[], int n)&#123; //n表示数组长度 int i,j; for(i = 1;i&lt;n;i++)&#123; if(a[i]&lt;a[i-1])&#123; T temp = a[i]; for(j = i-1; a[j]&gt;temp &amp;&amp; j&gt;=0; j--) a[j+1] = a[j]; //元素后移 a[j+1] = temp; //插入 &#125; &#125;&#125; 算法分析： 平均时间复杂度：O(n^2) 最好情况(有序) O(n) 最坏情况(逆序) O(n^2) 稳定性：稳定 2. 折半插入排序 稳定算法思想：先查后移： 将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法， 仅仅减少了查找排序的比较次数，约为O(nlog2n)，元素的移动次数并未改变，依赖于排序表的初始状态 具体代码：123456789101112131415161718void Sort(int a[], int n)&#123; //n表示数组长度 int i,j,temp; int low,high,mid; for(i = 1;i&lt;n;i++)&#123; //以第一个数a[0]为基准比较 temp = a[i]; low = 0;high = i-1; //查找 while(low&lt;=high)&#123; mid = (low+high)/2; if(a[mid]&gt;temp) high = mid-1; else low = mid+1; &#125; //后移 for(j = i-1;j&gt;=high+1;j--) a[j+1] = a[j]; a[high+1] = temp; &#125;&#125; 算法分析： 平均时间复杂度：O(n^2) 稳定性：稳定 3. 希尔排序 不稳定算法思想：又称“缩小增量排序” 把记录按下标的一定增量分组，对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 数组长度10 则增量序列一般为：5，3，1 算法图解： 具体代码：1234567891011121314void Sort(int a[], int n)&#123; //n表示数组长度 int i, j, dk, temp; for (dk = n / 2; dk &gt;= 1; dk = dk / 2)&#123; //步长为dk的直接插入排序 for (i = dk + 1; i &lt; n; i++)&#123; if(a[i-dk]&gt;a[i])&#123; temp = a[i]; for (j=i-dk; a[j]&gt;temp &amp;&amp; j&gt;=0; j=j-dk) a[j + dk] = a[j]; a[j + dk] = temp; &#125; //if &#125; &#125;&#125; 二、交换排序1. 快速排序 O(nlog2n) 不稳定算法思想： 从数列中挑出一个元素，称为 “基准”（pivot）（一般选取数列的第一个元素作为基准）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 算法图解： 具体代码：12345678910111213141516171819202122232425262728void QuickSort(int A[], int low, int high)&#123; if (low &lt; high) &#123; int pivots = Partition(A, low, high); QuickSort(A, low, pivots); QuickSort(A, pivots + 1, high); &#125;&#125;//划分算法int Partition(int A[], int low, int high)&#123; int pivots = A[low]; while (low &lt; high) &#123; //从后往前找比中轴值小的元素，若找到，则交换 // 一定要先从后往前查找，再从前往后 while (low &lt; high &amp;&amp; A[high] &gt;= pivots) high--; A[low] = A[high]; //从前往后找比中轴值大的元素,若找到,则交换 while (low &lt; high &amp;&amp; A[low] &lt;= pivots) low++; A[high] = A[low]; &#125; A[low] = pivots; return low;&#125; 算法分析 最好(划分平衡)：O(nlogn) 最坏(有序)：O(n2) 假如给定15个数，求快速排序的最多、最少比较次数 2. 冒泡排序 O(n^2) 稳定算法思想：从后往前（从前往后）两两比较相邻的元素，若为逆序，则交换，直到序列比较完，称为一趟冒泡。 下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素。 这个算法的名字由来是因为越小（大）的元素会经由交换慢慢“浮”到数列的顶端，故名。 算法图解： 具体代码：123456789101112void sort(int a[], const int size)&#123; for (int i = 0; i &lt; size - 1; i++)&#123; for (int j = 0; j &lt; size; j++)&#123; if (a[j] &gt; a[j + 1])&#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125; 算法改进1： 在第一遍排序后，最大值必定在数组最大编号的元素中；第二遍排序后，最大的两个值都在最终位置了，依次类推。所以，修改这个冒泡排序法（假设数组中有10个元素），使得在第二遍排序时比较8次，在第三遍排序时比较7次，而不是每次排序时都比较9次 1234567891011void sort2(int a[], const int size)&#123; for(int i = 0; i &lt; size-1; i++)&#123; for(int j = 0;j&lt;size-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125; 算法改进2： 如果某趟冒泡排序没有发生交换，即说明数组中的元素已经全部有序，此时无需再进行排序 12345678910111213141516void sort3(int a[], const int size)&#123; for (int i = 0; i &lt; size - 1; i++)&#123; int ifSwap = false; for (int j = 0; j &lt; size - i - 1; j++)&#123; if (a[j] &gt; a[j + 1])&#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; ifSwap = true; &#125; &#125; if(ifSwap == false) break; &#125;&#125; 算法分析： 平均时间复杂度：O(n2) 最好情况(有序) O(n) 最坏情况(逆序) O(n2) 稳定性：稳定（全局有序的） 三、选择排序 不稳定1. 简单选择排序 O(n^2)算法思想：每次排序都从未排序列选取最小元素放在第 i 个位置，第 i 次排序即从 i~n 中挑选最小元素与 A[i] 交换，一共循环 n-1 次 算法图解： 具体代码：1234567891011121314151617template&lt;class T&gt; void SortTwo(T *a, int len)&#123; int min; //记录最小值下标 for(int i = 0;i&lt;len-1;i++)&#123; min = i; //设置最小值 for(int j = i+1; j&lt;len; j++)&#123; if(a[min]&gt;a[j]) min = j; &#125; //更新最小值 if(min != i)&#123; T temp = a[min]; a[min] =a[i]; a[i] = temp; &#125; &#125;&#125; 算法分析：选择排序是最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。 元素间比较的次数与序列的初始状态无关 2. 堆排序 O(nlog2n)算法思想： a.将无序的序列构建成一个堆，根据升序降序需求选择大根堆或小根堆;（先找n/2[取下整]的分支结点，即最后一个分支结点，调整该结点和他的孩子结点，然后依次从下往上对结点数-1的结点进行调整，最后再从上往下调整检查一遍） b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 算法图解： 来个动图直观感受一下： 算法分析：时间复杂度始终为O(nlog2n) 稳定性：不稳定 四、归并排序 O(nlog2n) 稳定算法思想：归并的含义是将两个或以上的有序表组合成一个新的有序表； 以二路归并为例：两两归并，Merge()的功能是将前后相邻的两个有序表归并为一个有序表； 递归形式的二路归并是基于分治算法的； 算法图解： 具体代码：12345678910111213141516171819202122232425int *B = (int *)malloc(sizeof(int) * (n + 1)); //动态分配辅助数组Bvoid Merge(int A[], int low, int mid, int high)&#123; for (int k = low; k &lt;= high; k++) B[k] = A[k]; //将A中所有元素复制到B中 //对B两个部分依次比较，选取最小值放入A for (i = low, j = mid + 1, k = i; i &lt; mid &amp;&amp; j &lt;= high; k++) &#123; if (B[j] &lt;= B[i]) A[k] = B[i++]; else A[k] = B[j++]; &#125; while (i &lt;= mid) //若第一个表未检测完 A[k++] = B[i++]; whle(j &lt;= high) //若第二个表未检测完 A[k++] = B[j++];&#125;void MergeSort(int A[], int low, int high)&#123; int mid = (low + high) / 2; //从中间划分两个子序列 MergeSort(A, low, mid); //对左侧序列进行递归排序 MergeSort(A, mid + 1, high); //对右侧序列进行递归排序 Merge(A, low, mid, high); //归并&#125; 算法分析：和选择排序一样，归并排序不受输入数据的影响，时间复杂度始终是 O(nlog2n) 稳定性：稳定 五、基数排序 稳定算法思想：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 算法图解： 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int maxbit(int data[], int n) //辅助函数，求数据的最大位数&#123; int maxData = data[0]; ///&lt; 最大数 /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。 for (int i = 1; i &lt; n; ++i) &#123; if (maxData &lt; data[i]) maxData = data[i]; &#125; int d = 1; int p = 10; while (maxData &gt;= p) &#123; //p *= 10; // Maybe overflow maxData /= 10; ++d; &#125; return d;&#125;void radixsort(int data[], int n) //基数排序&#123; int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i &lt;= d; i++) //进行d次排序 &#123; for(j = 0; j &lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for(j = 0; j &lt; n; j++) &#123; k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; &#125; for(j = 1; j &lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中 &#123; k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; &#125; for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; &#125; delete []tmp; delete []count;&#125; 六、排序的相关算法1. 编写算法使之能在数组[1….n]中找出第K小的元素算法思想：利用快速排序的划分操作 确定pivot ，a[low] = pivot。 若low==k,则返回a[low]; 若low&gt;k,则递归查找low左边数组第k个元素； 若low&lt;k，则递归查找low右边数组第k-low个元素 1234567891011121314151617181920212223int elem_k(int a[], int low, int high, int k)&#123; int pivot = A[low]; //由于下面划分会修改low和high的值，递归的时候又需要用到他们，所以先存储起来 int low_temp = low; int high_temp = high; //下面即为快速排序的划分算法 while(low &lt; high)&#123; while(A[low] &lt; pivot) low++; A[low] = A[high]; while(A[high] &gt; pivot) high--; A[high] = A[low]; &#125; A[low] = pivot; if(low = k) return A[low]; else if(low &gt; k) return elem_k(a,low_temp,low-1,k); else return elem_k(a,low+1,high_temp,k-low);&#125; 2. 有一个仅由红，白，蓝三个颜色组成的条块序列，设计算法将红色全都排在前面，蓝色全都排在后面（荷兰国旗）算法思想：设置三个指针i，j，k，j为工作指针，顺序扫描线性表，将红色序列全都放在i指针之前，将蓝色序列全都放在k指针之后。 12345678910111213141516171819typedef enum&#123;Red,White,Blue&#125;;void FlagArrange(color a[], int n)&#123; int i = 0, j = 0, k = n-1; while(j &lt; k) switch(a[j])&#123; case Red: swap(A[i],A[j]); j ++; i ++; break; case White: j ++; break; case Blue: swap(A[j],A[k]); k --; //此处没有j++是为了防止交换后的颜色任为蓝色 &#125;&#125; case Red无须考虑交换后是否仍为红色，因为i指针后移还会遍历到该条块； 而case Blue需要考虑交换后是否为蓝色，因为k指针递减遍历不到该结点就会因为j&gt;k而退出循环 3. 双向冒泡算法算法思想：在正反两个反向交替进行扫描， 即第一趟把关键字最大的元素放在序列的最后面，第二趟把关键字最小的元素放在序列的最前面，如此反复进行。 123456789101112131415161718192021void BubbleSort(Element A[], int n)&#123; int low = 0, high = n-1; bool flag = true; while(low &lt; high &amp;&amp; flag)&#123; flag = false; for(int i=low; i&lt;high; i++)&#123; //奇数次从前向后气泡最大值 if(A[i+1]&lt;A[i])&#123; swap(A[i],A[i+1]); flag = true; &#125; &#125; high --; //修改上界 for(int j=high; j&gt;low; j--)&#123; //偶数次从后向前气泡最小值 if(A[j] &lt; A[j-1])&#123; swap(A[j],A[j-1]); flag = true; &#125; &#125; low ++; //修改下界 &#125;&#125; 4. 已知线性表按顺序存储，且每个元素都是不相同的整数型元素，设计把所有的奇数移动到偶数前边的算法算法思想：类比快速的排序的划分算法，使用交换的理念，从前往后找偶数，从后往前找奇数，找到后两者互换。 1234567891011121314void move(ElemType A[], int len)&#123; int low = 0; int high = len-1; while(low&lt;high)&#123; while(low&lt;high &amp;&amp; A[low]%2!=0) low ++; while(low&lt;high &amp;&amp; A[high]%2=0) high --; if(low&lt;high) swap(A[low],A[high]); //交换 low ++; high --; &#125;&#125; 5. 若只想得到一个序列中第k(k&gt;=5)个最小元素之前的部分排序序列，则最好采用什么排序方法最好采用堆排序。 插入排序（直接插入，折半插入，希尔排序），快速排序和归并排序只有在元素全部排完序之后，才能得到所有元素的有序序列。 冒泡排序，简单选择排序和堆排序每趟排序后都能确定一个部分有序序列。 对于堆排序，有n个元素的序列，建立初始堆的时间不超过4n,取得第k个最小元素之前的排序序列所花的时间为klog2n，总时间为4n+klog2n； 对于冒牌排序和简单选择排序，完成此功能所花时间为kn（k&gt;=5)","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"查找","slug":"数据结构/5-查找","date":"2020-03-16T14:02:45.000Z","updated":"2020-09-04T15:49:59.655Z","comments":true,"path":"2020/03/16/数据结构/5-查找/","link":"","permalink":"https://aaronyard.github.io/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5-%E6%9F%A5%E6%89%BE/","excerpt":"思维导图 一、线性结构","text":"思维导图 一、线性结构 1. 顺序查找（线性查找）O(n)主要用于在线性表上进行查找 12345678int Search_Seq(int *a,int x)&#123; //a[0]作哨兵，使得循环不必判断数组是否越界 //因为满足i==0时，循环一定会跳出 a[0] = x; int i; for(i = 10;a[i]!=x;i--); return i;&#125; 注：对于顺序查找，不管线性表是有序的还是无序的，成功查找第一个元素的比较次数为1，成功查找第二个元素的比较次数为2，依次类推，每个元素查找成功的比较次数只与其位置有关，与是否有序无关。 对有n个元素的有序顺序表和无序顺序表进行顺序查找，讨论平均查找长度 2. 折半查找(仅适用于有序的顺序表) O(log2n)1234567891011121314int Binary_Search(int *a,int x)&#123; int low = 0, high = 10,mid; while(low&lt;=high)&#123; mid = (low+high)/2; cout &lt;&lt; a[low] &lt;&lt; setw(5) &lt;&lt; a[mid] &lt;&lt; setw(5) &lt;&lt; a[high] &lt;&lt; endl; if(a[mid]==x) return mid; else if(a[mid]&lt;x) low = mid+1; else high = mid-1; &#125; return -1; //若查找成功不会走到这一步&#125; 3. 分块查找（索引顺序查找）块中元素可无序，块间元素须有序 二、树形结构1. 二叉排序树详见 第三章节 - 树 2. 平衡二叉树详见 第三章节 - 树 3. B / B+ 树B/B+树一种平衡的多路查找树，一般被用在文件系统（我们常说的B树其实是叫 B- 树） B 树 M阶 B+ 树 M阶 ① 关键字个数 + 1 = 子树个数 ① 关键字个数 = 子树个数 ② 根节点至少2棵子树（1个关键字），至多M棵子树（M-1个关键字） ② 根节点至少2棵子树（2个关键字），至多M棵子树（M个关键字） ③ 除根节点的分支结点至少 M/2 取上整 棵子树（至少 M/2 取上整 - 1 个关键字），至多 M 棵子树（至多 M - 1个关键字） ③ 除根节点的分支结点至少 M/2 取上整 棵子树至少 M/2 取上整 -个关键字），至多 M 棵子树至多 M 个关键字） ④ B 树的叶节点不带任何信息，所有的信息（key，value）都存在分支结点中 ④ B+树叶子结点携带所有结点的全部信息（key，value），且按照大小顺序通过指针链接起来，分支结点仅携带索引信息（key）起索引作用。所以B+ 树的查找更稳定，因为每次都是从根节点到叶节点的查找路径 下图为 B+ 树 B树的插入删除操作插入： 插入后该结点关键字个数小于等于m-1，直接插入 插入后该结点关键字个数大与m-1，以该结点的中间元素为轴进行结点分裂，并将该结点的中间元素上移到其父结点，相应的父结点要增加新分支，即分裂的结点 删除（叶节点）：以3阶为例 删除该关键字后所在结点的关键字个数 &gt; [m/2]取上整 - 1, 直接删除关键字 删除该关键字后所在结点的关键字个数 &lt; [m/2]取上整 - 1 且与其相邻的左（右）兄弟结点够借 ， 父子换位法（兄弟的第一个元素上移到父结点，父结点的最后一个元素下移到要删除的关键字所在的结点。—— 兄弟够借，父子换位 删除该关键字后所在结点的关键字个数 &lt; [m/2]取上整 - 1 且与其相邻的左（右）兄弟结点不够借 ， 则将关键字删除后，将父结点第一个元素下移至要删除元素所在结点处 并与其兄弟结点合并 —— 兄弟不够借，父子合并 B树的建立过程举例： 4. 红黑树① 为什么需要红黑树对于二叉搜索树，如果插入的数据是随机的，那么它就是接近平衡的二叉树，平衡的二叉树，它的操作效率（查询，插入，删除）效率较高，时间复杂度是O（logN）。 但是可能会出现一种极端的情况，那就是插入的数据是有序的（递增或者递减），那么所有的节点都会在根节点的右侧或左侧，此时，二叉搜索树就变为了一个链表，它的操作效率就降低了，时间复杂度为O(N)，所以可以认为二叉搜索树的时间复杂度介于O（logN）和O(N)之间，视情况而定。 那么为了应对这种极端情况，红黑树应运而生，它是具备了某些特性的二叉搜索树，能解决非平衡树问题，红黑树是一种接近平衡的二叉树。 ② 红黑树的特征首先，红黑树是一个二叉搜索 / 二叉排序树，它同时满足以下特性： 每个节点非黑即红 根节点是黑色 如果节点是红色的，那么它的子节点必须是黑色的（反之，不一定需要成立） 从根节点到叶节点或空子节点的每条路径，都包含相同数目的黑色结点 ③ 红黑树的效率红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。 查找操作时，它和普通的相对平衡的二叉搜索树的效率相同，都是通过相同的方式来查找的，没有用到红黑树特有的特性。 但，如果插入的时候是有序数据，那么红黑树的查询效率就比二叉搜索树要高了，因为此时二叉搜索树不是平衡树，它的时间复杂度O(N)。 插入和删除操作时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉搜索树效率要低一点，不过时间复杂度仍然是O(logN)。 总之，红黑树的优点就是对有序数据的查询操作不会慢到O(logN)的时间复杂度。 ④ 红黑树的操作👉 红黑树详解 三、散列结构散列表 1. 散列表的定义散列（哈希）表： 根据关键码值(Key value)而直接进行访问的数据结构 。根据给定的关键字通过散列函数来计算出关键字在表中的地址，以加快查找的速度。 2. 散列函数的构造方法 直接定址法 H(key) = a*key + b 除留取余法 H(key) = key%p (p为不大于m的最大质数) 3. 散列（哈希）冲突冲突：指的是多个关键字映射同一个地址的情况。 4. 处理冲突的方法1.开放定址法 线性探测法（常用，会产生堆积问题） 冲突发生时顺序查找下一个位置 平方探测法 再散列法 2.拉链法（所有的同义词都存储在一个线性链表中） 5. 性能分析平均查找长度仅依赖于装填因子，越满发生冲突的可能性越大。 ASL成功 （除以 元素的总个数） ASL失败 （除以 P 或 mod后面的数） 四、字符串模式匹配KMP 算法123456789101112131415int Index_KMP(string s,string T,int next[],int pos)&#123; int i = pos,j = 1; //i代表母表，j代表字表 while(i&lt;=s.length &amp;&amp; j&lt;T.length)&#123; if(j==0 || s[j]==T[i])&#123; i++; j++; &#125; else j = next[j]; &#125; if(j&gt;T.length) //匹配成功 return i-T.length; else return 0;&#125; next 数组算法如下：","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","slug":"数据结构/4-图","date":"2020-03-15T14:02:45.000Z","updated":"2020-09-04T15:50:02.720Z","comments":true,"path":"2020/03/15/数据结构/4-图/","link":"","permalink":"https://aaronyard.github.io/2020/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-%E5%9B%BE/","excerpt":"一、相关名词解释1. 完全图 无向图中任意两个顶点之间都存在边，称为无向完全图。 n个顶点，n(n-1)/2 条边 有向图中任意两个顶点之间都存在相反的两条弧，称为有向完全图。 n个顶点, n(n-1）条边 2. 连通图/强连通图 无向图 中顶点v到顶点w有路径存在，称v和w连通。若任意两个顶点都连通，连通图 若一个图有n个顶点，并且边数小于n-1，则此图必是非连通图 若一个图有n个顶点，并且边数大于n-1，则此图必有回路 有向图 中顶点 v 到顶点 w 和顶点 w 到顶点 v 之间都有路径，称 v 和w 强连通 。若任意两个顶点都连通，强连通图","text":"一、相关名词解释1. 完全图 无向图中任意两个顶点之间都存在边，称为无向完全图。 n个顶点，n(n-1)/2 条边 有向图中任意两个顶点之间都存在相反的两条弧，称为有向完全图。 n个顶点, n(n-1）条边 2. 连通图/强连通图 无向图 中顶点v到顶点w有路径存在，称v和w连通。若任意两个顶点都连通，连通图 若一个图有n个顶点，并且边数小于n-1，则此图必是非连通图 若一个图有n个顶点，并且边数大于n-1，则此图必有回路 有向图 中顶点 v 到顶点 w 和顶点 w 到顶点 v 之间都有路径，称 v 和w 强连通 。若任意两个顶点都连通，强连通图 3. 连通分量/极大连通子图 无向图中极大连通子图称为连通分量； 有向图中极大连通子图称为强连通分量； 极小连通子图指该连通子图既保持图的连通且包含的边数最少； 4. 生成树 (对于连通图而言）连通图的生成树是 包含全部顶点的一个极小连通子图（即包含全部顶点且边数最少） 若砍去生成树的一条边，则会变成非连通图 若加上一条边，则会形成一个回路 5. 顶点的入度和出度 无向图 的的全部顶点的度之和等于边数的2倍 有向图 的全部顶点的入度之和与出度之和相等，且与边数相等 6. 简单路径序列中的顶点和路径不重复出现的路径。 7. 回路路径中第一个顶点和最后一个顶点相同的路径 二、图的存储1. 邻接矩阵法：（稠密图）图的顺序存储结构 一维数组存储顶点集，二维数组存储边集 无向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的度 有向图的邻接矩阵第i行（列）非零元素的个数表示该顶点的出度（入度） 无向图的邻接矩阵是对称的 2. 邻接表法：（稀疏图）图的链式存储结构 一个单链表表示该顶点的边表； 各个单链表的头指针和顶点采用顺序存储连接起来表示顶点表 邻接表可以方便的找出一顶点的所有邻边，但确定两结点之间是否有边效率低下 在有向图中，求一个给定结点的出度只需计算邻接表中结点的个数，但求入度需要遍历全部顶点的邻接表 假设有n个顶点，e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为：O(n+e) 首先删除下标为v的顶点表结点的单链表，边数最多n-1，时间复杂度O(n)； 再扫描所有边表结点，删除所有的顶点v的入边，时间复杂度O(e)； 3. 十字链表有向图的另一种链式存储结构。 4. 邻接多重表无向图的链式存储结构。 三、图的遍历1. 广度优先遍历BFS（类似于层次遍历）基本思想 ：利用 队列 实现。 首先访问起始顶点 V 并将其入队 V出队，并遍历V的所有邻接点 w1，w2，….，wn并依次入队 w1出队，并遍历 w1 的全部邻接点(不包括已经被访问的点) w2出队，并遍历w2的全部邻接点(不包括已经被访问的点) ……. 以此类推 1234567891011121314151617181920212223 void BFS(Graph G, int v)&#123; visit(v); //访问初始结点 visited[v] = TRUE; //初始结点置已访问标识 EnQueue(Q,v); //顶点v入队 while(!isEmpty(Q))&#123; DeQueue(Q,v); //顶点v出队 for(w = FirstNeighbor(G,v); w&gt;=0; w = NextNeighbor(G,v,w))&#123; //循环遍历v所有邻接点 if(!visited[w])&#123; visit(w); //访问顶点w visited[w] = TRUE; EnQueue(Q, w); &#125; &#125; &#125; //while &#125; void BFSTraverse(Graph G)&#123; for(i = 0; i&lt;G.vexnum; i++) visited[i] = FALSE; InitQueue(Q); //初始化队列 for(i = 0; i&lt;G.vexnum;i++) //防止一次遍历无法遍历到全部结点（非连通图） if(!visited[i]) //若未被访问 BFS(G,i);&#125; 2. 深度优先遍历DFS（类似于先序遍历）基本思想：利用 递归/栈 实现。当不能继续向下访问时，依次回退到最近的被访问结点 首先访问顶点V，并将其标记为已访问 然后访问与顶点V的其中一个未被访问的邻接点W，并将其标记为已访问 再访问W的其中一个未被访问的邻接点，并将其标记为已访问 依次类推….. 当一个顶点所有的邻接顶点都被访问过时，则依次退回最近被访问过的顶点 12345678910111213141516 void DFS(Graph G, int v)&#123; visit(v); visited[v] = TRUE; for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w))&#123; if(!visited[v]) DFS(G,w); //递归 &#125; &#125; void DFSTraverse(Graph G, int v)&#123; for(int i = 0 ; i&lt;G.vexnum; i++) visited[v] = FALSE; for(int i = 0; i&lt;G.vexnum; i++) if(!visited[v]) DFS(G,i);&#125;&#125; 四、图的应用1. 最小生成树① Prim算法每次选取相对最小的边并且互相连通。需保证无环 ② kruskal算法每次选取最小的边，无须保证此过程是否连通。需保证无环 2. 最短路径① Dijkstra算法该算法可以求得某一顶点到其余各顶点的最短路径。 算法思想： 设有两个顶点集合 S 和 T，其中集合 S 中存放的是图中已找到最短路径的顶点，集合 T 中存放 的是图中的剩余顶点。 初始状态时，集合 S 中只包含源点 V0，然后不断从集合 T 中选取到顶点 V0 路径最短的顶点 Vu 并加入集合 S 中，之后的路径可通过该结点 集合 S 每加入一个新的顶点 Vu，都要修改 V0 到集合 T 中各个顶点的最短路径的长度值。 不断重 复这个过程，直至集合T中的顶点全部并入到 S 中为止。 ② Floyd算法每次都试图在路径上添加新的中间结点 3. 拓扑排序什么图可以进行拓扑排序？ 有向无环图 基本思想 ：每次去除一个入度为0的结点和该与顶结点相连的边 若图中存在一条A——&gt;B的路径，则在拓扑排序中表示B事件在A事件的后面 4. 关键路径具有最大路径长度的路径称为关键路径 只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快所有关键路径上的关键活动才能缩短工期 关于关键路径的求解问题可参考本篇博文：木子阳555 -【数据结构-图】关键路径解法","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树","slug":"数据结构/3-树","date":"2020-03-14T14:02:45.000Z","updated":"2020-09-04T15:49:39.373Z","comments":true,"path":"2020/03/14/数据结构/3-树/","link":"","permalink":"https://aaronyard.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-%E6%A0%91/","excerpt":"一、思维导图","text":"一、思维导图 二、基本概念和性质 结点数等于所有结点的度数(边数)加1 v = e+1； 对于一颗具有n个结点，度为4的树来说，树的最大高度为n-3； 二叉树的性质： n0 = n2 + 1； 叶子结点数数 = 度为2的结点+1 高度为h的二叉树总共至多有 2的h次方 -1 个结点（满二叉树） 第k层至多有 2的k-1次方 个结点； 具有n个结点的完全二叉树的高度为 log2(n+1) 向上取整 三、二叉树的存储结构顺序存储顺序存储（数组）：空间利用率较低 链式存储链式存储（链表）：左右孩子指针（含有n个结点的二叉链表中，含有n+1个空链域） C 1234typedef struct BiTNode&#123; int data; struct BiTNode* lchild,*rchild;&#125;BiTNode,*BiTree; C++ 1234567template&lt;class T&gt;struct BiTNode&#123; T data; BiTNode&lt;T&gt; *lchild,*rchild; BiTNode():lchild(NULL),rchild(NULL)&#123;&#125; //无参构造 BiTNode(T x, BiTNode&lt;T&gt; *l = NULL, BiTNode&lt;T&gt; *r = NULL):data(x),lchild(l),rchild(r)&#123;&#125; //带参构造&#125;; 四、二叉树的三种遍历+层次遍历以下代码给出三种遍历的递归和非递归实现，均为 c++ 实现 先中后遍历均借助栈实现，层次遍历借助队列实现 1. 先序遍历 递归 12345public static void scan(BiTree b) &#123; cout&lt;&lt;r-&gt;data; if(b-&gt;lchild != null) scan(b-&gt;lchild); if(b-&gt;rchild != null) scan(b-&gt;rchild);&#125; 非递归 123456789101112131415//先序遍历非递归void InOrder(BiTree T)&#123; BiTree p = T; while(p || !is_empty(S))&#123; if(p)&#123; visit(p-&gt;data); push(S,p); p=p-&gt;lchild; &#125; else&#123; pop(S,p); p = p-&gt;rchild &#125; &#125;&#125; 2. 中序遍历 递归 1234567public static void scan(BiTree b) &#123; if(b != null) &#123; scan(b-&gt;lchild); cout&lt;&lt;r-&gt;data; scan(b-&gt;rchild); &#125;&#125; 非递归 123456789101112131415//中序遍历非递归void InOrder(BiTree T)&#123; BiTree p = T; while(p || !is_empty(S))&#123; if(p)&#123; push(S,p); p=p-&gt;lchild; &#125; else&#123; pop(S,p); visit(p-&gt;data); p = p-&gt;rchild &#125; &#125;&#125; 3. 后序遍历 递归 1234567public static void scan(BiTree b) &#123; if(b != null) &#123; scan(b-&gt;lchild); scan(b-&gt;rchild); cout&lt;&lt;r-&gt;data; &#125;&#125; 非递归 123456789101112131415161718192021222324252627//后序遍历非递归void PostOrder(BiTree T)&#123; InitStack(S); p = T; r = NULL; //最近访问过的结点 while(p || !is_empty(S))&#123; if(p)&#123; Push(S,p); p = p-&gt;lchild; &#125; else&#123; GetTop(S,p); //右孩子存在且未被访问过 if(p-&gt;rchild &amp;&amp; r!=p-&gt;rchild)&#123; p = p-&gt;rchild; Push(S,p); p = p-&gt;lchild; //再走到最左 &#125; else&#123; //若既无左孩子也无右孩子，则弹出结点并访问 Pop(S,p); visit(p-&gt;data); r = p; //置为最近访问结点 p = NULL; //p重置 &#125; &#125; &#125;&#125; 4. 层次遍历123456789101112void LevelOrder(BiTree T)&#123; BiTNode p; EnQueue(Q,T); while(!isEmpty(Q))&#123; DeQueue(p); visit(p); if(p-&gt;lchild!=NULL) EnQueue(Q,p-&gt;lchild); if(p-&gt;rchild!=NULL) EnQueue(Q,p-&gt;rchild); &#125;&#125; 若已知以下三种序列组合，则可以唯一的确定一颗二叉树 先序和中序序列（前序为进栈序列，中序为出栈序列） 后序和中序序列 层次和中序序列 若非空二叉树先序序列和后序序列正好相反，则二叉树形态是什么? 每层只有一个结点，高度=结点个数 若非空二叉树先序序列和后序序列正好相同，则二叉树形态是什么？ 只有根节点 五、二叉树相关递归算法1. 统计二叉树中度为2的结点个数12345678int Dnode(BiTree T)&#123; if(T==NULL) return 0; else if(T-&gt;lchild &amp;&amp; T-&gt;rchild) return Dnode(T-&gt;lchild)+Dnode(T-&gt;rchild) + 1; else return Dnode(T-&gt;lchild)+Dnode(T-&gt;rchild); &#125; 2. 统计二叉树中度为1的结点个数12345678int Lnode(BiTree T)&#123; if(T==NULL) return 0; else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild!=NULL || T-&gt;lchild!=NULL&amp;&amp;T-&gt;rchild==NULL) return Lnode(T-&gt;rchild)+Lnode(T-&gt;lchild)+1; else return Lnode(T-&gt;rchild) + Lnode(T-&gt;lchild);&#125; 3. 统计二叉树中度为0的结点个数(叶子)12345678int Leaves(BiTree T)&#123; if(T==NULL) return 0; else if(T-&gt;lchild==NULL &amp;&amp; T-&gt;rchild==NULL) return 1; else return Leaves(T-&gt;rchild) + Leaves(T-&gt;lchild);&#125; 4. 统计二叉树的高度1234567891011int Height(BiTree T)&#123; if(T==NULL) return 0; else if(!T-&gt;lchild &amp;&amp; !T-&gt;rchild) return 1; else&#123; int hl = Height(T-&gt;lchild); int hr = Height(T-&gt;rchild); return (hl&gt;hr?hl:hr) + 1; &#125;&#125; 5. 统计二叉树的宽度1234567891011121314//先序遍历，每递归一次就深入一层int count[100]; //记录每层的宽度int Width(BiTree T,int k)&#123; //K表示第几层 int max = -1; //最大宽度 if(T==NULL) return 0; count[k] ++; //第k层宽度++ if(max&lt;count[k]) max = count[k]; else&#123; Width(T-&gt;lchild,k+1); Width(T-&gt;rchild,k+1); &#125;&#125; 6. 计算指定结点*p所在层次12345678910111213int Level(BiTree T, BiTNode *p, int level)&#123; if(T==NULL) return 0; else if(T-&gt;data == p-&gt;data) return level; else&#123; int l = Level(T-&gt;lchild,p,level+1); if(l!=0) return l; else return Level(T-&gt;rchild,p,level+1); &#125;&#125; 7. 交换二叉树中每个结点的两个子女12345678910//先交换左右孩子的左右子树，再交换左右孩子void swap(BiTree T)&#123; if(T)&#123; swap(T-&gt;lchild); swap(T-&gt;rchild); int temp = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = temp; &#125;&#125; 六、二叉排序树BST / 二叉查找树1. 定义二叉排序树又称二叉查找树，它或者是一颗空树，或者满足一下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于根节点的值； 若右子树不空，则右子树上所有结点的值均大于根节点的值； 左右子树也分别是二叉排序树。 递归的数据结构，左&lt;根&lt;右 ，中序遍历为递增序列 2. 插入和删除操作 插入 插入的结点一定是某个叶结点 删除 被删除结点时叶子结点，直接删除； 被删除结点z只有一棵左子树或者右子树，则删除z,令z的子树成为z父结点的子树 被删除结点z有两棵子树，则交换z的 直接后继（中序遍历） 和z的位置，转换为第二种情况删除z 查找效率分析 最好情况：平衡二叉树 O(log2n) 最坏情况：输入序列有序 O(n) 3. 二叉排序树的判定思路：二叉排序树的中序遍历序列一定为递增序列 代码： 12345678910111213//利用中序遍历为递增bool isBST(BiTree T)&#123; if(T==NULL) return true; else&#123; bool bl = isBST(T-&gt;lchild); if(bl==false || pre&gt;T-&gt;data) return false; pre = T-&gt;data; bool br = isBST(T-&gt;rchild); return br; &#125;&#125; 七、平衡二叉树AVL1. 定义为避免树的高度增长过快，降低二叉排序树的性能， 规定插入和删除时 任意结点的左右子树高度差的绝对值不超过1 。 平衡二叉树是特殊的二叉排序树 2. 插入操作（每次调整对象都是最小不平衡子树） LL右单旋：（在结点A的左孩子的左子树插入新结点导致A失衡） RR左单旋：（在结点A的右孩子的右子树插入新结点导致A失衡） LR左右双旋：（在结点A的左孩子的右子树插入新结点导致A失衡） RL右左双旋：（在结点A的右孩子的左子树插入新结点导致A失衡） 3. 平衡二叉树的判定思路：平衡二叉树的每一个结点都是平衡的，利用后序遍历按照左右根的次序依次判断是否平衡二叉树 1234567891011121314151617181920int isAVL(BiTree T,int &amp;h,int &amp;balance)&#123; int bl,br,hl,hr; //左右子树的高度和平衡性 if(T==NULL)&#123; balance = 1; h = 0; &#125; else if(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)&#123; //左右孩子均不存在 balance = 1; h = 1; &#125; else&#123; isAVL(T-&gt;lchild,hl,bl); //判定左子树 isAVL(T-&gt;rchild,hr,br); //判定右子树 h = hl&gt;hr?hl:hr; if(bl&amp;&amp;br &amp;&amp; abs(hl-hr)&lt;2) //若左右子树均平衡且高度差小于等于1 balance = 1; else balance = 0; &#125;&#125; 4. 完全二叉树的判定思路： 完全二叉树的结点编码是连续的，根据层次遍历，把所有结点依次入队，包括空结点，若空结点之后还有非空结点，就不是完全二叉树 代码： 12345678910111213141516171819202122bool isComplete(BiTree T)&#123; if(!T) return true; InitQueue(Q); BiTNode *p = T; EnQueue(Q,T); while(!isEmpty(Q))&#123; DeQueue(Q,p); if(p)&#123; EnQueue(Q,p-&gt;lchild); EnQueue(Q,p-&gt;rchild); &#125; else&#123; while(!isEmpty(Q))&#123; DeQueue(Q,p); if(p) return false; &#125; &#125; &#125; return true;&#125; 八、哈夫曼树（最优二叉树）和哈夫曼编码1. 定义给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree) 带权路径长度：结点到根结点之间的路径长度与该结点上权的乘积 2. 构造方法每次选取两棵根结点权值最小的树作为新结点的左右子树 3. 哈夫曼编码前缀编码：没有一个编码是另一个编码的前缀，比如：01 011 010 就不是前缀编码，因为01是011的前缀，根据01不能唯一确定用哪个编码。 哈夫曼编码就是长度最短的前缀编码，减少编码的长度。 九、树、森林、二叉树的转换1. 树转化为二叉树二叉树中遵循 左孩子右兄弟 的原则 2. 森林转化为二叉树 将第一棵树的根作为转换后的二叉树的根； 将第一棵左子树作为转换后二叉树根的左子树； 将第二棵树作为转化后二叉树的右子树………. 3. 二叉树转化为森林 二叉树的根及其左子树作为第一棵树； 右子树作为第二棵树； 直到产生一棵没有右子树的二叉树为止","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈和队列","slug":"数据结构/2-栈和队列","date":"2020-03-13T14:02:45.000Z","updated":"2020-09-04T15:49:43.192Z","comments":true,"path":"2020/03/13/数据结构/2-栈和队列/","link":"","permalink":"https://aaronyard.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"一、栈1. 栈的定义 操作受限的线性表，先进后出 FILO（First In Last Out） 一般设立栈顶指针初值为top=-1（栈空） 从队头出队，从队头进队 进栈：top ++; 出栈：top –;","text":"一、栈1. 栈的定义 操作受限的线性表，先进后出 FILO（First In Last Out） 一般设立栈顶指针初值为top=-1（栈空） 从队头出队，从队头进队 进栈：top ++; 出栈：top –; 2. 共享栈：S[0 : n-1]一般设初值为top1 = -1(栈空)，top2 = n(栈空) 当且仅当top2-top1 = 1时共享栈满（即两个栈顶指针相邻） 3. 出栈序列若元素的进栈序列为ABCDE,运用栈操作，能否得到出栈序列BCAED和DBACE？ BCAED 正确 DBACE 不可能：若 D 为首先出栈元素，已知 ABC 先于 D 入栈， C 不可能后于 AB 出栈 4. 实际应用举例设计算法判断单链表（字符型data域)的全部n个字符是否中心对称。 ex: xyx, xyyx 思路：利用栈的先进后出的特点，将链表前一半元素依次进栈，然后将栈中元素出栈，与链表的后半元素依次进行比较。 12345678910111213141516171819int dc(LinkList L, int n)&#123; char s[n/2]; //字符栈，同数组实现栈的功能 p = L-&gt;next; for(int i = 0; i &lt; n/2; i++)&#123; //链表前一半元素进栈 s[i] = p-&gt;data; i++; &#125; i--; //恢复最后的i值if(n%2!=0) //若n为奇数，后移过中心结点 p = p-&gt;next; while(p!=NULL &amp;&amp; s[i]=p-&gt;data)&#123; //检测是否中心对称 i --; //i充当栈顶指针 p = p-&gt;next; &#125;if(i = -1) //空栈 return 1; else return 0;&#125; 5. 将中缀表达式转化为后缀表达式核心思想 ：栈外字符加入栈内时，要保证栈外字符的优先级比栈内所有字符的优先级都要低，否则，弹出栈内优先级较高的字符，并加入后缀表达式。 步骤 ： 遇到字母或数字直接入栈； 遇到运算符时： 若为’(‘, 直接入栈； 若为’)’, 依次把栈中运算符加入后缀表达式，直到出现‘(’, 并从栈中将‘(’删除； 若为其他运算符，根据优先级表依次弹出比当前处理的运算符优先级高的运算符，并将其加入后缀表达式，直到遇到一个比它优先级低的或遇到了一个’(‘为止。 运算符优先级表 操作符 # （ *，/ +，- ） 栈内优先级 0 1 5 3 6 栈外优先级 0 6 4 2 1 6. 栈在递归中的应用ex：斐波拉契数列 0 1 1 2 3 5 … 12345678int Fib(int n)&#123; if(n == 0) return 0; else if(n == 1) return 1; else c return Fib(n-1) + Fib(n-2);&#125; 递归必要的两个条件： 递归表达式（递归体） 递归出口（边界条件） 采用非递归方式重写递归程序时必须使用栈。该说法是错误的！ ex: 计算斐波拉契数列可用循环实现 函数调用时，系统要用栈保存必要的信息；递归次数过多容易造成栈溢出 二、队列1. 队列定义同样也是操作受限的线性表，先进先出FIFO，从队尾进队，从队头出队 队列分为： 顺序队列 循环队列 链式队列 双端队列 2. 顺序队列 同样采用数组存储元素 队头指针指向第一个元素 队尾指针一般指向最后一个元素的下一个位置 进队：先送值到队尾，再将队尾指针+1 12Q.data[Q.rear] = x;rear ++; 出队：先取出队头元素，再将队头指针+1 12x = Q.data[Q.front]front ++; 顺序队列存在的问题 ：会导致上溢出；是一种 假溢出 ，在data数组中任然存在可以存放数组的位置 解决方法： 建立一个足够大的存储空间以避免溢出，但这样做空间使用率低，浪费存储空间 移动元素：每当出队一个元素，就将移动队列中所有的已有元素向队头移动一个位置 循环队列：将队头和队尾看作是一个首尾相接的循环队列 3. 循环队列弥补顺序队列的缺点 初始/队空：Q.front = Q.rear (队空条件） 出队：Q.front = (Q.front+1) % maxsize (最大元素个数) 进队：Q.rear = (Q.rear+1) % maxsize 队列长度 = (Q.rear - Q.front + maxsize) % maxsize 队满：( 牺牲一个单元来区分队空和队满 ）(Q.rear + 1) % maxsize = Q.front 4. 链式队列实际就是一个同时带有头指针和尾指针的单链表 头指针指向队头结点，尾指针指向队尾结点（即单链表最后一个结点，与顺序存储有所不同） 适合于数据元素变动较大的情况，而且不存在队列满或者溢出的问题。 队空： Q.rear == Q.front == NULL 出队：（带头结点） 123456LinkNode *p = Q.front-&gt;next;x = p-&gt;data;Q.front-&gt;next = p-&gt;next; //插入头节点之后if(Q.rear = p) //若原队列中只有一个结点，删除后变空，还需修改尾指针 Q.rear = Q.front;free(p); 进队：（带头节点） 1234LinkNode *s = (LinkNode *) malloc (sizeof(LinkNode)); //创建新结点s-&gt;data = x; s-&gt;next = NULL;Q.rear-&gt;next = s; //插入到表尾Q.rear = s; 5. 双端队列允许两端都进行入队和出队操作的队列 输出受限：有一端允许插入和删除；另一端只允许插入 输入受限：有一端允许插入和删除；另一端只允许删除 6. 队列的应用 层次遍历 计算机系统中的应用 解决主机与外部设备之间速度不匹配的问题（ex:打印机数据缓冲区中所存储的数据就是一个队列） 解决由多用户引起的资源竞争问题（CPU将请求按时间先后排成队列）","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线性表","slug":"数据结构/1-线性表","date":"2020-03-12T14:02:45.000Z","updated":"2020-09-04T15:49:46.494Z","comments":true,"path":"2020/03/12/数据结构/1-线性表/","link":"","permalink":"https://aaronyard.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"一、线性表的定义具有相同数据类型的 n 个数据元素的有限序列 线性表是一种逻辑结构，表示元素之间一对一的逻辑关系。 顺序表和链表是存储结构。","text":"一、线性表的定义具有相同数据类型的 n 个数据元素的有限序列 线性表是一种逻辑结构，表示元素之间一对一的逻辑关系。 顺序表和链表是存储结构。 二、顺序表1. 顺序表定义：线性表的顺序存储 1234typedef struct&#123; int data[50]; int length;&#125; SqList; 逻辑上相邻的两个元素在物理位置上也相邻 特点： 随机访问（通过首地址和元素序号可在时间O(1)内找到元素） 插入和删除需要移动大量元素 存储密度高，每个结点只存储数据元素 2. 顺序表基本操作① 插入在第i个位置(下标i-1)插入元素e 12345 //第i个元素及其之后的元素后移for (int j = length; j &gt;= i; j--) L[j] = L[j - 1];L[i - 1] = e;length++; 最好情况：在表尾插入，时间复杂度 O(1) 最坏情况：在表头插入，时间复杂度 O(n) 平均情况：时间复杂度 O(n) ② 删除删除第i个位置的元素，用e返回 12345e = L[i-1];//从第i个位置元素前移for(int j = i; j&lt;length;j++) L[j-1] = L[j];length --; 最好情况：删除表尾元素，O(1) 最坏情况：删除表头元素，O(n) 平均情况：O(n) ③ 按值查找123for (int i = 0; i &lt; length; i++) if (L[i] == e) return i; 最好情况：查找元素在表头，O(1) 最坏情况：查找元素在表尾，O(n) 平均情况：O(n) 3. 顺序表相关算法① 删除线性表中所有值为x的数据元素 用 k 记录顺序表中等于 x 的元素个数，边扫描边统计 k 遍历结束后将不等于 x 的元素前移 k 个位置，最后修改 L 的长度 12345678910111213void delete_x(int &amp;a, int x)&#123; int i = 0; int k = 0; //记录当前查询到的x的个数 while(i&lt;len)&#123; if(a[i]==x) k++; else a[i-k] = a[i]; i++; &#125; len = len - k;&#125; ② 将两个有序顺序表合成一个有序顺序表归并思想 1234567891011121314151617181920212223242526typedef struct&#123; int data[50]; int length;&#125; SqList;bool merge(SqList a,SqList b,SqList &amp;c)&#123; if(a.length+b.length&gt;50) return false; int i=0,j=0,k=0; while(i&lt;a.length &amp;&amp; j&lt;b.length)&#123; if(a.data[i]&lt;b.data[j])&#123; //a表元素较小 c.data[k++] = a.data[i++]; &#125; else //b表元素较小 c.data[k++] = b.data[j++]; &#125; //若a表未比较完 while(i&lt;a.length)&#123; c.data[k++] = a.data[i++]; &#125; while(j&lt;b.length)&#123; c.data[k++] = b.data[j++]; &#125; c.length = k; return true;&#125; ③ 将数组R中的n个元素循环左移p个位置题目等同于将ab转变为ba（a为前p个元素） XY —&gt; (XTYT)T = YX 123reverse(R,0,n-1);reverse(R,0,p-1);reverse(R,p,n-1); ④ 找出两个等长升序序列A，B的中位数（取上整）A中位数a，B中位数b 若a=b: 返回a或b 若a&gt;b: 舍弃a右边较大的部分，同时舍弃b左边较小的部分（不删除中位数） 若a&lt;b：舍弃a左边较小的部分，同时舍弃b右边较大的部分 重复上述操作，直到两序列都只剩一个元素，较小值即为中位数 123456789101112131415161718192021222324252627282930313233343536373839int Mid(int A[], int B[], int n)&#123; int s1 = 0, d1 = n - 1, m1; //首位数，末位数，中位数 int s2 = 0, d2 = n - 1, m2; while (s1 != d1 || s2 != d2) &#123; //表中不只一个元素 m1 = (s1 + d1) / 2; m2 = (s2 + d2) / 2; if (A[m1] == A[m2]) return A[m1]; else if (A[m1] &gt; A[m2]) &#123; //舍弃A较大部分和B较小部分 if ((s1 + d1) % 2 == 0) &#123; //元素个数为奇数,保留中间点 d1 = m1; s2 = m2; &#125; else &#123; //元素个数为偶数，B的中间点也舍弃 d1 = m1; s2 = m2 + 1; &#125; &#125; else &#123; //舍弃A较小部分和B较大部分 if ((s1 + d1) % 2 == 0) &#123; //元素个数为奇数,保留中间点 d2 = m2; s1 = m1; &#125; else &#123; //元素个数为偶数，A的中间点也舍弃 d2 = m2; s1 = m1 + 1; &#125; &#125; &#125; return A[s1]&lt;A[s2]?A[s1]:A[s2];&#125; 三、链表链表分为： 单链表 双链表 循环单链表（判空条件：表尾结点的next是否是等于头指针） 循环双链表 1. 单链表① 定义1234typedef struct LNode&#123; ElemType data; struct LNode* next;&#125;LNode,*LinkList; 单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点 单链表是非随机存储的存储结构：即不能直接找到表中某个特点的结点。需要从头开始遍历。 单链表访问前驱的时间复杂度为O(n),访问后继O(1) 引入头节点的优点： 链表的第一个元素位置上的操作与其他位置的元素操作一样，无须进行特殊处理 无论链表是否为空，其头指针都是指向头节点的非空指针，空表和非空表的处理得到了统一 （头指针始终指向第一个结点，有头节点则指向头节点，无头节点则指向第一个元素结点） ② 基本操作头插法：(读入顺序和生成顺序相反）12s-&gt;next = L-&gt;next;L-&gt;next = s; 尾插法：(读入顺序和生成顺序相同）123//尾指针rr-&gt;next = s;r = s; 按序号查找按值查找插入结点：p之后插入s (p的位置需要自行查找) 12s-&gt;next = p-&gt;next;p-&gt;next = s; 删除结点：1234//删除p之后的qq = p-&gt;next;p-&gt;next = q-&gt;next;free(q); //释放结点的存储空间 求表长2. 双链表① 定义就是同时具有前驱指针和后继指针的链表 访问前驱和后继结点时间复杂度都是O(1) 1234typedef struct DNode&#123; int data; struct DNode* next,*prior;&#125;DNode,*DinkList; ② 基本操作插入：p之后插入s 1234s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;p-&gt;next = s;s-&gt;prior = p; 删除：1234//删除p之后的sp-&gt;next = s-&gt;next;s-&gt;next-&gt;prior = p;free(s); 3. 循环单链表 判空条件：表尾结点的next是否是等于头指针 4. 循环双链表 四、顺序表和链表的比较 五、链表的相关算法1. 递归删除不带头节点的单链表L中所有值为x的结点12345678910111213void Del(LinkList &amp;L,int x)&#123; LNode *p; if(L==NULL) return; else if(L-&gt;data == x)&#123; p=L; L=L-&gt;next; free(p); Del(L,x); &#125; else Del(L-&gt;next,x);&#125; 2. 反向输出单链表中每个结点的值12345void rprint(LinkList L)&#123; if(L-&gt;next!=NULL) rprint(L-&gt;next); cout&lt;&lt;L-&gt;data&lt;&lt;\" \";&#125; 3. 带头结点的单链表就地逆置123456789101112//摘下头结点，同头插法LinkList Reverse(LinkList &amp;L)&#123; LNode *p=L-&gt;next, *r=L;//r为后继结点，防止断链 L-&gt;next = NULL; //摘下头节点 while(p)&#123; r = p-&gt;next; p-&gt;next = L-&gt;next; L-&gt;next = p; p = r; //继续插入 &#125; return L;&#125; 4. 找出两个链表的公共结点算法思想：两个链表公共结点之后的所有结点都重合，呈现Y型； 先走完较长链表的多出来的一部分，到达同样长度后再同步比较 12345678910111213141516171819202122232425LinkList Search_Common(LinkList L1, LinkList L2)&#123; int len1 = L1.length; int len2 = L2.length; int longlist, shortlist; if (len1 &gt; len2) longlist = L1-&gt;next; shortlist = L2-&gt;next; dist = len1 - len2; else longlist = L2; shortlist = L1; dist = len2 - len1; while (dist--) longlist = longlist-&gt;next; while (longlist != Null) &#123; if (longlist == shortlist) return longlist; else &#123; longlist = longlist-&gt;next; shortlist = shortlist-&gt;next; &#125; &#125;&#125; 5. 在一个递增有序的单链表中，删除数值相同的元素，使表中不再有重复的元素1234567891011121314void Del_Same(LinkList &amp;L)&#123; LNode *p=L-&gt;next, *r; //后继结点r if(p==NULL) return; while(p-&gt;next!=NULL)&#123; r = p-&gt;next; if(p-&gt;data == r-&gt;data)&#123; p-&gt;next = r-&gt;next; free(r); &#125; else p = p-&gt;next; &#125;&#125; 6. 查找链表中倒数第K个位置的结点算法思想：快慢指针法； 快指针先走k步，随后快慢指针同时依次后移，快指针到达链表尾部时，慢指针正好访问倒数第k个位置结点 123456789101112131415161718int Search_k(LinkList L, int k)&#123; LNode *p = L-&gt;next, *q = L-&gt;next; int count = 0; while(p!=Null)&#123; if(conut &lt; k)&#123; p = p-&gt;next; count++; &#125; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; if(count &gt; k) //k值超过了线性表长度 return 0; else return 1;&#125; 7. 查找单链表的中间结点此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空、链表结点个数为1和2的情况。时间复杂度O（n）。 12345678910111213141516// 获取单链表中间结点，若链表长度为n(n&gt;0)，则返回第n/2+1个结点 ListNode * GetMiddleNode(ListNode * pHead) &#123; if(pHead == NULL || pHead-&gt;m_pNext == NULL) // 链表为空或只有一个结点，返回头指针 return pHead; ListNode * pAhead = pHead; ListNode * pBehind = pHead; while(pAhead-&gt;m_pNext != NULL) // 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步 &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; if(pAhead-&gt;m_pNext != NULL) pAhead = pAhead-&gt;m_pNext; &#125; return pBehind; // 后面的指针所指结点即为中间结点 &#125; 8. 如何判断单链表是否有环以及环的入口假设一个单链表有环，他就是下面这种情况： 判断是否有环：使用二指针法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。 如存在环，则两者相遇；如不存在环，fast遇到NULL退出 1234567while (slow != NULL&amp;&amp; fast != NULL &amp;&amp; fast -&gt; next != NULL) &#123; slow = slow -&gt; next ; fast = fast -&gt; next -&gt; next ; if (slow == fast) return true ; &#125; return false; 环的入口：头结点到入口的距离 = slow 和 fast 指针相遇点到入口的距离。设定一个start指针指向头结点，meet指针指向slow和fast指针相遇处，将start指针和meet指针遍历，start指针和meet指针相等时，则该地址为环的入口地址。 123456789//环的入口节点 start=head; meet=fast;//meet=slow while(start!= meet)//遍历指针，直到start指针和meet指针相等 &#123; start = start-&gt;next; meet = meet-&gt;next; &#125; return start;//return meet","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aaronyard.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"软件工程重点知识总结","slug":"软件工程/软件工程重点知识总结","date":"2020-03-06T14:02:45.000Z","updated":"2020-09-04T15:49:28.623Z","comments":true,"path":"2020/03/06/软件工程/软件工程重点知识总结/","link":"","permalink":"https://aaronyard.github.io/2020/03/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"一、 软件工程概述1. 软件的定义 软件是指令的集合 软件是一种数据结构，使得程序可以合理利用信息 软件是软件描述信息，用来描述程序的操作和使用","text":"一、 软件工程概述1. 软件的定义 软件是指令的集合 软件是一种数据结构，使得程序可以合理利用信息 软件是软件描述信息，用来描述程序的操作和使用 2. 软件产品的特性是什么？ 是一种逻辑产品，与物质产品有很大的区别 软件产品的生产成本主要在开发和研制，完成后，通过复制就产生了大量的软件产品 软件产品的生产过程主要是脑力劳动，大部分软件是定制开发 开发软件的成本不断增加 软件产品不存在磨损和消耗（但是因为软件是在不断迭代更新的，所以软件退化确实存在） 3. 什么是软件危机，软件危机有哪些表现什么是软件危机： 软件开发技术的进步满足不了发展的需求 在软件开发中遇见的问题得不到有效的解决方案，久而久之，问题累积起来，形成尖锐的矛盾，导致了软件危机 软件危机的表现： 用户对开发出的软件不满意 软件产品的质量不可靠 软件可维护性较低 软件生生产效率较低 软件开发成本越来越高 软件开发进度难以估计 4. 什么是软件工程，它的目标和内容是什么要获得成功的软件就需要在设计和构建软件时有所规范，因此，各种形式各个应用领域的软件都需要工程化。 软件工程定义：将系统的、规范的、可量化的方法应用于软件的开发、运行和维护，并对这些方法进行研究 软件工程的内容：软件工程是一种层次化的技术，包含工具、方法、过程和质量关注点。其中，支持软件工程的根基在于质量关注点（quality focus） 过程：软件工程的基础。过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤 方法：为构建软件提供技术上的解决方法，回答怎样做问题 工具：为过程和方法提供自动化或半自动化的支持 软件工程的目标：（解决软件危机） 付出较低的开发成本，达到要求的功能，取得较好的性能 开发的软件可靠性高 开发的软件易于移植 降低软件维护费用 按时完成开发任务，及时交付使用 5. 软件工程的本质特性软件过程具有下述本质特性： 软件工程关注于大型程序的构造 软件工程的中心课题是控制复杂性 软件经常变化 软件必须有效地支持它的用户 开发软件的效率非常重要 和谐的合作是开发软件的关键 在软件工程领域中通常由具有一种文化背景的人代替另一种文化背景的人创造产品 6. 什么是软件生存周期软件生存周期：一个软件从提出开发要求开始到该软件报废为止的整个时期 包括： 可行性分析和项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护 二、软件工程方法学软件工程方法学包含 3 个要素：方法、工具和过程 方法：完成软件开发的各项任务的技术方法，回答怎样做问题 过程：为了获得高质量的软件而定义的一系列任务的框架，它规定了完成各项任务的工作步骤 工具：为过程和方法提供自动化和半自动化的技术支持 1. 传统/结构化开发方法结构化开发方法把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。前一个阶段任务的完成是开始进行后一个阶段工作的前提和基础，而后一阶段任务的完成通常是使前一阶段提出的解法更进一步具体化。且每个阶段都需要提交详细的文档。（类似瀑布模型） 结构化开发方法主张把软件系统按功能进行逐步的细分，采用自顶向下设计方法，在设计阶段需要考虑每个模块应该分解成哪些子模块，每个子模块又该分解成哪些更小的子模块，以此内推，直到模块被细化为一个个函数。 结构化开发方法把数据和对数据的处理分离开来，增加了软件开发与维护的难度 这种结构化的设计方法显然是有局限性的： 设计不够直观，与人类的思维方式不一致。因为开发者需要将客观世界的模型分解成一个个功能，每个功能用于完成一定的数据处理。 适应性差，可扩展性不强。由于采用自顶向下的设计方法，当用户需求改变时，需要自顶向下的修改模块结构，维护的成本相当大。 2. 面向对象开发方法面向对象程序设计方法的基本思想是使用类、对象、继承、封装和消息等概念进行程序设计。它从现实世界客观存在的事物（对象）出发来构造软件系统。强调尽可能用人类自然的思维方式思考问题，认识问题，从而将现实世界中的事物抽象成系统中的类，作为系统的基本构成单元。这样构建的系统能直接映射客观世界，更符合现实世界的本来面貌。 面向对象方法将数据与数据操作封装成一个整体，对象的修改只能由自身的成员函数完成。 面向对象的设计方法的优点是： 与人类习惯的思维方式一致； 稳定性好 可重用性好 易于开发大型的软件产品 可维护性好 三、软件过程1. 什么是软件过程软件过程是软件工程的基础。过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤 2. 什么是软件过程模型通常使用软件过程模型简洁地描述软件过程。生命周期模型规定了把生命周期划分成哪些阶段及各个阶段的执行顺序，因此，也成为软件过程模型。 软件过程模型：描述软件开发过程中各种活动如何执行的模型。对软件开发提供强有力的支持，为开发过程中的活动提供统一的政策保证，为参与开发的人员提供帮助和指导，是软件生存周期模型化技术的基础，也是建立软件开发环境的核心。 3. 常见的软件过程模型① 瀑布模型 waterfall model瀑布模型又称为经典生命周期，它提出了一个系统的、顺序的软件开发方法 开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈，因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来，如瀑布流水，逐级下落 瀑布模型的前提条件是：需求必须是准确定义且相对稳定的，对于经常变化的项目而言，瀑布模型毫无价值。 瀑布模型的特征： 各个阶段之间的顺序性和依赖性： 必须等前一阶段的工作完成之后，才能开始后一阶段的工作； 前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能获得正确的结果。 瀑布模型的优点： 可强迫开发人员采用规范的方法（例如，结构化技术）； 严格地规定了每个阶段必须提交的文档； 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证； 瀑布模型的缺点： 突出缺点是不适应用户需求的变化 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险 ② 快速原型模型所谓快速原型就是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。 快速原型的第一步是快速建立一个能反映用户主要需求的原型系统，让用户在计算机上试用它，然后用户会提出许多修改意见，开发人员按照用户的意见快速的修改原型系统，然后再次请用户试用…… 一旦用户认为这个原型系统满足了用户的需求，原型系统将被抛弃。也就是说，原型的作用就是为了获知用户的真正需求。 ③ 增量过程模型在许多情况下，初始的软件需求有明确的定义，但是整个开发过程中需要逐步为用户添加更多的功能，此时就用到了增量过程模型 使用瀑布模型或者快速原型模型开发软件的时候，目标都是一次就把一个满足所有需求的产品交给用户。而增量过程模型交付一系列称为增量的版本，随着每个版本的交付，再逐步为用户提供更多的功能 ④ 螺旋模型集合了瀑布模型和快速原型的优点，螺旋模型就相当于在每个阶段之前都增加了风险分析过程的快速原型模型。如果风险不能排除，则停止开发工作或大幅度消减项目规模，如果风险排除，则进入下一个开发步骤，这个工作过程和瀑布模型类似。 螺旋模型适用于内部开发的大规模软件项目，因为只有内部开发的项目，才能在风险过大时方便的中止项目。 ④ 喷泉模型“喷泉” 这个词体现了面向对象软件开发过程迭代和无缝的特性。 两个活动之间存在交迭，而面向对象方法在概念和方法上的一致性，保证了在各项开发活动之间的无缝过渡。 4. Rational 统一软件开发过程 / RUP① 什么是 RUPRational 统一过程（Rational Unified Process，RUP）是由Rational公司推出的一种完整且完美的软件过程 RUP 总结了经过多年商业化验证的 6 条最有效的软件开发经验，这些经验被称为 最佳实践 迭代开发 管理需求 使用基于构件的体系结构 可视化建模 验证软件质量 控制软件变更 ② RUP 的三大特点 软件开发是一个迭代过程 RUP强调软件开发是一个迭代模型(Iterative Model)，它定义了四个阶段(Phase)： 初始(Inception) 细化(Elaboration) 构造(Construction) 交付(Transition) 只有通过了上一阶段才能进入下一阶段，这种迭代模型的实现在很大程度上提供了及早发现隐患和错误的机会，因此被现代大型信息技术项目所采用。 软件开发是由用例驱动的 用例是RUP方法论中一个非常重要的概念。简单地说，一个用例就是系统的一个功能。在系统分析和系统设计中，用例被用来将一个复杂的庞大系统分割、定义成一个个小的单元，这个小的单元就是用例。然后以每个小的单元为对象进行开发。 按照RUP过程模型的描述，用例贯穿整个软件开发的生命周期。在需求分析中，客户或用户对用例进行描述，在系统分布和系统设计过程中，设计师对用例进行分析，在开发实现过程中，开发编程人员对用例进行实现，在测试过程中，测试人员对用例进行检验。 软件开发是以架构设计为中心的 构架设计(ArchitecturalDesign)是系统设计的一个重要组成部分。在构架设计过程中，设计师必须完成对技术和运行平台的选取，整个项目的基础框架( Framework)的设计，完成对公共组件的设计，如审计( Auditing)系统、日志(Iog)系统、错误处理(Exception Handling)系统、安全(Security)系统等。设计师必须对系统的可扩展性( Extensibility)、安全性(Security)、可维护性( Maintainability)、可延拓性(Scalability)、可重用性(Reusability)和运行速度(Performance)提出可行的解决方案。 5. 敏捷开发过程与极限编程① 什么是敏捷开发过程为了使软件开发团队具有高效工作和快速响应的能力，17 位著名的软件专家起草了敏捷软件开发宣言，由下述 4 个简单的价值观声明组成： 个体和交互胜过过程和工具 可以工作的软件胜过面面俱到的文档 客户合作胜过合同谈判 响应变化胜过遵循计划 根据上述价值观提出的软件过程称为敏捷开发过程，其中最重要的是极限编程 🚩 敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，都具备集成和可运行的特征。 换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。 敏捷开发属于增量式开发，对于需求范围不明确，需求变更较多的项目而言，可以很大程度上响应和拥抱变化。 敏捷开发最大程度体现 80/20 法则的价值，通过增量迭代，每次都优先交付那能产生 80% 价值效益的 20% 功能，最大化单位成本收益。 ② 什么是极限编程 XP极限编程（Extreme Programming，XP）是敏捷开发过程中最富盛名的一个，”极限” 二字的含义是指把好的开发实践运用到极致。极限编程广泛应用于需求模糊且经常改变的场合。 四、可行性研究1. 可行性研究的目的并非任何问题都能在预定的系统规模或时间期限内解决，可行性研究的目的就是用最小的代价在尽可能短的时间内确定问题是否能够解决。如果问题没有可行的解，分析员应该建议停止这项开发工程。 2. 从哪些方面进行可行性研究 技术可行性：使用现有的技术能实现这个系统吗 经济可行性：这个系统的经济效益能超过它的开发成本吗 操作可行性：系统的操作方式在这个用户组织内行得通吗 五、需求1. 什么是需求工程需求工程 （Requirement Engineering / RE） 制作一个软件的最终目的是满足客户的需求，然而开发人员往往无法准确理解客户的需求，又或是客户无法准确描述甚至根本不清楚自己的需求。试想在开发一个计算机软件时，如果软件解决的问题是错误的，那么即使软件再精巧也满足不了任何人的要求。 需求工程就是致力于不断理解需求。需求工程为理解客户需要，分析要求，评估可行性等工作提供了良好的机制，为设计和构造奠定了坚实的基础，如果没有需求工程，那么实现的软件很有可能无法满足用户的需求。 2. 需求分析① 什么是需求分析需求分析也称软件需求分析，是开发人员经过深入细致的调研和分析，准确理解用户的需求和项目的功能等要求，将用户非形式的需求表述转化为完整的需求定义，从而确定系统必须做什么的过程 需求分析的目标是分析系统在功能上要 “实现什么”，而不是 “如何实现” ② 需求分析的过程 / 基本任务 确定对系统的综合需求 功能需求 性能需求 可靠性和可用性需求 出错处理需求 接口需求 逆向需求：说明软件系统不应该做什么 约束 将来可能提出的需求 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 六、概要设计和详细设计1. 什么是概要设计概要设计也称总体设计，经过了需求分析之后，概要设计重点明确系统总体实现方案，确定软件的总体布局，各个子模块的功能以及各个子模块之间的关系，同时，还要设计系统的总体数据结构和数据库结构，并编写概要设计文档。 2. 概要设计的基本原理 模块化 抽象化 逐步求精 信息隐藏和局部化 使得一个模块内包含的信息对于不需要这些信息的模块来说，是不能访问的 模块独立 模块的独立程度可由两个标准度量： 耦合：不同模块之间的互连程度 内聚：一个模块内各个元素彼此结合的紧密程度 力争低耦合、高内聚 3. 什么是详细设计概要设计之后，进入详细设计阶段。重点明确每个模块该如何实现，确定每个模块使用的数据结构、算法等，并编写详细设计说明书 七、软件测试1. 软件测试的概念、目标和原则概念： 软件测试是使用人工或自动的手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。 目标： 测试的目的在于发现错误； 一个好的测试用例是发现了至今尚未发现的错误的测试用例； 一个成功的测试时发现了至今尚未发现的错误的测试 原则： 测试用例应由输入数据和预期的输出数据两部分组成。这样便于对照检查，做到有的放矢。 测试且例不仅选用合理输入数据，还要选择不合理的输入数据。这样能更多地发现错误，提高程序的可靠性。对于不合理的输入数据，程序应拒绝接受，并给出相应的提示。 除了检查程序是否做了它应该做的事，还应该检查程序是否做了它不应该做的事。 应制定测试计划并严格执行，排除随意性。 长期保留测试用例。 对发现错误较多的程序段，应进行更深入的测试。 程序员应避免测试自己的程序。测试是一种”挑剔性”的行为，心理状态是测试自己程序的障碍。 2. 白盒测试法① 什么是白盒测试法白盒法测试法把测试对象看作一个打开的盒子，测试人员须了解程序内部结构和处理过程，以检查处理过程的细节为基础，对程序中尽可能多的逻辑路径进行测试，检验内部控制结构和数据结构是否有错，实际的运行状态与预期的状态是否一致。 ② 逻辑覆盖从覆盖源程序语句的详尽程度分析，大致有以下一些不同的覆盖标准： 语句覆盖：至少每个语句应该执行一次。语句覆盖是很弱的逻辑覆盖标准 🎲 测试用例：A = 2，B = 0，X = 4 判定覆盖：不仅每个语句必须至少执行一次，而且每个判定的每个分支都至少执行一次 🎲 以上图为例，测试用例： A = 3，B = 0，X = 3（覆盖 sacbd） A = 2，B = 1，X = 1（覆盖 sabed） 条件覆盖：不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果 以上图为例，有两个判定表达式，每个表达式中有两个条件，为了做到条件覆盖， 在 a 点，应有下述各种结果出现： A &gt; 1，A ≤ 1，B = 0，B ≠ 0 在 a 点，应有下述各种结果出现： A = 2，A ≠ 2，X &gt; 1，X ≤ 1 🎲 测试用例： A = 2，B = 0，X = 4（覆盖 sacbed） A = 1，B = 1，X = 1（覆盖 sabd） 判定/条件覆盖：使得判定表达式中的每个分支都至少执行一次，而且每个判定表达式中的每个条件都取到各种可能的结果 🎲 以上图为例，测试用例： A = 2，B = 0，X = 4 A = 1，B = 1，X = 1 条件组合覆盖：每个判定表达式中条件的各种可能组合都至少出现一次 3. 黑盒测试法① 什么是黑盒测试法黑盒测试法把被测试对象看成是一个黑盒子，测试人员完全不考虑程序的内部结构和处理过程，只在软件接口处进行测试，依据需求规格说明书，检查程序是否满足功能要求。 黑盒测试能发现的错误类型： 不正确或遗漏的功能 接口错误 数据结构或外部数据库访问错误 行为或性能错误 初始化或终止错误 白盒测试一般在测试过程的早期执行，而黑盒测试倾向于应用在测试的后期阶段。 下面讲解两种黑盒测试技术 等价划分 边界值分析 ② 等价划分将程序的输入划分为若干个数据类，从中生成测试用例。理想的测试用例是可以单独发现一类错误 ③ 边界值分析 BVA一般来说，大量的错误发生在输入域的边界处，而不是发生在输入域的中间。 边界值分析 Boundary Value Analysis 选择测试用例检查边界值 一般来说除了使用等价划分设计出的测试方案外，还应该使用边界值分析法再补充下测试方案 八、软件架构1. 什么是软件体系结构软件体系结构是指系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系。 2. 软件架构的重要性体系结构的重要性： 软件体系结构提供了一种表示，有助于对计算机系统开发感兴趣的利益相关者开展交流 体系结构突出了早期的设计决策，这些决策对随后的所有软件工程工作都有深远的影响 体系结构构建了一个相对较小的、易于理解的模型，该模型描述了系统如何构成以及构件如何一起工作 软件架构的重要性在于它决定了—个系统的主体结构、宏观特性和具有的基本功能。复杂软件设计的成功在于软件系统有宏观层次上结构设计的正确性和合理性。 九、软件工程的人员方面1. 软件工程师应有的特质软件工程师应具备的七种特质 责任感 高度的公平感 / 避免利益冲突和破坏他人劳动成果 对用户和团队成员的需求有敏锐的意识 良好的抗压能力 实事求是 / 坦诚 遵守科学规则 / 务实 注重细节 十、软件项目管理1. 软件项目管理和软件开发的关系所谓管理，就是合理的配置和使用各种资源，以达到既定目标的过程。 软件项目管理先于任何技术活动之前，并且贯穿于整个软件生命周期中。 大多数软件的规模都很庞大，单个软件开发人员无法在规定期限内完成开发工作，因此必须通过软件项目管理把多名软件开发人员合理的组织起来，使他们有效的分工协作共同完成开发任务。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://aaronyard.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"浅谈游戏安全","slug":"GameSecurity","date":"2020-03-06T12:22:18.000Z","updated":"2020-04-06T15:10:47.280Z","comments":true,"path":"2020/03/06/GameSecurity/","link":"","permalink":"https://aaronyard.github.io/2020/03/06/GameSecurity/","excerpt":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科","text":"网络游戏现状市面上手机游戏数不胜数，在众多玩家玩的不亦乐乎的时候，总有那么一小撮拥有技术的人不安分，他们开发出了外挂修改器，甚至直接修改游戏安装包。对于部分玩家来说，外挂是超级作弊器，可以无条件获得任何想要的装备，对他们有益。但是对于游戏开发商来说，这无异于晴天霹雳。 什么是外挂外挂，又叫开挂、开外挂、辅助、修改器，一般指通过修改游戏数据而为玩家谋取利益的作弊程序或软件，即利用电脑技术针对一个或多个软件进行非原设操作，篡改游戏原本正常的设定和规则，大幅增强游戏角色的技能和超越常规的能力，从而达到轻松获取胜利、奖励和快感的好处，通过改变软件的部分程序制作而成的作弊程序。 主要应用原理是在游戏中用封包和抓包工具对游戏本身或游戏服务器提交假参数从而改变游戏中的人物能力。 使用外挂具有一定风险，特别是在非单机游戏中使用破坏游戏公平性的外挂，可能还会被封禁账号。 —来自百度百科 外挂的弊端一些外挂会破坏游戏的平衡，造成网络游戏的极度不公平，影响正常玩家的游戏体验，若长时间不控制，正常玩家会逐渐流失。 外挂的种类1、外挂修改器，独立于手机之外的一个小软件，原理是修改内存，有时即使时特意通过第三方加固过的安装包也无法杜绝数据内存被修改。 2、外挂包，即安装包的包体被修改，替换了dll以及so库等。 应对方法我经历的项目有幸被这两种外挂盯上，由于在开发阶段部分功能没有做好数据加密防护，在被外挂魔改之后，达成了一刀秒杀，满攻速，免疫所有伤害等，所幸咱也不怕，兵来将挡，水来土掩，开始与外挂斗智斗勇。 对于外挂修改器，对核心数据进行加密，修改一下存储的数据类型，就可以杜绝大部分外挂修改器的修改，其次，可以对数据进行基本的校验，比如存储时将数据分别*2和/2，三份数据均存在本地，取数据时再进行校验，如果数据不对就闪退。 对于包体被修改，可以在打包之后对包体内的文件进行md5校验，运行游戏的时候如果发现md5不对就闪退。也可以使用第三方加固包体的服务，使得包体无法再被修改。 另外，终极大招就是在服务器端对数据进行校验，这样外挂就无机可乘了。 相关代码可以参考以下代码 DBTools.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485using System;using System.Collections.Generic;using System.Linq;using System.Security.Cryptography;using System.Text;using System.Threading.Tasks; namespace DBTools&#123; public class Encryption &#123; /// &lt;summary&gt; /// 加密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Encrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); byte[] inputByteArray; inputByteArray = Encoding.Default.GetBytes(Text); des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); StringBuilder ret = new StringBuilder(); foreach (byte b in ms.ToArray()) &#123; ret.AppendFormat(\"&#123;0:X2&#125;\", b); &#125; return ret.ToString(); &#125; /// &lt;summary&gt; /// 解密数据 /// &lt;/summary&gt; /// &lt;param name=\"Text\"&gt;&lt;/param&gt; /// &lt;param name=\"sKey\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Decrypt(string Text, string sKey) &#123; DESCryptoServiceProvider des = new DESCryptoServiceProvider(); int len; len = Text.Length / 2; byte[] inputByteArray = new byte[len]; int x, i; for (x = 0; x &lt; len; x++) &#123; i = Convert.ToInt32(Text.Substring(x * 2, 2), 16); inputByteArray[x] = (byte)i; &#125; des.Key = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); des.IV = ASCIIEncoding.ASCII.GetBytes(System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(sKey, \"md5\").Substring(0, 8)); System.IO.MemoryStream ms = new System.IO.MemoryStream(); CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write); cs.Write(inputByteArray, 0, inputByteArray.Length); cs.FlushFinalBlock(); return Encoding.Default.GetString(ms.ToArray()); &#125; // MD5 32 位 public static String Encrypt32(String convertString) &#123; MD5 md5 = new MD5CryptoServiceProvider(); byte[] bytes = System.Text.Encoding.UTF8.GetBytes(convertString); bytes = md5.ComputeHash(bytes); md5.Clear(); string ret = \"\"; for (int i = 0; i &lt; bytes.Length; i++) &#123; ret += Convert.ToString(bytes[i], 16).PadLeft(2, '0'); &#125; return ret.PadLeft(32, '0').ToLower(); &#125; // MD5 16 位 public static string Encrypt16(string convertString) &#123; MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); string t2 = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(convertString)), 4, 8); t2 = t2.Replace(\"-\", \"\"); return t2.ToLower(); &#125; &#125;&#125; 编码时： 123//LoginPwd--要加密的数据。也可以将二进制值传递给此函数。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。//Master--用来对 LoginPwd 进行加密的加密密钥。解密时必须使用同一密钥才能获得原始值。此参数区分大小写，即使是在不区分大小写的数据库中也是如此。string Pwd = DBTools.Encryption.Encrypt(LoginPwd, \"Master\"); 与大多数口令一样，最好选择无法被轻易猜到的密钥值。建议选择满足以下条件的密钥值：长度至少为 16 个字符，混合使用大小写并包含数字、字母和特殊字符。每次要对数据进行解密时，都需要使用此密钥。 解码时： 1string Pwd = DBTools.Encryption.Decrypt(LoginPwd, \"Master\"); ##总结 魔高一丈道高一尺，遇到外挂不要害怕，他们并不可怕，钻研外挂的原理，从源头上击垮他们。在项目立项之初，也要有数据加密的意识，一些重要的运算放在服务器端，客户端只做展示，不给外挂可乘之机。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"计算机网络面试指南","slug":"计算机网络/计算机网络面试指南","date":"2020-02-29T14:02:45.000Z","updated":"2020-09-04T15:48:52.315Z","comments":true,"path":"2020/02/29/计算机网络/计算机网络面试指南/","link":"","permalink":"https://aaronyard.github.io/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"🔍 计算机网络 面试指南 一、网络模型1. 思维导图 ⚠ 把下图中标黄的五层参考模型 改为 七层参考模型 2. 七层网络模型","text":"🔍 计算机网络 面试指南 一、网络模型1. 思维导图 ⚠ 把下图中标黄的五层参考模型 改为 七层参考模型 2. 七层网络模型 物理层 数据链路层（CSMA、CSMA/CA、CSMA/CD、ARQ） 网络层（IP、ARP（IP-&gt;MAC）、RARP (MAC-&gt;IP)、ICMP） 传输层（TCP、UDP） 会话层（通信管理。负责建立和断开通信连接，管理传输层以下的分层。何时建立连接、何时断开以及保持多久的连接） 表示层（设备固有数据格式和网络标准数据格式之间的转换） 应用层(DNS、DHCP、HTTP、HTTPS) TCP/IP 与 OSI 七层模型相比： 简化了高层的协议，将会话层和表示层融进了应用层，使得系统的层次减少，提高了通信的效率。 一般我们学习的都是五层参考模型： 3. 计算机网络中各层的作用 物理层的作用 在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 数据链路层 数据链路层在物理层提供的服务的基础上向网络层提供服务，将原始的、有差错的物理线路改进成逻辑上 无差错的数据链路，从而向网络层提供高质量的服务。数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。功能主要有： ①链路管理； ②封装成帧； ③透明传输； ④差错检测 网络层的作用 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成IP数据报/分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 传输层的作用 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的可靠传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 应用层的作用 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 4. 为什么要分层 各层之间相互独立：高层不需要知道底层的功能是如何实现的，它只需要通过底层提供的接口获取服务即可 灵活性好：各层都可以采用最适当的技术来实现，如果某一层的实现技术发生了变化，但只要实现接口不变，该层的变化就不会对其他各层以及整个系统的工作产生影响 易于实现和标准化：由于采用了规范的层次结构取组织网络功能和协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与交互过程，有利于将网络复杂的通信过程化简为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于实现和标准化 5. 什么是点到点通信和端到端通信 点到点通信：主机到主机的通信 端到端通信：进程和进程之间的通信 6. 面向有连接和面向无连接通过网络发送数据，大致可以分为面向有连接型和面向无连接型 面向有连接型： 在发送数据前，需要在收发主机之间建立一条通信线路。 在面向有连接的方式下，必须在通信传输前后，专门进行建立和断开连接的处理。如果与对端之间无法通信，就可以避免发送无谓的数据。 面向无连接型： 发送端可于任何时候自由发送数据，而接收端永远不知道自己会在何时从哪里接收到数据。因此，在面向无连接的情况下，接收端需要时常确认是否收到了数据。 7. 单播、广播、多播、任播 单播：1 对 1 通信。比如固定电话 广播：1 对 多 通信。比如电视播放 多播：1 对 多 通信，但是这个 多 是限定的某一组主机。比如远程会议 任播：1 对 1 通信，在特定的多台主机中任意选出一台作为接收端。比如 DNS 根域名解析服务器 8. Internet 和 WWW 的关系Internet：因特网。泛指全世界各国计算机网络用各种传输介质相互连接起来的的集合，也称为网络的网络。Internet 提供的主要服务有 万维网 WWW 文件传输 FTP 电子邮件 E-Mail 远程登录 Telnet WWW：World Wide Web 万维网。是无数个网页和站点的集合，万维网是全世界最大的资料空间，空间中的资源通过唯一的 URL 统一资源定位符来表示。这些资源通过 HTTP 协议传输给用户，用户通过点击超链接获取资源。 二、物理层1. 思维导图 2. 物理层功能在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 3. 三种通信方式 单工通信 发送方和接收方固定，单向传输，仅需要一条信道（类比广播） 半双工通信 通信的双方都可以发送和接收，但不能同时发送和接收，交替传输，需要两条信道（类比对讲机） 双工通信 双方可以同时发送和接收，双向同时传输（类比打电话） 单工只要一条信道，而半双工和全双工需都需要两条信道（每个方向各一条）。 4. 串行/并行传输 串行传输 将表示一个字符的8位二进制数按照从低位到高位的顺序，在一条信道按照顺序发送 速度慢，费用低，适合远距离 并行传输 将表示一个字符的8位二进制数同时通过8条信道发送，接收方再根据顺序重新组装这些数据 速度快，费用高，适合近距离 5. 同步/异步传输 同步传输 同步传输就是发送方和接收方的时钟要同步，数据的传送以一个数据块为单位，因此同步传输也称区块传输。采用同步符号作为数据开始和结束的标志。 异步传输 异步传输就是发送方和接收方没有时钟同步，将比特分成小组进行传送，采用起始位和终止位作为数据开始和结束的标志。发送方可以在任何时刻发送这些比特组，而接收方从不知道它们会在什么时候到达。一个常见的例子是计算机键盘与主机的通信。 6. 物理层设备 中继器 集线器（多端口中继器） 作用：扩大信号的传输距离 三、数据链路层1. 思维导图 2. 数据链路层功能 数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传,数据链路层在物理层提供服务的基础上为网络层提供服务。 其最基本的服务是将来自网络层的IP数据报封装成帧，可靠的传输到相邻结点的目标网络层。 其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 功能概述： 为网络层提供服务 链路管理，即连接的建立，维持，释放 组帧 流量控制（限制发送方） 差错控制 3. 数据链路层协议① CSMA 载波监听多路访问协议 载波监听：侦听媒体是否空闲（先听再说） 多路访问：多个结点共享媒体，多个结点同时获取信息 ② CSMA/CD 载波监听多点接入/碰撞检测 ⭐先听再说，边听边说（一边发送一边检测其他站是否也在发送数据），冲突停发、随机重发 CSMA/CD 协议用于有线局域网 ③ CSMA/CA 载波监听多点接入/碰撞避免 ⭐先听再说，监听到信道空闲时不立即发送数据，而是先发送一个小的RTS帧，告知对方将要发送的数据长度和频段选择，如果收到最近结点返回的CTS，再发送数据。接收端如果正确收到此数据帧，则经过一段时间间隔后，向发送端发送确认帧ACK。 发送端收到ACK帧，确定数据正确传输，再经历一段时间间隔后，再发送数据。 CSMA/CA 协议用于无线局域网，因为无线传输的信号波动较大，实时检测碰撞对硬件要求较高 ④ PPP点对点协议目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。面向字节；不需要的功能：纠错（PPP协议只负责检错）、流量控制（由TCP 负责）、序号（PPP协议是不可靠传输协议，故不需要对帧进行编号）、多点线路（PPP协议是点对点 的通信方式）、半双工或单工（PPP只支持全双工链路） ⑤ ARQ 协议 / 停等协议 ⭐停止等待协议是数据链路层（有些书说是传输层）为保证可靠传输，以流量控制为目的的一个协议。通过滑动窗口来限制发送方的发送速度 有些书中将这个协议放在运输层 以下三种协议都包含 自动重传请求（Automatic Repeat Request）ARQ，所以也称 ARQ 协议 传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。 ① 停等协议（停等式ARQ） 在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。 停等式ARQ，发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。该方法所需要的缓冲存储空间最小，缺点是信道效率很低。 ② 后退N帧协议 GBN（后退N帧的ARQ） 发送窗口 &gt;= 1，接收窗口 = 1 , 发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。 特点：（GBN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的 ③ 选择重传协议 SR（选择性重传ARQ） 发送窗口 &gt;= 1，接收窗口 &gt;= 1 , 发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。 特点：相对于GBN 复杂度高，但是不需要发送没必要的帧，所以效率高。 4. 频分复用 时分复用 波分复用 码分复用 ⭐ 频分复用 FDM：给每个信号分配唯一的载波频率，用户在分到一定的频带后，在通信过程中自始至终一直都占用这个频带。频分复用的所有用户在同样的时间内占据不同的带宽资源。 时分复用 TDM：把多个信号复用到单个硬件传输信道，它允许每个信号在一个很短的时间使用信道，接着再让 下一个信号使用。 波分复用 WDM：就是光的频分复用。用一根光纤同时传输多个频率很接近的光载波信号。 码分复用 CDM：码分复用是用一组包含互相正交的码字的码组携带多路信号。每一个用户可以在同样的时间使 用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，各用户之间不会造成干扰，因此这种 系统发送的信号有很强的抗干扰能力。 5. 频分复用如何避免各路信号间的干扰频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传输的信号互不干扰，应在各子信道之间设立隔离带（也就是保护频带，即插入一些空白的频段 ），这样就保证了各路信号互不干扰。 6. 链路层设备 网桥 交换机（多接口网桥） 功能：根据MAC帧的目的地址对帧进行转发和过滤。当网桥/交换机 收到一个帧的时候，并不向所有接口转发此帧（集线器），而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口，或者是把他丢弃 网桥/交换机 的功能在延长网络跨度上类似于中继器/集线器，然而它能提供智能化连接服务，即根据帧的终点地址处于哪一网段来进行转发和滤除 7. 连接两个局域网需要用什么设备 连接两个局域网，即连接两个同类型网络，需要使用网桥或者交换机，工作在数据链路层。 连接两个不同类型的网络，比如局域网和互联网，使用路由器，工作在网络层。 四、网络层1. 思维导图 ⚠ 下图思维导图有个错误：DHCP协议是应用层协议 2. 网络层功能在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。 网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 网络层功能概述： 路由选择与分组转发 异构网络互联 拥塞控制 3. 网络的分类 4. 网络层协议① IP 协议提供无连接的（为了简单化和高速化）、不可靠的、尽力的（为了把数据包发送到最终目标地址，尽最大努力，但并不保证最终收到的数据是否完整或正确）数据报投递服务，IP 协议屏蔽下层物理网络的差异，为上层提供统一的 IP 数据报 ② ICMP 网际报文控制协议IP 数据包的丢失，由路由器发送 ICMP 报文告知（ICMP报文由路由器产生， 被封装在IP数据报的数据区中进行传输） ③ ARP 地址解析协议 ⭐ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。 工作原理： 每个主机都有一个 ARP 高速缓存，里面有本局域网中各个主机和路由器的 IP 地址到 MAC 地址的映射 如果 A 主机想要和 B 主机进行通信，则先查找 ARP 高速缓存中有没有 B 主机的 IP 地址到 MAC 地址的映射 若没有，则 A 主机以广播方式发送 ARP 请求分组（该分组携带 A 主机的 IP 地址和 MAC 地址以及 B 主机的 IP 地址），其他主机收到该请求分组后丢弃，B 主机接收到该分组后，发送 ARP 响应分组 给 A 主机告知其 MAC 地址 主机 A 收到 B 发来的 ARP 响应分组，则将 B 主机 IP 地址 和 MAC 地址的映射存入 ARP 高速缓存中 ④ RARP 反向地址解析协议RARP 实现由 MAC 地址得到 IP 地址 ⑤ 动态路由转发协议内部网关协议：(一个自治系统AS内的网关协议) RIP 路由信息协议：仅和邻居交换信息，且交换的是整个路由表，适用于小规模网络，传输层使用 UDP 协议。RIP 选择路由的标准是 距离，要求途中经过的路由器个数越小越好，距离超过 15 表示不可达。 OSPF 开放最短路由协议：向自治域中所有路由器发送信息，且发送的是链路状态表，根据代价选择最佳路由，基于 IP 协议。OSPF 选择路由的标准是 带宽（代价），始终选择代价最小的路径作为最终路由。底层实现算法是 Dijkstra 最短路径算法 外部网关协议： BGP 外部网关协议：不同AS的路由器之间交换路由信息的协议。基于 TCP 协议 5. 电路交换，报文交换，分组交换之间的区别以及联系 ⭐为什么要数据交换：如果没有数据交换，每两个主机之间就需要一条数据链路，如果主机非常多的话，那么需要的数据链路也非常之多，费用和维护难度都非常高。交换是通过某些交换中心将数据进行集中和传送，传输线路为各个用户共用，从而大大节省通信线路，降低系统费用 电路交换：类似打电话，独占这条线路，其他人无法参加，需要建立连接，比特流直达，速度快（电路交换传bit流，发生在物理层） 报文交换：报文是应用层传输单位，即站点一次性要发送的数据块，无须建立连接，采用存储转发的方式，速度较慢（报文交换传报文，发生在应用层） 分组交换：是将较大的数据分割成小块，在每个分组的首部写入发送端和接收端的地址，无须建立连接，采取存储转发的方式，速度比报文交换快，比电路交换慢，可能产生分组丢失，乱序的情况（分组交换传分组/IP数据报，发生在网络层） 6. 分组交换的优点和缺点与报文交换相比较，分组交换的优点和缺点如下。 优点： ① 加速传输：因为分组交换是逐个传输，所以可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间，此外，传输一个分组所需的缓冲区比传输一个报 文所需的缓冲区小得多，这样因缓冲区不足而等待发送的几率及等待的时间也必然减少。 ② 简化了存储管理：分组的长度固定，相应的缓冲区大小也固定。 ③ 减少出错几率和重发数据量：因为分组较短，其出错几率必然减少，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。 缺点： ① 存在传输时延：尽管与报文交换相比的传输时延较短，但是与电路交换相比仍然存在存储转发时延， 而且对其结点交换机的处理能力有更高的要求。 ② 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达的目的地的结点时，要对分组按编号进行排序工作，工作量较大。 7. IPv4地址缺乏的解决办法(替代方案) NAT 网络地址转换：根据NAT转换表，NAT路由器将 专用网上的IP地址 和 因特网上的外部全球唯一IP地址 进行转化 子网划分：将传统的二级 IP 地址划分为 三级 IP 地址，二级 IP 地址中的 网络号 分为网络号 + 子网号，缩小地址分配空间 动态分配 IP 地址（应用层 DHCP 协议）：由于IP地址资源很宝贵，因此大部分用户上网都是使用动态IP地址的，在需要的时候才进行IP地址分配 32位的IPV4地址空间已分配殆尽，以上方式只能是治标不治本，启用 IPV6 才能从根本上解决地址耗尽问题 8. IPV6 在 IPV4 的基础上做了哪些改进 更大的地址空间：IPV4 是 32 位，IPV6 是 128 位 简化了 IP 报头的格式 IPV6 支持动态配置（即插即用），不需要 DHCP 协议进行动态配置 IP 地址 IPV6 首部长度是 8B 的 整数倍，IPV4 首部长度是 4B 的整数倍 IPV6 支持对数据进行确认和加密 9. IPv4和IPv6如何相互通信？IPV4 向 IPV6 过渡的策略： 双栈协议：同时启用 IPV4 和 IPV6 协议栈 隧道技术：将其他协议的数据帧或包重新封装然后通过隧道发送 10. 网络设备 - 路由器路由器从功能上可以划分为：路由选择和分组转发。 11. 路由器和交换机的区别 交换机工作在数据链路层，交换机根据MAC地址寻址。 路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。 路由器可以为局域网自动分配IP和虚拟拨号。 交换机只是用来分配网络数据的。 路由器可以把一个IP分给多个主机使用，对外IP相同。 交换机可以把很多主机连接起来，对外的IP不同。 路由器可以提供防火墙，交换机不能提供这个功能。 交换机是做扩大局域网接入点的，可以让局域网连进更多的电脑，用来连接相同类型的网络。 路由器是用来做网间连接，也就是用来连接不同网络的。 12. 路由和路由器的区别路由 route, 将一个URL路径和一个函数进行映射 路由器是 router, 可以理解为一个容器，或者说一种机制，它管理了一组 route, 进行相应的路由转发 总结一句话：The router routes you to a route 五、运输层1. 思维导图 2. 运输层功能运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。 由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 主要功能总结如下： 传输层提供进程和进程之间的逻辑通信（网络层提供主机间的通信） 复用和分用 传输层对接收到的报文进行差错检测 TCP/UDP协议 3. TCP与UDP的连接区别及适用情况 用户数据报协议 UDP（User Datagram Protocol） UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比 如： QQ 语音、 QQ 视频 、直播等等 传输控制协议 TCP（Transmission Control Protocol） TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有校验和、确认、序号、重传、流量控制、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 4. TCP三次握手/四次握手 ⭐① 三次握手过程（连接建立） SYN：连接请求/接收 报文段 seq：发送的第一个字节的序号 ACK：确认报文段 ack：希望收到的下一个数据的第一个字节的序号 具体流程： 客户端：发送连接请求报文段 SYN， 无应用层数据。 服务器端：为该TCP连接分配缓存和变量，并向客户端返回确认报文段ACK，允许连接，无应用层数据。 客户端：为该TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据。 ② 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 ③为什么要传回 SYN接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK响应，表示确认发来的数据已经接受无误。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。 SYN洪泛攻击：攻击者发送大量的TCP SYN，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态（半连接状态），服务器收不到再确认的话，还会重复ACK给攻击者，这样更加浪费服务器的资源。 ④ 传了 SYN, 为啥还要传 ACK双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 ⑤ 四次握手过程（连接释放） FIN ：连接终止位 具体过程： 客户端：发送连接释放报文段FIN，停止发送数据，主动关闭TCP连接。 服务器端：回送一个确认报文段ACK。客户到服务器这个方向的连接就被释放了 ——&gt; 半关闭状态 服务器端：发送连接释放报文段FIN，停止发送数据，主动关闭TCP连接。 客户端：回送一个确认报文段ACK，再等到时间等待计时器设置的2MSL后(最长报文段寿命)，服务器到客户这个方向的连接就被释放了——连接彻底关闭 ⑥ 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子： A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 5. 什么是滑动窗口协议 ⭐流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP实现流量控制主要是 滑动窗口协议， 使用这种方法的时候，发送方和接收方向外通信各使用一个窗口。窗口大小取决于下面两个数：接收窗口（rwnd）和拥塞窗口（cwnd）。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段 rwnd 设置为 0，则发送方不能发送数据。 （接收方根据自己接收缓存的大小，即接收窗口rwnd，动态的调整发送方的发送窗口大小，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值） 滑动窗口协议的实际应用：数据链路层的三个ARQ协议 6. 流量控制在哪些层实现流量控制就是要控制发送方数据传输的速率，使接收方来得及接收 传输层 TCP流量控制，利用滑动窗口机制控制发送方的速度 数据链路层/传输层 ARQ停等协议 7. 拥塞控制网络中存在太多的数据包导致数据包被延迟或丢失，从而降低了整个网络的传输性能，这种情况叫做拥塞。 如果产生网络拥塞，则网络的性能明显下降，整个网络的吞吐量将随着输入负荷的增大而下降。 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。 拥塞控制的4种算法： ① 慢开始算法（指数增长） ② 拥塞避免算法（加法增大，乘法减小） ③ 快重传算法 ④ 快恢复算法 8. TCP是如何实现可靠传输的 差错检测： 校验：增加伪首部 序号：一个字节占一个序号，按序对发来的数据进行组装接收 确认：累计确认 重传：发送方在规定时间内没有收到确认就要重传已发送的报文段 流量控制：利用滑动窗口机制控制发送方的速率 拥塞控制：当网络阻塞时，减少数据的发送 9. 网关 Gateway / 4-7 层交换机网关（Gateway）设备又称网间连接器、协议转换器，是多个网络间提供数据转换服务的计算机系统或设备。可以说网关设备就是不同网之间的连接器，就是数据要从一个网到另外一个网时要经过“协商”的设备。 网关工作在 OSI/RM 的传输层及以上的所有层次，通过重新封装信息来使它们能够被另一种系统处理。 事实上现在的网关已经不能完全归为一种网络硬件，而可以概括为能够连接不同网络的软件和硬件的结合产品。 一个非常典型的例子就是互联网邮件与手机邮件的转换服务。 手机邮件与互联网邮件有时候可能会不兼容，这是由于他们在表示层和应用层中的 “ 电子邮件协议 ” 互不相同导致的。 那么，为什么连到互联网的电脑与手机之间能够互发电子邮件呢？ 因为互联网与手机之间设置了一道网关。网关负责读取完各种不同协议后，对他们逐一进行合理的转换，再将相应的数据转发出去。这样一来即使应用的是不同电子邮件协议，计算机与手机之间也能互相发送邮件。 六、应用层1. 思维导图 ⛔ 应用层的思维导图中应加入DHCP协议 2. 应用层功能应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 主要功能总结如下： 文件传输、访问和管理 FTP 电子邮件 SMTP，POP3 虚拟终端 HTTP 查询服务和远程作业登录 DNS 3. 应用层协议 ⭐① DNS 地址解析协议将域名解析成IP地址 域名解析方式： 递归查询（比较少用，靠别人） 迭代查询（靠自己） 基本原理： 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表； 若没有，则搜索操作系统的DNS缓存； 若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找： 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址； 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址； 本地域名服务器向权限域名服务器发起请求，得到IP地址； 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来； 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来； 至此，浏览器已经得到了域名对应的IP地址。 ② DHCP 动态主机配置协议DHCP 动态主机配置协议：提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 对想要上网的用户分配 IP 地址，使用完毕后回收 IP 地址。 DHCP 是基于 UDP 的，客户和服务器之间采用 广播 形式进行交互 流程如下： 主机广播 DHCP 发现报文，试图寻找 DHCP 服务器 DHCP 服务器广播 DHCP 提供报文，服务器拟分配一个 IP 地址及相关配置给主机 主机广播 DHCP 请求报文，请求获得 IP 地址 DHCP 服务器广播 DHCP 确认报文，正式地将 IP 地址分配给主机 ③ HTTP 超文本传输协议超文本传输协议，所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 见下文详解 👇 ④ FTP 文件传输协议FTP 协议需要建立两个 TCP 连接，需要使用两个端口号，建立连接使用 21 端口，数据传输使用 20 端口 ⑤ SMTP 邮件发送协议SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。 ⑥ POP3、IMAP 邮件接收协议 POP3：用户从服务器上读取该邮件后，邮件就被删除了 IMAP：用户可以看见邮箱的首部，当用户打开邮件的时候，邮件才传到用户的服务器上。只有用户手动删除，这个邮件才会被删除。IMAP 使得用户可以随时随地的处理邮件。 4. 打开一个网页网络通信过程 ⭐打开一个网页网络通信过程： 应用层：首先通过DNS协议进行域名解析，获得IP地址，具体过程如下： 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表； 若没有，则搜索操作系统的DNS缓存； 若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找： 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址； 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址； 本地域名服务器向权限域名服务器发起请求，得到IP地址； 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来； 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来； 至此，浏览器已经得到了域名对应的IP地址。 浏览器发送HTTP请求； 接下来到了传输层，TCP三次握手建立连接； 接下来到来网络层，建立TCP连接时需要传送数据，传送数据在网络层使用IP协议，通过IP协议将IP地址封装为IP数据报； IP数据报在路由器之间进行传送的时候，需要使用路由选择协议OSPF； 路由器在与服务器通信的时候，需要将IP地址转换为MAC地址，此时就需要使用ARP协议；主机发送信息时将包含目标IP地址，将ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址； 接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的MAC地址开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层； 服务器响应浏览器发送的HTTP请求并请求客户端要的资源，传回给客户端； 断开TCP连接，浏览器通过HTTP协议对页面进行渲染呈现给客户端。 总结以上过程，用到的协议依次为： DNS ——&gt; HTTP ——&gt; TCP ——&gt; IP ——&gt; OSPF ——&gt;ARP ——&gt;HTTP 5. HTTP 协议① HTTP持久连接（长连接），非持久连接（短连接）在HTTP/1.0中默认使用非持久连接 close (短连接)。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。 从HTTP/1.1起，默认使用持久连接 keep-alive (长连接)，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 TCP短连接模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。 TCP长连接我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 ② HTTP是不保存状态的协议,如何保存用户状态?HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？ Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。 在服务端保存 Session 的方法很多，最常用的就是内存和数据库。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。 Cookie 被禁用怎么办? 最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。 ③ Cookie的作用是什么? 和Session有什么区别？Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie 一般用来保存用户信息 比如:① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。 Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 SessionID 之后就可以标识这个用户并且跟踪这个用户了。 Cookie 存储在客户端（浏览器）中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。 ④ URI和URL的区别是什么? URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URL(Uniform Resource Location)是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何找到这个资源。 URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。 URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。 ⑤ 状态码状态码是HTTP响应报文部分响应行中的内容 响应行包括 1）报文协议及版本； 例如： 1HTTP/1.1 200 OK 2）状态码及状态描述； 状态码：由3位数字组成，第一个数字定义了响应的类别。响应码详细如下。 1xx：指示信息，表示请求已接收，继续处理 2xx：成功，表示请求已被成功接受，处理。 200 OK：客户端请求成功 204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。 206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容 3xx：重定向 301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。 302 Found：临时重定向，表示请求的资源临时搬到了其他位置 303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问 304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有 307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET 4xx：客户端错误 400 Bad Request：客户端请求有语法错误，服务器无法理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在。比如，输入了错误的url 415 Unsupported media type：不支持的媒体类型 5xx：服务器端错误，服务器未能实现合法的请求。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ⑥ HTTP 断点续传概念：断点续传指的是下载传输文件可以中断，之后重新下载时可以接着中断的地方开始下载，而不必从头开始下载。断点续传需要客户端和服务端都支持。 原理：原理是客户端一块一块的请求数据，最后将下载回来的数据块拼接成完整的数据。其实就是在Http的请求上和一般的下载有所不同而已。 打个比方，浏览器请求服务器上的一个服务，所发出的请求如下： 假设服务器域名为 www.baidu.com，文件名为down.zip。 1234567GET /down.zip HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms- excel, application/msword, application/vnd.ms-powerpoint, */* Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0) Connection: Keep-Alive 服务器收到请求后，按要求寻找请求的文件，提取文件的信息，然后返回给浏览器，返回信息如下： 12345678200 Content-Length=106786028 Accept-Ranges=bytes Date=Mon, 30 Apr 2001 12:56:11 GMT ETag=W/&quot;02ca57e173c11:95b&quot; Content-Type=application/octet-stream Server=Microsoft-IIS/5.0 Last-Modified=Mon, 30 Apr 2001 12:56:11 GMT 所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给Web服务器的时候要多加一条信息 – 从哪里开始。 比如要求从2000070字节开始。 1234GET /down.zip HTTP/1.0 User-Agent: NetFox RANGE: bytes=2000070- Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 仔细看一下就会发现多了一行 RANGE: bytes=2000070- 这一行的意思就是告诉服务器down.zip这个文件从2000070字节开始传，前面的字节不用传了。 服务器收到这个请求以后，返回的信息如下： 12345678206 Content-Length=106786028 Content-Range=bytes 2000070-106786027/106786028 Date=Mon, 30 Apr 2001 12:55:20 GMT ETag=W/&quot;02ca57e173c11:95b&quot; Content-Type=application/octet-stream Server=Microsoft-IIS/5.0 Last-Modified=Mon, 30 Apr 2001 12:55:20 GMT 和前面服务器返回的信息比较一下，就会发现增加了一行： Content-Range=bytes 2000070-106786027/106786028 返回的代码也改为 206 （已完成部分get请求）了，而不再是 200 了。 ⑦ HTTP 1.0和HTTP 1.1的主要区别是什么?HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 1）长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 2）错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 3）缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 4）带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 ⑧ HTTP 和 HTTPS 的区别？1）端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口 443 2）安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等； 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 ⑨ HTTPS 加密关于HTTPS加密的详细内容参见 👉 HTTPS 协议","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"网络管理和网络安全","slug":"计算机网络/7-网络管理和网络安全","date":"2020-02-27T14:02:45.000Z","updated":"2020-09-04T15:48:55.343Z","comments":true,"path":"2020/02/27/计算机网络/7-网络管理和网络安全/","link":"","permalink":"https://aaronyard.github.io/2020/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","excerpt":"一、网络管理1. 网络管理的目的对组成网络的各种软硬件设施的综合管理，以达到充分利用这些资源的目标 对象：网络设备、主机； 管理的方法：收集、分析和配置参数 2. 网络管理的体系结构","text":"一、网络管理1. 网络管理的目的对组成网络的各种软硬件设施的综合管理，以达到充分利用这些资源的目标 对象：网络设备、主机； 管理的方法：收集、分析和配置参数 2. 网络管理的体系结构 网络管理面向用户，属于 OSI 应用层的服务之一 从微观上来说：网管涉及所有层次，因此，每层均设置对应实体； 各层管理实体协作，保证本层协议/功能正常运行/提供； 从宏观上来说：ISO/OSI 的 系统管理应用实体 SMAE 分管理员和代理两类实体，管理员和代理之间遵循 公共管理信息协议（CMIP） 管理员：负责对整个网络的资源进行管理； 代理：驻留在被管对象上，响应管理员的指令（路由器、交换机等）。 3. 网络管理的基本模型 网络管理工作站：运行网管软件，收集被管网络设施的信息，进 行汇总分析和反馈。 被管结点：网络交换设备、集中器、线路设备、用户结点等；运行网管（代理）软件，将被管设备的信息通过网络管理协议提供 给管理工作站，包括主动监测和记录故障并报于管理工作站。 管理信息库：保存为网络管理目的而收集的信息。 网络管理协议：支持网管工作站（网管软件）和被管结点（代理 软件）之间的数据交换。 4. 信息获取方式网络管理系统收集被管设备数据的方法：主动轮询，被动中断。 主动轮询：工作站周期性地轮询子机； 可能存在的问题： 轮询间隔的设置：长 — 及时性不好，短 — 占用资源多； 轮询顺序：设备之间的相互影响； 灾难响应：实时性略欠，主动性不足。 被动中断（自陷）：子机主动传递数据 可能存在的问题： 传递周期设置：可能消耗资源； 设备故障数据的可传递性（优先级）。 5. 简单网络管理协议 SNMP① 概述 为促进因特网网络管理标准化，IETF成立两个工作组。 管理信息库（MIB）工作组负责定义交换的元素及结构 （对象）； 网络管理协议（SNMP）工作组定义管理实体之间交换的协议（交换的方式、格式和时序）； SNMP 中交换的信息是 MIB （管理信息库），MIB 实在树形结构的数据库中为每个项目附加编号的一种数据结构。 SNMP作用于应用层，利用UDP的两个端口（161和162）实现管理员和代理之间的管理信息交换。 UDP端口161用于数据收发 UDP端口162用于代理报警 管理员/代理之间交换的PDU（五种类型）： ② 因特网网络管理的工作方式 ⭐为了使一个管理员可以管理多个代理，同时，代理又可以主动报告出现的问题，SNMP 采用具有自陷能力的轮询机制； 管理员和代理之间主要以请求/应答方式工作： 管理员周期性向代理发出“请求”指令，获取或者设置网络元素的参数； 代理向管理员返回“应答”响应，报告“请求”的执行结果； 如果代理发现设备故障，主动向管理员报警（自陷 Trap）。 以 SNMPv2 为例： 二、网络安全1. 网络安全的目的网络安全的目的就是：保护网络资源（此处主要指信息资源），免受攻击； 基于网络的应用可能受到的安全威胁如下： 截取（窃取）：非法截取网络信息，窃取其中的机密； 篡改：对截取的数据进行部分/全部篡改，再送到目的地； 伪造：冒充合法用户进行网络操作，嫁祸于人； 重播/插播：干扰用户的正常操作； 发方否认：否认已向接受者发送过数据； 收方否认：否认已收取过发送方发送的数据。 2. 抵御攻击的安全服务 ⭐⚠ 所有的服务只能保证出现的攻击可以被识别， 并不能防止攻击的发生 ① 内容保密 — 防窃取采用加密技术对数据进行加密； 为提高加密的效率，混合使用秘密密钥加密体系和公开密钥加密体系的算法。 对应每次通信，形成一个一次性密钥（随机数）； 只有指定的收方才可以获得密钥，解密密文； 使用DES算法（对称加密算法）对明文加密，提高效率； 使用RSA算法（非对称加密算法）对密钥加密，保护密钥的秘密性 ② 内容完整性—防篡改依赖摘录技术的特性（报文和摘录息息相关）。 工作过程： 发送方利用摘录算法（如MD5）形成摘录值（报文完整性检查值— MIC 值）； 用密钥对摘录值进行加密形成数字签名 报文连同数字签名一起传递给接收方； 接收方解密并分隔报文和MIC值； 对报文执行相同的摘录算法，形成新的MIC值； 新/ 原MIC值比较，判断报文在传输过程中是否被修改 ③ 序列完整性 —防重播在报文中增加序号和时标（报文形成或者发送的时间值）； 接收方按序接受报文。 ④ 实体鉴别 ：— 防冒充（假冒）含身份鉴别和数据源鉴别。 身份鉴别 — 鉴别对等实体的身份 进入系统时常用的鉴别身份的方法为传递用户标识和口令字， 并和系统内保留的用户标识和口令字进行比较，验证用户的合法性 数据源鉴别 — 鉴别数据真实性，确认数据来自正确的发送方 数字签名技术支持数据源的鉴别 描述： 形成的报文数字签名和报文内容及发方密钥密切相关； 收方利用发方的公钥处理签名，获得原始MIC值； 收方利用MD5对报文求MIC值； 如果新MIC值和原始MIC值一致，可认为报文确实来自于期望的发送方，且在传输过程中内容未被篡改。 依据：只有发方才掌握发方的私钥 ⑤ 防否认服务 — 抵御合法用户对所作的操作进行否认理想的解决方案：第三方的参与和仲裁。 措施： 至少维护一个双方可信的认证中心（CA），合法用户需在中心注册，获得自己的密钥对； CA以安全的方式转发通信双方的报文，并予以记录，作为产生异议时的仲裁依据。 过程： A以CA的公钥和A的私钥向CA认证自身，并获得 B的公钥； A以B的公钥形成密文（容许含随机密钥的秘密加密）， 并提交CA； CA记录全部或者部分（如MIC值）信息后，转发密文至B； B收取报文后，应向CA返回确认信息 3. 防火墙防火墙：保护内部网络的资源免受外界的侵袭 防火墙的原理： ① 分组过滤原理：分析报文，对应其中的所有参数，设置过滤策略， 允许或者拒绝该报文穿越防火墙； 分析的参数有：源IP地址（仅允许哪些设备访问内部网）、宿IP地 址（仅允许访问哪些结点）、端口号（允许使用哪些服务）等； 设置的策略包括：访问的时间段、并发访问的个数等； 一般策略为：不明确表示“允许”的就是禁止。 ② 代理服务代理外部（或内部）用户访问内部（或外部）网络，杜绝内部和外部的直接访问。 代理服务器分析客户的请求，根据制定的策略决定允许或者拒 绝某个特定的请求； 当一个请求被允许时，代理服务器就“代表” 该客户执行访问操作，并将结果返回客户。 此处的“代表”隐含了分组中IP地址的转换（迁移）。 此类防火墙安全较高，但效率受影响，常用于特定的应用服务 （如FTP服务、Telnet服务、远程拨号服务等） ③ 地址转换 NAT针对IP地址告急和专用IP地址在部分企业网中的应用，出现 了地址转换路由器（NAT路由器或者NAT服务器）。 当内外用户希望相互访问时，NAT路由器负责全局/本地IP地 址的映射，屏蔽内部IP地址； NAT服务器专门进行地址转换工作，并增加各种安全策略， 限制地址的转换，隔离内外网络。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"应用层","slug":"计算机网络/6-应用层","date":"2020-02-26T14:02:45.000Z","updated":"2020-09-04T15:49:00.618Z","comments":true,"path":"2020/02/26/计算机网络/6-应用层/","link":"","permalink":"https://aaronyard.github.io/2020/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"一、思维导图 二、应用层功能应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。","text":"一、思维导图 二、应用层功能应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。 主要功能总结如下： WWW 万维网 电子邮件 SMTP、POP3、IMAP 文件传输 FTP 远程传输 TALENT、SSH 网络管理 SNMP 三、网络应用模型1. 客户/服务器模型 C/S 服务器：对外提供服务 24小时提供服务 永久性访问地址/域名 大量服务器实现可扩展性 客户机：获取服务 间歇性接入网络 可能使用动态IP地址 不会与其他客户机直接通信 典型的 C/S 结构：Web 2. P2P模型 Peer to Peer 没有永远在线的服务器 每个主机既可以提供服务，也可以请求服务 任意端系统/节点之间可以直接通讯 节点间歇性接入网络 节点可能改变IP地址 典型的 P2P 结构：文件共享 优点：高度可伸缩 缺点：难以管理 四、域名解析系统 DNS域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库 (这里的分布式数据库是指，每个站点只保留它自己的那部分数据)，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 地址。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。 大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。 在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 域名解析方式： 递归查询（比较少用，靠别人） 迭代查询（靠自己） 基本原理： 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表； 若没有，则搜索操作系统的DNS缓存； 若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找： 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址； 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址； 本地域名服务器向权限域名服务器发起请求，得到IP地址； 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来； 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来； 至此，浏览器已经得到了域名对应的IP地址。 五、文件传送协议 FTPFTP提供不同种类主机之间的文件传输能力 FTP 使用 TCP 进行连接，实现可靠传输，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据，数据传输使用端口号 20 六、电子邮件协议 1. 简单邮件传送协议 SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。 MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 SMT通信三个阶段： 连接建立 邮件传送 连接释放 2. 邮局协议 POP3POP3用来接收邮件 特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 3. 网际报文存取协议 IMAPIMAP用来接收邮件。 IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 七、动态主机配置协议 DHCPDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 目的：动态调整，按需分配IP地址给希望上网的用户机。 原理：地址分配服务器维护IP地址池，希望上网的用户向其申请IP地址，使用后释放IP地址，提高地址利用率 DHCP 是基于 UDP 的，客户和服务器之间采用 广播 形式进行交互 八、HTTP 协议1. URIURI 包含 URL 和 URN。 2. 了解HTTP超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 超文本指的是HTML，CSS，JavaScript和图片等，HTTP的出现是为了接收和发布HTML页面，经过不断的发展也可以用于接收一些音频，视频，文件等内容。 HTTP协议是用于客户端和服务器端之间的通信，用于客户端和服务器端之间的通信有HTTP协议和TCP/IP协议族在内的其他众多的协议。 请求访问文本或图片等资源的一方，我们叫做客户端；负责接收，提供响应的一方称为服务器端。 Client客户端请求Server服务端，Server服务端响应给Client客户端。HTTP是基于客户端/服务端的架构模型，浏览器或其他任何客户端都可以用HTTP协议的，通过URL地址向HTTP的服务器即Web服务器发送所有请求，Web服务器端在接收到请求后会做出反应，响应给对方，就是向客户端回传响应的信息。 注意：在使用HTTP协议的时候，我们一端必定是客户端，另一端必定是服务器端。 3. HTTP协议特点 支持客户/服务器模式。 基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应 默认使用80端口（HTTPS使用443端口） 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，如果服务器不需要前面已处理过的信息，它的应答速度就较快。 4. HTTP协议的版本 HTTP/1.0：发送请求，创建一次连接，获得一个web资源，连接断开 HTTP/1.1：发送请求，创建一次连接，获得多个web资源，连接断开 HTTP1.1新特性：详细内容见下文 默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age 5. HTTP协议的组成Http协议由 Http 请求和 Http 响应组成 当在浏览器中输入网址访问某个网站时， 你的浏览器会将你的请求封装成一个Http请求发送给服务器站点，服务器接收到请求后会组织响应数据封装成一个 Http 响应返回给浏览器。即没有请求就没有响应。 a. HTTP请求报文HTTP请求报文由3部分组成（请求行+请求头+请求体）： 请求行 必须在http请求格式的第一行。 请求头 从第二行开始，到第一个空行结束。请求头和请求体之间存在一个空行 请求体 通常以键值对 {key:value}方式传递数据。 ① HTTP请求方法 GET 获取资源 将请求参数追加在 url 后面，不安全； url 长度限制 get 请求方式数据的大小； 没有请求体； 一般的 HTTP 请求大多都是 GET。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。（RESTful 风格） 请求参数在请求体处，较安全。 请求数据大小没有显示 只有表单设置为 method=“post” 才是 post 请求，其他都是 get 请求 （常见 get 请求:地址栏直接访问、&lt;a href=&quot;&quot;&gt;、&lt;img src=&quot;&quot;&gt;等） PUT 上传文件 把一个资源存放在指定的位置上。 本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 OPTIONS 查询支持的方法 用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信 内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 ② HTTP 请求头属性以下列出常见请求头： Referer：表示这个请求是从哪个url跳过来的,通过百度来搜索淘宝网,那么在进入淘宝网的请求报文中,Referer的值就是:www.baidu.com。如果是直接访问就不会有这个头。常用于: 防盗链。 Accept：告诉服务端,该请求所能支持的响应数据类型,专业术语称为MIME 类型(文件类型的一种描述方式) 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 if-Modified-Sincce：浏览器通知服务器，本地缓存的最后变更时间。 Cookie：**客户端的Cookie就是通过这个报文头属性传给服务端的！ 1Cookie: ``JSESSIONID``=15982C27F7507C7FDAF0F97161F634B5 User-Agent：浏览器通知服务器，客户端浏览器与操作系统相关信息 Connection：**表示客户端与服务连接类型；Keep-Alive表示持久连接，close已关闭 Host：请求的服务器主机名 Content-Length：请求体的长度 Content-Type：请求的与实体对应的MIME信息。如果是post请求,会有这个头,默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码 Accept-Encoding：浏览器通知服务器，浏览器支持的数据压缩格式。如GZIP压缩 1Accept-Encoding: gzip, deflate Accept-Language：浏览器通知服务器，浏览器支持的语言。各国语言(国际化i18n) Cache-Control：指定请求和响应遵循的缓存机制。对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。 1Cache-Control: no-cache ③ 请求体当请求方式是 post 的时，请求体会有请求的参数，格式如下： 1234567username=zhangsan&amp;password=123POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1User-Agent: FiddlerHost: 39.108.107.149:8080Content-Length: 20 username=zhangsan&amp;password=123 b. HTTP响应报文HTTP的响应报文也由三部分组成（响应行+响应头+响应体） ① 响应行响应行包括 报文协议及版本； 例如： 1HTTP/1.1 200 OK 状态码及状态描述； 状态码：由3位数字组成，第一个数字定义了响应的类别。响应码详细如下。 ② 状态码 1xx：指示信息，表示请求已接收，继续处理 2xx：成功，表示请求已被成功接受，处理。 200 OK：客户端请求成功 204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。 206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容 3xx：重定向 301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。 302 Found：临时重定向，表示请求的资源临时搬到了其他位置 303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问 304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有 307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET 4xx：客户端错误 400 Bad Request：客户端请求有语法错误，服务器无法理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在。比如，输入了错误的url 415 Unsupported media type：不支持的媒体类型 5xx：服务器端错误，服务器未能实现合法的请求。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ③ 响应头响应头也是用键值对 k：v 服务器通过响应头来控制浏览器的行为，不同的头浏览器操作不同 ④ Content-Type 详解响应正文的类型： ⑤ 响应体响应体，响应体是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染显示页面内容 6. 连接管理① 长连接和短连接长连接也称持久连接，短连接也称非持久连接 在HTTP/1.0中默认使用非持久连接 close (短连接)。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。 从HTTP/1.1起，默认使用持久连接 keep-alive (长连接)，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 TCP短连接 模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。 TCP长连接 我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 ② 流水线默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 7. Cookie① 用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） ② 创建过程服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry ③ 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 8. Session除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 典型的 Session 应用比如购物车，通过为每个用户分配一个唯一的 Session ID来唯一标识这个用户。 ① 浏览器禁用Cookie此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 ② Cookie和Session的选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 9. 打开一个网页，整个过程会使用哪些协议 回顾一下这三个概念：物理(MAC)地址，IP地址，域名 连入Internet的每台主机至少有一个全网唯一的IP地址，是由数码表示的主机逻辑地址。 域名是Internet中为每台主机所取的一个具有一定含义又便于记忆的名字。 MAC地址是安装在主机网卡（网络适配器）上的地址。 域名与IP地址之间的映射称为域名解析。 IP地址与物理地址之间的映射称为地址解析。 在Internet应用中，人们使用的是方便、易记的域名，为了将信息发送到对方的主机上，就必须先把域名映射为IP地址，然后把IP地址映射为相应的物理地址，从而通过物理链路进行传输. 应用层：首先通过DNS协议进行域名解析，具体过程如下： 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表； 若没有，则搜索操作系统的DNS缓存； 若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找： 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址； 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址； 本地域名服务器向权限域名服务器发起请求，得到IP地址； 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来； 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来； 至此，浏览器已经得到了域名对应的IP地址。 浏览器发送HTTP请求； 接下来到了传输层，TCP三次握手建立连接； 接下来到来网络层，建立TCP连接时需要传送数据，传送数据在网络层使用 IP协议，通过IP协议将IP地址封装为IP数据报； IP数据报在路由器之间进行传送的时候，需要使用路由选择协议OSPF； 路由器在与服务器通信的时候，需要将IP地址转换为MAC地址，此时就需要使用ARP协议；主机发送信息时将包含目标IP地址，将ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址； 接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的MAC地址开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层； 服务器响应浏览器发送的HTTP请求并请求客户端要的资源，传回给客户端； 断开TCP连接，浏览器通过HTTP协议对页面进行渲染呈现给客户端。 总结以上过程，用到的协议依次为： DNS ——&gt; HTTP ——&gt; TCP ——&gt; IP ——&gt; OSPF ——&gt;ARP 10. HTTP 断点续传概念：断点续传指的是下载传输文件可以中断，之后重新下载时可以接着中断的地方开始下载，而不必从头开始下载。断点续传需要客户端和服务端都支持。 原理：原理是客户端一块一块的请求数据，最后将下载回来的数据块拼接成完整的数据。其实就是在Http的请求上和一般的下载有所不同而已。 打个比方，浏览器请求服务器上的一个服务，所发出的请求如下： 假设服务器域名为 www.baidu.com，文件名为down.zip。 1234567GET /down.zip HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms- excel, application/msword, application/vnd.ms-powerpoint, */* Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0) Connection: Keep-Alive 服务器收到请求后，按要求寻找请求的文件，提取文件的信息，然后返回给浏览器，返回信息如下： 12345678200 Content-Length=106786028 Accept-Ranges=bytes Date=Mon, 30 Apr 2001 12:56:11 GMT ETag=W/&quot;02ca57e173c11:95b&quot; Content-Type=application/octet-stream Server=Microsoft-IIS/5.0 Last-Modified=Mon, 30 Apr 2001 12:56:11 GMT 所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给Web服务器的时候要多加一条信息 – 从哪里开始。 比如要求从2000070字节开始。 1234GET /down.zip HTTP/1.0 User-Agent: NetFox RANGE: bytes=2000070- Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 仔细看一下就会发现多了一行 RANGE: bytes=2000070- 这一行的意思就是告诉服务器down.zip这个文件从2000070字节开始传，前面的字节不用传了。 服务器收到这个请求以后，返回的信息如下： 12345678206 Content-Length=106786028 Content-Range=bytes 2000070-106786027/106786028 Date=Mon, 30 Apr 2001 12:55:20 GMT ETag=W/&quot;02ca57e173c11:95b&quot; Content-Type=application/octet-stream Server=Microsoft-IIS/5.0 Last-Modified=Mon, 30 Apr 2001 12:55:20 GMT 和前面服务器返回的信息比较一下，就会发现增加了一行： Content-Range=bytes 2000070-106786027/106786028 返回的代码也改为 206 了，而不再是 200 了。 九、HTTPS 协议HTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 SSL，(Secure Socket Layer 安全套接字层)，为Netscape(网景公司)所研发，用以保障在Internet上数据传输之安全。SSL目前有三个版本，SSL1.0、SSL2.0、SSL3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。 SSL利用数据加密、身份验证和消息完整性验证机制，为网络上数据的传输提供安全性保证。SSL支持各种应用层协议。由于SSL位于应用层和传输层之间，所以可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 1. 加密① 对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。 如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是不现实的。怎么办？解决这个问题，我们就需要非对称加密。 ② 非对称密钥加密基于对称加密存在的问题，又有了非对称加密。 非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。 私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 ③ HTTPS加密方式（对称 + 非对称）既然非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。非对称加密、解密各只需一次的方法： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。 相当于对称加密明文信息，非对称加密密钥 HTTPS基本就是采用了这种方案。但还是有漏洞的。 2. 中间人攻击中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？ 3. 数字证书现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？ 4. 数字签名把要传送的明文信息通过 hash 算法得出 摘录信息 MIC（摘录技术），再用私钥对 MIC 值 进行加密得到数字签名 数字签名的制作过程： CA拥有非对称加密的私钥和公钥。 CA对证书明文信息进行hash。 对hash后的值用私钥加密，得到数字签名。 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。 浏览器验证过程： 拿到证书，得到明文T1，数字签名S1。 用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥），得到S2。 用证书里说明的hash算法对明文T1进行hash得到T2。 比较S2是否等于T2，等于则表明证书可信。 关于数字签名推荐阅读这篇漫画图解 👉 分分钟理解什么是数字签名","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"传输层","slug":"计算机网络/5-传输层","date":"2020-02-25T14:02:45.000Z","updated":"2020-09-04T15:49:03.845Z","comments":true,"path":"2020/02/25/计算机网络/5-传输层/","link":"","permalink":"https://aaronyard.github.io/2020/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5-%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"一、思维导图 二、传输层的功能运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。 由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。","text":"一、思维导图 二、传输层的功能运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。 由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 主要功能总结如下： 传输层提供进程和进程之间的逻辑通信（网络层提供主机间的通信） 复用和分用 传输层对接收到的报文进行差错检测 TCP/UDP协议 三、UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol） UDP 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比 如： QQ 语音、 QQ 视频 、直播等等 传输控制协议 TCP（Transmission Control Protocol） TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 🚩 插入一个小知识点：TCP/UDP 应用中，端口号的作用是什么？ IP 地址 + TCP/UDP 端口号确定因特网中的某个主机上的某个应用进程 四、UDP协议UDP 只在 IP 数据报服务之上增加了很少功能，即复用分用和差错检测功能。 1. UDP首部格式 2. UDP校验 五、TCP首部格式 六、TCP可靠传输可靠传输：保证接收方收到的字节流和发送方发出的字节流是完全一样的 传输层：使用 TCP 实现可靠传输 网络层：尽最大努力交付，不可靠传输 TCP实现可靠传输的机制： 校验：与UDP校验一样，增加伪首部 序号：一个字节占一个序号。序号字段指的是一个报文段第一个字节的序号 确认：累计确认 超时重传：确认重传不分家，TCP发送方在规定的时间内没有收到确认就要重传已发送的报文段。 七、TCP三次握手 - 建立连接1. 三次握手过程（连接建立） SYN：连接请求/接收 报文段 seq：发送的第一个字节的序号 ACK：确认报文段 ack：希望收到的下一个数据的第一个字节的序号 具体流程： 客户端：发送连接请求报文段 SYN， 无应用层数据。 服务器端：为该TCP连接分配缓存和变量，并向客户端返回确认报文段ACK，允许连接，无应用层数据。 客户端：为该TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据。 2. 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 3. 为什么要传回 SYN接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK响应，表示确认发来的数据已经接受无误。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。 4. 传了 SYN,为啥还要传 ACK双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 5. SYN洪泛攻击攻击者发送大量的TCP SYN，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态（半连接状态），服务器收不到再确认的话，还会重复ACK给攻击者，这样更加浪费服务器的资源。 八、TCP四次握手 - 释放连接1. 四次握手过程（连接释放） FIN ：连接终止位 具体过程： 客户端：发送连接释放报文段FIN，停止发送数据，主动关闭TCP连接。 服务器端：回送一个确认报文段ACK。客户到服务器这个方向的连接就被释放了——半关闭状态 服务器端：发送连接释放报文段FIN，停止发送数据，主动关闭TCP连接。 客户端：回送一个确认报文段ACK，再等到时间等待计时器设置的2MSL后(最长报文段寿命)，服务器到客户这个方向的连接就被释放了——连接彻底关闭 2. 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 九、TCP流量控制 — 滑动窗口协议流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP实现流量控制主要是 滑动窗口协议， 使用这种方法的时候，发送方和接收方向外通信各使用一个窗口。窗口大小取决于下面两个数：接收窗口（rwnd）和拥塞窗口（cwnd）。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段 rwnd 设置为 0，则发送方不能发送数据。 （接收方根据自己接收缓存的大小，即接收窗口rwnd，动态的调整发送方的发送窗口大小，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。） 滑动窗口协议的实际应用：数据链路层的三个ARQ协议 十、TCP拥塞控制在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分（需&gt;供)，网络的性能就要变坏。这种情况就叫拥塞。 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。 因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。 TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 | 快重传 、快恢复。 慢开始（指数增长）： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。 拥塞避免（加法增大，乘法减小）： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT cwnd加1。（网络堵塞后cwnd=1，慢开始轮限ssthresh = 堵塞时的cwnd/2） 快重传与快恢复： 在 TCP / IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。 没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。 有了 FRR，如果接收方接收到一个不按顺序的数据段，它会立即给发送方发送一个重复确认。如果发送方接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据报丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据报在某一段很短的时间内丢失时，它则不能很有效地工作。 （网络堵塞后cwnd = cwnd/2，慢开始轮限 ssthresh = 堵塞时的 cwnd/2） 十一、网关 Gateway网关（Gateway）设备又称网间连接器、协议转换器，是多个网络间提供数据转换服务的计算机系统或设备。可以说网关设备就是不同网之间的连接器，就是数据要从一个网到另外一个网时要经过“协商”的设备。 网关工作在 OSI/RM 的传输层及以上的所有层次，通过重新封装信息来使它们能够被另一种系统处理。 事实上现在的网关已经不能完全归为一种网络硬件，而可以概括为能够连接不同网络的软件和硬件的结合产品。 一个非常典型的例子就是互联网邮件与手机邮件的转换服务。 手机邮件与互联网邮件有时候可能会不兼容，这是由于他们在表示层和应用层中的 “ 电子邮件协议 ” 互不相同导致的。 那么，为什么连到互联网的电脑与手机之间能够互发电子邮件呢？ 因为互联网与手机之间设置了一道网关。网关负责读取完各种不同协议后，对他们逐一进行合理的转换，再将相应的数据转发出去。这样一来即使应用的是不同电子邮件协议，计算机与手机之间也能互相发送邮件。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"网络层","slug":"计算机网络/4-网络层","date":"2020-02-24T14:02:45.000Z","updated":"2020-09-04T15:49:07.899Z","comments":true,"path":"2020/02/24/计算机网络/4-网络层/","link":"","permalink":"https://aaronyard.github.io/2020/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4-%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"一、思维导图 ⛔ 图中有错：DHCP协议是应用层协议 二、网络层功能在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。","text":"一、思维导图 ⛔ 图中有错：DHCP协议是应用层协议 二、网络层功能在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。 网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。 在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 网络层功能概述： 路由选择与分组转发 异构网络互联 拥塞控制 三、数据交换方式为什么要数据交换：交换是通过某些交换中心将数据进行集中和传送，传输线路为各个用户共用，从而大大节省通信线路，降低系统费用。如果网络规模较大，则把交换设备连接在一起形成交换网络。 1. 电路交换最典型的电路交换网络：电话网络 特点：独占连接 电路交换的三个阶段： 建立连接 通信 释放连接 2. 报文交换无需建立连接，一次性发送，存储转发 3. 分组交换相当于把报文分割成一个一个的小组，在每个分组的首部写入发送端和接收端的地址，同样是存储转发，不同站点的数据分组可以交织在同一线路上传输，提高了线路的利用率 什么时候使用分组交换： 当一个IP数据报从一个主机传输到另一个主机时，它可能通过不同的物理网络。每个物理网络上都有各自的最大帧的大小，即最大传输单元MTU，若传输的IP数据报超过MTU，此时就会对整个IP数据包进行分组 分组交换又区分为数据报方式和虚电路方式 ① 数据报特点：不同分组（传输的分组称为数据报）的下一跳结点可能不同。随时发送，随时接收，无连接服务。同一报文的不同分组到达目的结点时可能发生乱序、重复或丢失 ② 虚电路将数据报方式和虚电路方式结合，以发挥两者的优点。 维持一条虚电路的建立，非实际物理连接。一次通信的所有分组都通过虚电路顺序传送，同一报文的不同分组到达目的结点时不会发生乱序、丢失和重复。 ③ 数据报和虚电路比较数据报： 无需建立连接； 每个数据报中需带地址信息（冗余信息），占用信道资源； 用户的连续数据块会无序地到达目的地，接收站点予以排序。 当使用网状拓扑组建网络时，任一中间结点或者线路的故障 不会影响数据报的传输（可以选择不同的路径），可靠性较高。 数据报较适合站点之间小批量数据的传输（存储排序占用资 源）。 虚电路： 需建立连接和释放虚电路； 数据分组中仅含少量的地址信息（LC号），用户的连续数据 块沿着相同的路径，按序到达目的地；接收站点处理方便。 如果虚电路中的某个结点或者线路出现故障，将导致虚电路中断，传输失效。 虚电路方式较适合站点之间大块数据的传输（地址冗余量小） 4. 三种交换方式比较 电路交换：类似打电话，独占这条线路，其他人无法参加，需要建立连接，比特流直达，速度快（电路交换传bit流，发生在物理层） 报文交换：报文是应用层传输单位，即站点一次性要发送的数据块，无须建立连接，采用存储转发的方式，速度较慢（报文交换传报文，发生在应用层） 分组交换：是将较大的数据分割成小块，无须建立连接，采取存储转发的方式，速度比报文交换快，比电路交换慢，可能产生分组丢失，乱序的情况（分组交换传分组/IP数据报，发生在网络层） 5. 数据交换方式的选择 四、IP 协议1. 概述 IP协议：因特网中的基础协议； IP协议屏蔽下层各种物理网络的差异， 向上层（主要是TCP层或UDP层）提供统一的IP数据报。 IP数据报：由IP协议控制传输的协议单元。 IP数据报中含有发/收方的IP地址。 2. IP 协议提供的功能IP提供无连接的、不可靠的、尽力的数据报投递服务 ★ 无连接的投递服务 发送端可于任何时候自由发送数据，而接收端永远不知道自己会在何时从哪里接收到数据。每个数据报独立处理和传输， 一台主机发出的数据报序列，可能取不同的路径， 甚至其中的一部分数据报会在传输过程中丢失； ★ 不可靠的投递服务 IP协议本身不保证数据报投递的结果。 在传输的过程中，数据报可能会丢失、重复、延迟和乱序等， IP协议不对内容作任何检测，也不将这些结果通知收发双方； IP数据报的丢失，通过路由器发 ICMP报文 告知； 必要时，由高层实体（如TCP）负责差错恢复动作。 ★ 尽力投递服务 执行数据报的分段和封装，以适应具体的传输网络， 由最终结点的IP模块进行合段处理 不同物理网络对传输的帧 /分组的体积有不同的规定； 当数据报长度 &gt; MTU（最大传输单元 MTU—Maximun Transfer Unit ）时，需对数据报分段 。 3. IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。数据报分片举例： 五、IPV4地址IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口 1IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125; 网络号全0代表本机 主机号全1代表广播地址 为解决IPV4地址不足的问题，现有的如下3种方案 NAT 地址转换 子网划分 CIDR 无分类编址 当然，这些方案治标不治本，IPV6才是最终归宿 1. 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT路由器 来将本地 IP 转换为全球 IP。 2. 子网划分两级IP地址 (网络号+主机号) ——&gt; 三级IP地址 (网络号+子网号+主机号) 1IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125; 子网掩码：网络号全1，主机号全0 注意，外部网络看不到子网的存在。 子网划分相关习题： 有关子网划分的习题可参见这篇文章 👉 计算机网络——子网划分（内含习题讲解） 常见进制转换：👇 十进制 二进制 255 1111 1111 192 1100 0000 128 1000 0000 127 0111 1111 3. 无分类编址 CIDR 构成超网无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 CIDR 把网络前缀都相同的连续 IP 地址组成一个 CIDR 地址块 1IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125; CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 六、ARP 地址解析协议网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP（Address Resolution Protocol ）实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组（该分组携带自己的 IP 地址 和 MAC 地址 以及 目标主机的 IP 地址），主机 B 收到该请求后会发送 ARP 响应分组 给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 RARP 协议 实现 MAC地址 ——&gt; IP 地址 七、ICMP 网际控制报文协议ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。IP 数据报传输失败时，ICMP报文由路由器产生， 被封装在IP数据报的数据区中进行传输，进行差错报告。 功能：ICMP 协议负责网络设备和结点之间的控制和差错报告报文的传输 ICMP 报文分为差错报告报文和询问报文，详细类型分类如下： ICMP 可视为对 IP 协议的补充：弥补部分差错报告的功能。 当中间路由器发现传输错误（借助报头校验和） 时，IP 模块丢弃该 IP 数据报，ICMP 实体向信源主机返回ICMP 报文，报告出错情况，以便信源主机采取相应的措施。 ICMP的应用： Ping Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。使用了ICMP时间超过差错报告报文。 八、IPV632位 IPV4地址空间已分配殆尽，CIDR，NAT治标不治本，IPV6 从根本上解决地址耗尽问题。 1. IPV6 和 IPV4 区别 2. IPV6基本地址类型 单播 多播 任播 3. IPv6向IPv4过渡的策略 双栈协议 双栈协议就是在一台设备上同时启用 IPV4 协议栈和 IPV6 协议栈 隧道协议 将IPV6协议通过隧道包装成IPV4协议再进行发送 九、路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 十、动态路由选择协议 / 路由算法路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的 自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把动态路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1. 内部网关协议 RIP 距离向量算法RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器（若网络1出现故障，则路由表到网1的距离增大到16的时候才知道网1是不可达的）。好消息传得快，坏消息传得慢 RIP 习题举例： 假设网络中路由器B的路由表如下 目的网络 距离 下一跳路由 N1 7 A N2 2 C N6 8 F N8 4 E N9 4 F 现在B收到C发过来的路由信息 目的网络 距离 N2 4 N3 8 N6 4 N8 3 N9 5 首先，我们修改一下C发过来的路由表，将所有距离 +1，并修改下一跳为 C 目的网络 距离 下一跳 N2 5 C N3 9 C N6 5 C N8 4 C N9 6 C 则路由器B更新后的路由表为： 算法原则： 下一跳相同，替换原路由表信息 下一跳不同，若传过来的项目距离比原路由距离小，则更新，否则不更新 若原路由表中没有传过来的路由信息，则进行添加 目的网络 距离 下一跳路由 解释 N1 7 A C中没有N1的信息，不需要更新 N2 5 C 下一跳相同，直接更新 N3 9 C B中没有N3的信息，添加 N6 5 C 下一跳不同，且C中到N6的距离为4，小于B到N6的距离8，需更新 N8 4 E 下一跳不同， B、C到N8的距离相同，不更新 N9 4 F 下一跳不同，B到N9的距离为4，小于C到N9的距离5，不更新 2. 内部网关协议 OSPF 链路状态路由算法开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra提出的最短路径算法 SPF。 OSPF 算法选择路由的标准是带宽（或者说代价） OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议），基于 TCP 协议 AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 十一、虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 十二、IP 多播 + IGMP 网际组管理协议1. IP 多播对于广播方式，将数据发送给所有终端主机，再由这些主机 IP 之上的一层去判断是否有必要接收数据，这种方式会给哪些毫无关系的网络或者主机带来影响，造成网络上产生很多不必要的流量。 而且广播无法穿透路由，若想给其他网段发送同样的包，就不得不采取另一种机制。因此，多播这种既可以穿透路由器，又可以实现只给那些必要的组发送的数据包的技术就成为必选之路的。 多播使用 D 类地址，即 1110 开头的 IP 地址就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。 利用 IP 多播实现通信，除了地址外还需要 IGMP 等协议的支持。 2. IGMP 网际组管理协议IGMP 协议让路由器知道本局域网上是否有主机参加或退出了某个组播组 十三、网络层设备 — 路由器 / 三层交换机工作在 OSI 第三层，因此路由器也称为三层交换机。 路由器从功能上可以划分为：路由选择和分组转发。 路由器主要用来连接两个不同类型的网络。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"数据链路层","slug":"计算机网络/3-数据链路层","date":"2020-02-23T14:02:45.000Z","updated":"2020-09-04T15:49:11.361Z","comments":true,"path":"2020/02/23/计算机网络/3-数据链路层/","link":"","permalink":"https://aaronyard.github.io/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"🚡 数据链路层 一、思维导图 二、数据链路层的作用基于物理层的问题： 物理连接是有差错和不可靠的 物理设备之间可能存在传输速度不匹配问题","text":"🚡 数据链路层 一、思维导图 二、数据链路层的作用基于物理层的问题： 物理连接是有差错和不可靠的 物理设备之间可能存在传输速度不匹配问题 数据链路层功能： 数据链路层在物理层提供服务的基础上为网络层提供服务。 其最基本的服务是将来自网络层的 IP 数据报封装成帧，可靠的传输到相邻结点的目标网络层。 其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 流量控制：解决速度不匹配问题 差错处理技术：保证数据传输准确性 功能概述： 为网络层提供服务 链路管理，即连接的建立，维持，释放 组帧 流量控制（限制发送方） 差错控制 下面具体解释这些功能 三、封装成帧&amp;透明传输1. 封装成帧的概念封装成帧就是在网络层传下来的IP数据报的前后部分添加首部，尾部，这样就构成了一个帧。 接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。 2. 透明传输 透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。 当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。方法如下： 3. 组帧的四种方法① 字符计数法帧首部使用一个计数字段（第一个字节）来标明帧内字符数 存在的问题：若一个帧出错，则它之后的帧都出错 ② 字节填充法（转义符） ③ 零比特填充法发送端：连续5个1，则立即填入1个0 接收端：连续5个1，则立即去除后面的0 ④ 违规编码法（曼彻斯特编码）可以用电平的 “高-高” “低-低“ 来判定帧的起始和终止 四、数据链路层的差错控制1. 检测编码① 奇偶校验码校验位的取值应使整个码字(包括校验位)中为“1”的比特个数为奇(偶)数。 传输时，形成的校验位附加在信息字段之后传输。 直接举例： 0110001 采用奇校验码，应使 0110001中1的个数为奇数，所以添加0 偶校验码，应使0110001中的1的个数为偶数，所以添加1 奇偶校验码的特点： 只能检查出奇数个比特的错误，检测能力为50% 异步传输方式中采用偶校验， 同步传输方式中采用奇校验 ② 循环冗余码CRC冗余码 ：在数据发送之前，先按某种关系附加上一定的冗余码，当要发送的数据发送变化时，相应的冗余码位也随之变化。接收端接收时判断数据信息和冗余码是否符合，从而判断是否出错。 类似于快递买了5本书，包装上写了5本，但是收到后里面只有3本，则可判断发送过来的数据出了问题 异或相除，同0异1，即 1 /0 = 0， 1 / 1 = 1，0 / 1 = 0，0 / 0 = 1 2. 纠错编码 — 海明码工作流程： 确定校验码位数r 确定校验码和数据的位置 4位校验码P1,P2,P3,P4，分别放在 2^0 ，2^1 ，2^2 ， 2^3这四个位置上， 其余位置依次从高到底填入原始数据 求出校验码的值 检错并纠错 按照上一步的逻辑进行异或运算求出一个二进制序列 P1 异或 D1 异或 D2 异或 D4 异或 D5 = 1 P2 异或 D1 异或 D3 异或 D4 异或 D6 = 0 P3 异或 D2 异或 D3 异或 D4 = 1 P4 异或 D5 异或 D6 = 0 得出的二进制序列为 0101 = 5，由此可知第五位出错 五、流量控制&amp;可靠传输1. 流量控制的概念限制发送方的发送速度，让发送发慢点发 通过滑动窗口来实现流量控制 2. 数据链路层流量控制的方法 —— ARQ协议 有些书中将这个协议放在运输层 以下三种协议都包含 自动重传请求（Automatic Repeat Request）ARQ，所以也称 ARQ 协议 传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。 ① 停等协议（停等式ARQ） 在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。 停等式ARQ，发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。该方法所需要的缓冲存储空间最小，缺点是信道效率很低。 ② 后退N帧协议 GBN（后退N帧的ARQ） 发送窗口 &gt;= 1，接收窗口 = 1 , 发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。 特点：（GBN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的 ③ 选择重传协议 SR（选择性重传ARQ） 发送窗口 &gt;= 1，接收窗口 &gt;= 1 , 发信侧不用等待收信侧的应答，持续的发送多个帧，接收方将确认一个正确接收的帧而不管其是否按序，失序的帧都将被缓存。假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。 特点：相对于GBN 复杂度高，但是不需要发送没必要的帧，所以效率高。 3. 可靠传输发送端发送什么，接收端原封不动接收什么 六、介质访问控制1. 传播数据使用的两种信道/链路① 点对点信道一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。常用于广域网 ② 广播式信道一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术（静态划分信道），另一个是使用 CSMA/CD 协议。 详细控制方法如下 2. 介质访问控制的概念介质访问控制 就是采取一定的措施，使得 广播式链路中 两对节点之间的通信不会发生互相干扰的情况 3. 静态划分信道 使得多路信号可以共用一个信道， 将多路信号组合在一条物理信道上传输，充分利用信道容量。 ① 频分多路复用 FDM对整个物理信道的可用带宽进行分割，每个用户分配不同的频带 频分复用如何避免各路信号间的干扰： 频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传输的信号互不干扰，应在各子信道之间设立隔离带（也就是保护频带，即插入一些 空白的频段 ），这样就保证了各路信号互不干扰。 ② 时分多路复用 TDM将时间段分为一段段等长的时分复用帧，每个用户在每一个TDM帧内占用固定序号的时隙，所用用户按序轮流占用信道 在一个TDM帧内：A先发送na比特，接着B发送nb比特，C发送nc比特，最后D发送nd比特 下一个TDM帧同样如此 ③ 波分多路复用 WDM就是光的频分多路复用，将不同路信号调制成不同波长的光，并借助同一光纤信道传输 ④ 码分多路复用 CDM ⑤ 多路复用的特点 多路复用的特点：各个子信道（频分多路复用中的子 频段，时分多路复用中的时间片，波分多路复用中的波 长） 被静态地分配给各路信号传输，接收方可以直接 通过识别固定子频段、时间片或者波长来完成信号分离。 不足之处：信道利用率不够高，信号的传输往往是间断 的，在某个时刻，子信道会出现空闲状态**（无数据） 解决办法：集中传输 —— 动态按需分配子信道 4. 动态划分信道a. 轮询访问介质访问控制令牌传递协议结点之间通过有序传递令牌（特定比特模式）来分配各结点对共享型总线的访问权利，形成闭合的逻辑环路 b. 随机访问介质访问控制所有用户可随机发送信息，发送信息时占全部带宽 ① ALOHA 协议 不听就说，想发就发不监听信道 ② CSMA 协议 先听再说载波监听多路访问 载波监听：侦听媒体是否空闲（先听再说） 多路访问：多个结点共享媒体，多个结点同时获取信息 ③ CSMA/CD 协议 先听再说，边听边说，冲突停发，随机重发载波监听多点接入/碰撞检测 冲突检测：适配器边发送数据边检测信道上信号电压的变化情况，以便判断是否有人也在发送信号。 发现碰撞后采用 截断二进制指数规避算法 确定重传时机 CAMA/CD 碰撞检测协议一般用于有线连接的局域网 CSMA/CD 数据帧格式中，会有最小帧长（每个帧的长度不小于64字节）的限制，这是为了保证发送结点可以对发生的冲突进行有效的检测 ④ CSMA/CA 协议 先听再说，空闲发送，协商频段，避免冲突载波监听多点接入/碰撞避免 主要流程： 先听再说，但监听到信道空闲时，并不是立即发送数据，而是先发送一个很小的信道侦测帧 RTS，告知对方自己将要发送的数据长度和频段选择，如果收到最近的接入点返回的 响应 CTS，就认为信道是空闲的，然后再发送数据 接收端如果正确收到此数据帧，则经过一段时间间隔后，向发送端发送确认帧ACK。 发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，再发送数据。 CSMA/CA 碰撞避免协议一般用于无线局域网 为什么 CSMA/CD 协议不适用于无线网呢？ 碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道。一旦检测到碰撞，就立即停止发送。但由于无线信道的传输条件特殊，其信号强度的动态范围非常大，因此在802.11适配器上接收到的信号强度往往会远远小于发送信号的强度(信号强度可能相差百万倍)。如要在无线局域网的适配器上实现检测到碰撞，在硬件上需要的花费就会过大。 更重要的是，即使我们能够在硬件上实现无线局域网的碰撞检测功能，我们仍然无法避免碰撞的发生。这就表明，无线局域网不需要进行碰撞检测。 七、局域网 LAN局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 1. 局域网分类 以太网 令牌环网 FDDI ATM 无线局域网 WLAN 2. 局域网拓扑结构 3. MAC子层和LLC子层MAC子层和物理层对接，LLC子层和网络层对接 媒体访问控制（MAC）技术构成局域网的主要内容， 不同的媒体访问控制技术—不同的协议—不同的帧格式； LLC的目的：屏蔽不同MAC技术，向高层提供统一服务和接口 八、以太网以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网提供 无连接，不可靠 的服务 MAC地址MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 九、PPP协议互联网用户通常需要连接到某个 ISP(互联网服务提供商) 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 用户使用拨号电话接入因特网一般都使用PPP协议。 只支持全双工链路 十、链路层设备隔离冲突域，不隔离广播域 1. 网桥 / 二层交换机工作于OSI模型的第2层，因而称为二层交换机 网桥：根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧的时候，并不向所有接口转发此帧（集线器），而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口，或者是把他丢弃 网桥的功能在延长网络跨度上类似于中继器/集线器，然而它能提供智能化连接服务，即根据帧的终点地址处于哪一网段来进行转发和滤除 网桥只用于连接相同类型的网络。 2. 多接口网桥","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"物理层","slug":"计算机网络/2-物理层","date":"2020-02-22T14:02:45.000Z","updated":"2020-09-04T15:48:45.107Z","comments":true,"path":"2020/02/22/计算机网络/2-物理层/","link":"","permalink":"https://aaronyard.github.io/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"🧀 物理层 思维导图 一、物理层的作用在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。","text":"🧀 物理层 思维导图 一、物理层的作用在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 二、三种通信方式1. 单工通信发送方和接收方固定，单向传输，仅需要一条信道（类比广播） 2. 半双工通信通信的双方都可以发送和接收，但不能同时发送和接收，交替传输，需要两条信道（类比对讲机） 3. 双工通信双方可以同时发送和接收，双向同时传输（类比打电话） 三、两种数据传输方式1. 串行传输将表示一个字符的8位二进制数按照从低位到高位的顺序，在一条信道按照顺序发送 特点：速度慢，费用低，适合远距离 2. 并行传输将表示一个字符的8位二进制数同时通过8条信道发送，接收方再根据顺序重新组装这些数据 特点：速度快，费用高，适合近距离（远距离传输时，线间干扰导致可靠性下降） 四、实现同步的传输方式同步：接收方在时间上与发送方取得同步，以便能够正确的识别和接收发送方发来的数据 1. 同步传输 Synchronous Transmission同步传输就是发送方和接收方的时钟要同步，数据的传送以一个数据块为单位，因此同步传输也称区块传输 发送：同步符号(起始字符)＋数据块＋同步符号(结束字符） 接收：遇到同步符号，开始接收数据，直到结束符号为止。 同步符号：标识数据块的开始和结束 可能存在的问题：假同步现象 — 数据块中含有与同步符号相同的内容 解决方法：增加匹配同步符号的难度 SYN,SYN,G,H, …,B,A,SYN,D,E,SYN,SYN 传输方向 打个比方：就像双方约好了发送方每过一个小时就发送一次打包好的数据（帧）给接收方，接收方也每过一个小时接收一次数据（帧）。但是接收方不明白这一串数据得有多长，不能说传过来的数据收了一半就算完成了，所以得有起始位和结束位方便识别接受到的数据是否完整。 2. 异步传输 Asynchronous Transmission异步传输就是发送方和接收方没有时钟同步。异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方并不知道它们会在什么时候到达。 一个常见的例子是计算机键盘与主机的通信。按下一个字母键、数字键或特殊字符键，就发送一个8比特位的ASCII代码。键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。 异步传输存在一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。 同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。 3. 同步传输和异步传输的区别 异步传输是面向字符的传输，而同步传输是面向比特的传输。 异步传输的单位是字符，而同步传输的单位是帧。 异步传输通过字符起止的开始和停止码抓住再同步的机会，而同步传输则是以数据中抽取同步信息。 异步传输对时序的要求较低，同步传输往往通过特定的时钟线路协调时序。 异步传输相对于同步传输效率较低。 简单来说： 同步传输就是，数据没有被对方确认收到则调用传输的函数就不返回。接收时，如果对方没有发送数据，则你的线程就一直等待，直到有数据了才返回，可以继续执行其他指令 异步传输就是，你调用一个函数发送数据，马上返回，你可以继续处理其他事，接收时，对方的有数据来，你会接收到一个消息，或者你的相关接收函数会被调用。 形象点说： 异步传输: 你传输吧，我去做我的事了，传输完了告诉我一声 同步传输: 你现在传输，我要亲眼看你传输完成，才去做别的事 五、数据通信相关术语1. 码元码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形 1 码元可以携带多个比特的信息量 2进制编码 —&gt; 2种码元 0 和 1 ，称为二进制码元：0 1 4进制码元—&gt; 4种不同的信号波形：01 10 00 11 2. 速率 码元传输速率：1s 传输多少个码元 ，单位：波特 Baud 信息传输速率：1s 传输多少个比特 六、奈氏准则、香农定理① 失真发送的信号波形失真导致无法识别 失真的一种现象：码间串扰 接收端收到的信号波形因为振动太快（传播速度太快）失去了码元之间清晰界限的现象 ② 奈氏准则在任何信道中，码元传输速率是有上限的，若传输速率超过此上限，就会出现码间串扰问题 奈氏准则提出了在假定的理想条件下（无噪声，带宽受限），为了避免码间串扰，码元传输速率的上限是 2W 波特（W 是带宽 Hz） 也就是说，信道的频带越宽，就可以用更高的速率进行码元的有效传输 最大数据传输率 = 2Wlog2V (b/s) （V 表示有几种码元） ③ 香农定理香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率上限值为：Wlog2(1+S/N) （b/s)，其中 S/N 代表信噪比 也就是说，信道的带宽或者信噪比越大，则信息的最大传输速率就越高 七、编码与调制编码与调制其实就是模拟信号和数字信号的转换过程 1. 数字信道和模拟信道数字信道是能传输数字信号的信道。数字信号传输的是不连续的、离散的二进制脉冲信号。在它的整个信号中只有两种状态，高电平与低电平，高电平用逻辑1表示低电平用逻辑0表示。 模拟信道是能传输模拟信号的信道。模拟信号的电平随时间连续变化，具有周期性的正弦波信。语音信号是典型的模拟信号。模拟信号一般通过PCM脉码调制方法量化为数字信号，即让模拟信号的不同幅度分别对应不同的二进制值。 2. 基带信号和宽带信号 基带信号：数字信道上传输，保持数据波的原样进行传输。适合距离较近，信号可同时向两个方向扩散 宽带信号：模拟信道上传输，把基带信号经过载波调制后，把信号的频率范围搬移道较高的频段以便在信道中传输。适合距离较远，信号仅向一个方向扩散 3. 编码：数据——&gt;数字信号① 数字数据——&gt;数字信号 非归零编码 高1低0，没有检错功能 曼彻斯特编码 一个码元分成两个间隔，前低后高表示1，前高后低表示0（自己定） 差分曼彻斯特编码 同1异0 归零编码 信号电平在一个码元内都要恢复到0 反向不归零编码 电平反转表示0，状态不变表示1 4B/5B编码 ② 模拟数据——&gt;数字信号 抽样 量化 编码 4. 调制：数据——&gt;模拟信号① 数字数据——&gt;模拟信号 调幅 调频 调相 调频 + 调相 ② 模拟数据——&gt;模拟信号频分复用 八、物理层传输介质1. 导向型传输介质 双绞线：适用于近距离 屏蔽双绞线 无屏蔽双绞线 同轴电缆（抗干扰性强）：适用于远距离 光纤：带宽远远大于其他传输媒体 单模光纤：适合远距离 多模光纤：适合近距离 2. 非导向型传输介质 无线电波 微波 红外线、激光 九、物理层设备1. 中继器对信号进行再生和还原，增加信号传输的距离，延长网络的长度 2. 集线器（多口中继器）集线器不能分割冲突域，连在集线器上的工作主机平分带宽","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络相关概念","slug":"计算机网络/1-计算机网络相关概念","date":"2020-02-21T14:02:45.000Z","updated":"2020-09-04T15:48:49.117Z","comments":true,"path":"2020/02/21/计算机网络/1-计算机网络相关概念/","link":"","permalink":"https://aaronyard.github.io/2020/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","excerpt":"⛵ 计算机网络相关概念 一、思维导图 二、 计算机网络的概念计算机网络是以共享资源（硬件、软件和信息等） 为目的而连接起来的、在协议控制下，由一台或多台计算机、终端设备、数据传输设备等组成的系统之集合。 这些计算机系统应当具有独立自治的能力，是可以独立运行的系统。 计算机网络是自治的、互连的计算机集合","text":"⛵ 计算机网络相关概念 一、思维导图 二、 计算机网络的概念计算机网络是以共享资源（硬件、软件和信息等） 为目的而连接起来的、在协议控制下，由一台或多台计算机、终端设备、数据传输设备等组成的系统之集合。 这些计算机系统应当具有独立自治的能力，是可以独立运行的系统。 计算机网络是自治的、互连的计算机集合 自治 ：无主从关系 互连 ：互连互通 三、计算机网络的功能计算机联网的主要目的 —— 跨越时空： 数据通信 资源共享 分布式处理 提高可靠性 负载均衡 。。。 四、计算机网络的组成1. 组成部分 硬件 软件 协议 2. 工作方式 边缘部分（用户直接接触使用） 核心部分（为边缘部分服务） 3. 功能组成 通信子网：实现数据通信（由各种传输介质，通信设备，相应的网络协议组成） 资源子网：实现资源共享/数据处理（实现资源共享功能的设备和软件的集合） 五、计算机网络的分类1. 按分布范围分 广域网 WAN 支持用户使用计算机进行远距离的信息交换； 覆盖范围广，结点间距离远，考虑因素增多； 电信部门或公司负责组建、管理和维护，并向全社会提供面向通信的有偿服务，流量统计和计费问题 域域网 MAN 局域网 LAN 局域网是将分散在有限地理范围内（如一栋大楼，一个部门）的 多台计算机通过传输媒体连接起来的通信网络，通过功能完善的 网络软件，实现计算机之间的相互通信和共享资源。 个人局域网 PAN 2. 按使用者分 公用网：资源可供任何人使用 专用网：资源仅供有限对象使用 利用公用网组建专用网 — 虚拟专用网（VPN） 比如金融网，教育网，政府网等 3. 按交换技术分 电路交换网：类电话交换系统 报文交换网：基于存储转发，报文体积不限 分组交换网：基于存储转发，分组体积限制 目前所有的计算机网络均采用分组交换技术，但因环境不同，分组体积不同。 4. 按拓扑结构分 什么是拓扑：网络拓扑结构就是指用传输媒体把计算机等各种设备互相连接起来的物理布局，是指互连过程中构成的几何形状，它能表示出网络服务器、工作站的网络配置和互相之间的连接。总线型 星型 网状型 环型 5. 按传输技术分 广播式网络：共享公共通信信道 点对点网络：使用分组存储转发和路由选择机制 六、性能指标1. 速率速率 即 数据率 或称 数据传输率 或者 比特率 单位：b/s，kb/s，Mb/s，Gb/s，Tb/s 各单位之间倍数10^3 对于存储容量KB，MB，GB，TB各单位之间倍数 2^10 2. 带宽（理想速率） 带宽原本指最高频率和最低频率之差，单位是赫兹，HZ 在计算机网络中，带宽是指单位时间内网络中某一点到另一点能通过的 最高/理想 数据率 单位 比特/s （b/s） 3. 吞吐量（实际速率）单位时间内网络中某一点到另一点通过的 实际 数据率 ，单位 b/s 4. 时延数据从网络中某一点传达到另一点所需的时间，也叫 延迟 或 迟延，单位 s具有以下几种时延： 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 传输/发送 时延主机或路由器传输数据帧所需要的时间。 传播时延电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。取决于电磁波传播速度和链路长度 5. 时延带宽积时延带宽积 = 传播时延 X 带宽时延带宽积表示 某段链路现在有多少比特 6. 往返时间 RTT从发送方发送数据 到 发送方街道接收方的确认，总共经历的时间 RTT 越大，在收到确认之前可以发送的数据越多 7. 利用率 信道利用率有数据通过的时间 / （有+无）数据通过时间 网络利用率信道利用率加权平均值 七、计算机网络体系结构 1. OSI 七层参考模型 OSI ：开放系统互联参考模式 Open System Interconnection ① 应用层应用层是网络可向最终用户提供应用服务的唯一窗口，其目的是支持用户联网的应用要求 ② 表示层设备固有数据格式和网络标准数据格式的转换 ③ 会话层通信管理。负责建立和断开通信连接，管理传输层以下的分层。 何时建立连接，何时断开连接以及保持多久的连接 ④ 运输层负责不同主机两个进程之间的可靠传输，即端到端的通信 功能：（TCP/UDP） 可靠传输、不可靠传输可靠传输需要建立TCP连接，一般用于传输大数据不可靠传输不需要建立连接，可能发生丢失，一般用于传输小数据 差错控制 流量控制 (限制发送方的速率) 拥塞控制 （若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此需要采取拥塞控制） 复用分用 以上功能在运输层再详细解释 ⑤ 网络层将运输层传下来的用户数据报切割成分组，分组转发把分组从源端传递到目的端，为分组交换上的不同主机提供通信服务 功能： 路由选择 流量控制 差错控制 拥塞控制 以上功能在网络层再详细解释 ⑥ 数据链路层把网络层传下来的数据报组装成帧，将物理层有差错的物理链路转换为逻辑上无差错的数据链路功能： 成帧 差错控制 流量控制 访问控制（控制对信道的访问） ⑦ 物理层在物理媒介上实现比特流的透明传输（即不管什么样的比特组合，都应当能在链路上传送） 功能： 定义接口特性 定义传输模式（单双工/半双工/双工） 定义传输速率 比特同步 比特编码 2. TCP/IP 四层参考模型 应用层 运输层 网际层 网络接口层 相当于五层协议中数据链路层和物理层合并为网络接口层 3. 五层协议一般我们用五层协议模型来进行计算机网络的学习 应用层 运输层 网络层 数据链路层 物理层 五层参考模型的数据封装和解析过程： 4. 为什么要分层 各层之间相互独立：高层不需要知道底层的功能是如何实现的，它只需要通过底层提供的接口获取服务即可 灵活性好：各层都可以采用最适当的技术来实现，如果某一层的实现技术发生了变化，但只要实现接口不变，该层的变化就不会对其他各层以及整个系统的工作产生影响 易于实现和标准化：由于采用了规范的层次结构取组织网络功能和协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与交互过程，有利于将网络复杂的通信过程化简为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于实现和标准化 5. 分层的原则 独立性：减少模块之间交互的信息，降低依赖性 单向性：即高层可使用低层的服务，低层无法使用高层的。降低实现难度 增值性：各模块在使用下层服务的基础上，提供增值服务 同构性：互连的计算机系统应当具有相同的层次结构 适用性：同构系统的相同层次间才能进行有意义的通信（对等层间通信） 6. 层间通信相邻层之间通信： 相邻的上下层之间的通信；属于局部问题，标准中只定义了通 信的内容（服务原语），未规定这些内容的具体表现形式和层间 通信实现的具体方法。 对等层之间通信： 不同开放系统中的相同层次之间的通信，对等层实体之间的信息交换； OSI标准为每一层的通信都严格定义了 *协议数据单元 PDU *的格式。 对等层之间的通信是目的，（对等层实体的协作保证该层功能和 服务的实现）； 相邻层之间的通信是手段，（保证对等层实体之间的通信得以实 施） 八、计算机通信计算机通信的实质：进程间通信，各进程间相互制约的等待或互通消息 1. 同一计算机系统在同一计算机系统中，进程与进程之间的通信通过设置共享区来实现，比如共享内存、缓冲区、文件等 2. 不同计算机系统不同计算机系统之间通过网络进行通信，利用线路和中继设备的传输、存储、处理能力 不同计算机系统通信所需要的通信软件： 通信接口：设备和各个部件之间的衔接 网络控制程序：调度网络资源的使用情况 网络应用程序 遵循协议实际上一组规则或约定，是计算机之间得以正确通信的保障！ 是计算机网络研究的重点 九、Internet 和 WWW 的关系Internet：因特网。泛指全世界各国计算机网络用各种传输介质相互连接起来的的集合，也称为网络的网络。Internet 提供的主要服务有 万维网 WWW 文件传输 FTP 电子邮件 E-Mail 远程登录 Telnet WWW：World Wide Web 万维网。是无数个网页和站点的集合，万维网是全世界最大的资料空间，空间中的资源通过唯一的 URL 统一资源标识符来表示。这些资源通过 HTTP 协议传输给用户，用户通过点击超链接获取资源。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://aaronyard.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统面试指南","slug":"操作系统/操作系统面试指南","date":"2020-02-17T14:02:45.000Z","updated":"2020-09-04T15:47:48.655Z","comments":true,"path":"2020/02/17/操作系统/操作系统面试指南/","link":"","permalink":"https://aaronyard.github.io/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"🔍 操作系统面试指南 一、操作系统概述1. 什么是操作系统 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。 内核就是操作系统背后黑盒的核心。","text":"🔍 操作系统面试指南 一、操作系统概述1. 什么是操作系统 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。 内核就是操作系统背后黑盒的核心。 2. 什么是微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 因为需要频繁地在用户态和内核态之间进行切换，所以会有一定的性能损失。 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁地在用户态和核心态之间进行切换，性能低 华为发布的鸿蒙操作系统就是使用的微内核 3. 并发和并行的区别 ⭐ 并发：并发是指宏观上在一段时间内能同时运行多个程序。这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行 ； 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。 比如Intel的第八代i3处理器就是4核CPU，意味着可以并行地执行4个程序即使是对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此 并发性 是操作系统一个基本的特性 并行：并行则指同一时刻能运行多个指令，指两个或多个事件在同一时刻同时发生。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 4. 中断的作用中断使得 CPU 由 用户态 变为内核态，使操作系统重新夺回对 CPU 的控制权 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode):可以简单的理解内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。 5. 中断的类型软（内）中断： 编程异常通常叫做软中断（比如 int i = 1/0 ） 软中断是通讯进程之间用来模拟硬中断的一种信号通讯方式。 中断源发中断请求或软中断信号后,CPU 或接收进程在适当的时机自动进行中断处理或完成软中断信号 对应的功能 软中断是软件实现的中断,也就是程序运行时其他程序对它的中断;而硬中断是硬件实现的中断,是程序运 行时设备对它的中断。 硬（外）中断： 硬中断是由外部事件引起的，因此具有随机性和突发性； 软中断是执行中断指令产生的，无外部施加中断请求信号，因此中断的发生不是随机的而是由程序安排好的。 硬中断的中断响应周期，CPU 需要发中断回合信号（NMI 不需要），软中断的中断响应周期，CPU 不 需发中断回合信号。 硬中断的中断号是由中断控制器提供的（NMI 硬中断中断号系统指定为02H）；软中断的中断号由指令直接给出，无需使用中断控制器。 硬中断是可屏蔽的（NMI 硬中断不可屏蔽），软中断不可屏蔽。 区别： 软中断发生的时间是由程序控制的,而硬中断发生的时间是随机的 软中断是由程序调用发生的,而硬中断是由外设引发的 硬件中断处理程序要确保它能快速地完成它的任务,这样程序执行时才不会等待较长时间。 6. 操作系统中使用了哪些数据结构 栈： 比如内存管理中页面置换算法的先进先出置换算法 磁盘调度算法中先来先服务算法FCFS 队列： 比如内存管理中页面置换算法的时钟算法CLock 磁盘调度算法中扫描算法 链表： 进程管理中进程控制块的链接 进程通信IPC中的消息队列方法（消息的链表） 树： 进程管理中进程家族关系描述：进程树 散列表： 内存管理中对于内存的分配与回收，连续分配管理方式使用的是Hash算法 文件管理：Hash文件 7. 什么是系统调用，简述系统调用的过程操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。 “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 系统调用的过程如下： 传递系统调用参数 ——&gt; 执行陷入指令（用户态），引发一个内中断（保护被中断进程的CPU环境），使CPU进入内核态 ——&gt; 执行相应的请求，内核程序处理系统调用（内核态）——&gt; 返回应用程序（恢复被中断进程的CPU环境） 二、进程、线程、死锁1. 进程和程序的区别 ① 进程是动态的，程序是静止的。进程是程序的执行，程序是有序代码的集合。 ② 进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可以长久保存。 ③ 进程和程序的组成不同：进程包括程序，数据和进程控制块。 ④ 进程和程序是密切相关的。通过多次执行，一个程序可以对应多个进程；通过调度关系，一个进程可以包括多个程序。 ⑤ 进程可以创建其他进程，但是程序不能形成新的程序 2. 进程和线程的区别 ⭐ ① 调度：线程是独立调度的基本单位，进程是资源分配的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，将会引起进程切换。 ② 拥有资源：进程是拥有资源的基本单位，而线程不拥有系统资源（除了少量资源，比如栈，程序计数 器，寄存器），不过线程可以访问其隶属进程的系统资源。 ③ 并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且同一个进程内的多个线程之间 也可以并发执行，能提高系统的吞吐量，系统的并发性也更好。 ④ 系统开销：在创建进程和撤销进程时，系统都要为之分配或回收资源，所以操作系统为进程付出的系统开销远大于创建线程或撤销线程的开销。 ⑤ 同步和通信：多线程之间的同步和通信容易实现。 3. 进程和作业的区别一个进程是一个程序对某个数据集的执行过程，是资源分配的基本单位。 作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业的完成要经过作业提交、作业收容、作业执行和作业完 成4 个阶段。 其主要区别如下。 作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业后，系统将它放入外存中的作业等 待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程， 只要它被创建，总有相应的部分存在于内存中。 一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。 作业的概念主要用在批处理系统中，像UNIX 这样的分时系统中就没有作业的概念。而进程的概念则 用在几乎所有的多道程序系统中进程是操作系统进行资源分配的单位。在Windows 下,进程又被细化为线程,也就是一个进程下有多个能独立运行的更小的单位。 4. 进程树/线程树进程树是一个形象化的比喻，比如一个进程启动了一个程序，而启动的这个进程就是原来那个进程的子进 程，依此形成的一种树形的结构，我们可以在进程管理器选择结束进程树，就可以结束其子进程和派生的子进程。 5. 进程的状态以及转换过程 ⭐三态模型： 运行态 就绪态 阻塞态 五态模型： 创建态 就绪态 运行态 阻塞态 结束态 进程状态切换过程： 进程被创建后进入就绪态，此时尚未获得CPU资源 通过进程调度，进程获得CPU资源，进入CPU执行，转入运行态 若运行过程中该进程时间片用完，则失去CPU资源，转入就绪态 若运行过程中该进程发生等待事件（比如缺少可用资源（不包括CPU资源，缺少CPU资源会转入就绪态）或者等待I/O操作完成），转入阻塞态 若阻塞态的进程已经获得全部所需资源，则转入就绪态，等待进程调度获得CPU资源转入运行态 6. 进程调度算法 ⭐ 先来先服务 FCFS 非抢占式 按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。 短作业优先 SJF 非抢占式 每次调度时选择当前 已到达 且 运行时间最短 的作业/进程。 最短剩余时间优先 SRTN 抢占式 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 高响应比优先 HRRN 非抢占式 只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的 进程上处理机。 响应比 = (等待时间+要求服务时间) / 要求服务时间 7. 进程间的通信方式 ⭐大概有 7 种常见的进程间的通信方式。 管道/匿名管道(Pipes) ：管道是指用于连接读写进程的一个共享文件，采用半双工通信，同一时间段只能实现单向的传输。用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。无名管道文件存在于内存中。 有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。 管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启) 或者显示地删除一个消息队列时，该消息队列才会被真正的删除。 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 8. 操作系统中的信号量信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。整型变量 s 表示系统中某类资源的数目，当其值大于 0 时，表示系统中当前可用资源的数目；当其值 小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。 信号量分类： ① 整型信号量：所谓整型信号量就是一个用于表示资源个数的整型量 ② 记录型信号量（资源信号量）：就是用一个结构体实现，里面包含了表示资源个数的整型量和一个等待队列。 信号量的应用： ① 实现进程同步 ② 实现进程互斥 9. P V 操作信号量的值除了初值外，仅能由PV原语加以改变。 P、V 操作以原语形式实现，保证了对信号量进行操作过程中不会被打断或阻塞。 P 操作申请资源，V 操作释放资源。 P操作和V操作必定成对 出现，但未必在同一个进程中。 10. 进程同步的方法 临界区：一次仅允许一个进程访问的资源称为临界资源，对临界资源进行访问的那段代码称为临界区 信号量：PV操作 管程：把控制的代码独立出来 11. 进程同步和进程通信的区别 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 12. 死锁相关 ⭐进程同步离不开死锁问题 ▲ 什么是死锁： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 比如有A和B两个进程，A需要请求B的资源，B需要请求A的资源，但是A和B都对自己拥有的资源不放手，就导致循环等待，即产生死锁 ▲ 死锁产生的必要条件： 互斥：即只有对必须互斥使用的资源的争抢才会导致死锁。 请求和保持：进程已经拥有资源，但又提出了新的资源请求，而该资源又被其他进程所占有，于是该进程进入阻塞态，但还是对自己拥有的资源保持不放，贪得无厌。 不可抢占/不剥夺：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 循环等待：存在一种进程资源的循环等待环路，该环路中的每个进程都在等待下一个进程所占有的资源。 ▲ 死锁的处理策略： 死锁的产生必须满足四 个必要条件，只要其中一个或者几 个条件不满足，死锁就不会发生。 鸵鸟策略：忽略死锁 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁预防：：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁（比如破坏请求和保持条件，一次性给足进程所需的全部资源，不允许进程在运行过程中请求资源）。 预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 死锁避免：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的 的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免 发生死锁。 比如银行家算法（主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先进行试分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生） 死锁检测和解除：如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施。在这种情况下，系统应当提供两个算法： ①死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。 ②死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。 13. 饥饿、死锁、活锁 死锁(deadlock) 指的是两个或者两个以上的进程相互竞争系统资源，导致循环等待，致使进程永久阻塞。例如： 桌子上有慢慢一桌子的美食，但是只有一双筷子。 甲拿了一根，然后在找另一根。 乙拿了一根，然后也在自找另一根。 因为他们都掌握了对方必需的资源，导致最后他们俩谁都吃不到美食。 活锁 活锁和死锁很相似。 只是活锁的状态可以发生改变。不过虽然状态可以改变，却没有实质的进展。 比如两个人在一个很宅的胡同里。 一次只能并排过两个人。 两人比较礼貌，都要给对方让路。 结果一起要么让到左边，要么让到右边，结果仍然是谁也过不去。 类似于原地踏步或者震荡状态。 活锁一般是由于对死锁的不正确处理引起的。由于处于死锁中的多个线程同时采取了行动。 而避免的方法也是只让一个线程释放资源。 饥饿(starvation) 指的是等待时间长到已经影响到进程运行，此时成为饥饿现象。如果等待时间过长，导致进程使命已经没有意义时，称之为 饿死（一个线程在无限地等待另外两个或多个线程相互传递使用并且永远不会释放的资源）。但是有人饿死并不代表着出现了死锁。例如： 小明要告诉妈妈明天开家长会。 小明妈妈因为工作太忙，在公司加班，没有回家。 于是第二天，小问明的妈妈就错过了家长会。（“饿死”） 其实小明的妈妈没有出现“死锁”。只是小明的优先级过低，不如工作重要 ，所以就没有把自己拥有的时间资源分配给他。 三、内存管理1. 操作系统的内存管理主要是做什么操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？主要包括以下四个方面： 内存空间的分配与回收 内存空间的扩充（虚拟存储技术） 地址转换/重定位（逻辑地址和物理地址的转化） 存储保护（保证各进程在各自存储空间内运行，互不干扰） 2. 内存管理有哪几种方式/常见的内存管理机制 ⭐分为连续分配管理方式和非连续分配管理方式这两种。 连续分配管理方式：是指为一个用户程序分配一个连续的内存空间。 单一连续分配：内存中只能有一道用户程序，用户程序独占整个用户区空间。有内部碎片（如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片），存储利用率低下。 固定分区分配：将整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业 动态分区分配：这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。 非连续分配管理方式：允许一个程序使用的内存分布在离散或者说不相邻的内存中。 基本分页式存储管理：把主存分为大小相等且固定的一页一页的形式，页较小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。页与页之间不连续，但页的内部连续。 基本分段式存储管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。段与段之间不连续，但段的内部连续。 段页式管理：段页式管理机制结合了段式管理和页式管理的优点。 简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页. 也就是说 段页式管理机制 中段与段之间以及段的内部的都是不连续的。 3. 连续分配和非连续分配的比较连续分配：指为用户进程分配的必须是一个连续的内存空间。 非连续分配：为用户进程分配的可以是一些分散的内存空间。 4. 什么是内部碎片和外部碎片内部碎片：分配给进程的存储空间中未被利用的部分 外部碎片：系统中无法利用的小的存储块，比如通过动态分区分配技术从空闲内存区上分配内存后剩下的那部分内存块 5. 什么是拼接技术？在分区管理方式下，系统运行一段时间后，内存中会出现相当一部分的碎片，拼接技术是解决碎片问题的方法。 即将存储器中所有已分配分区移动到主存的一端，使本来分散的多个小空闲区连成一个大的空闲区，这种通过移动把多个分散的小分区拼接成一个大分区的方法即为拼接技术。 6. 基本分页存储 — 多级页表和快表页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。 在分页内存管理中，很重要的两点是： 逻辑地址到物理地址的转换要快。（快表解决） 解决逻辑地址空间大，页表也会很大的问题。（多级页表解决） 页表： 进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 注：页表通常存在PCB（进程控制块）中 一个进程对应一张页表 进程的每个页面对应一个页表项 每个页表项由 页号 和 块号 组成 页表记录进程页面和实际存放的内存块之间的映射关系 每个页表项的长度是相同的 即页表中的页号对应进程的逻辑地址，页表中的块号对应内存中的实例物理地址 多级页表：引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。 快表 TLB: 为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表TLB 来加速逻辑地址到物理地址的转换。 快表，又称联想寄存器（TLB，translation lookaside buffer ），是一种访问速度比内存快很多的 高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。 与此对应，内存中的页表常称为慢表。 若快表命中，就不需要再访问内存了，若快表中没有目标页表项，则需要查询内存中的页表 使用快表之后的地址转换流程是这样的： 根据逻辑地址中的页号查快表； 如果该页在快表中，直接从快表中读取相应的物理地址； 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中； 当快表填满后，又要登记新页时，就按照页面置换算法淘汰掉快表中的一个页。 总结：为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理 7. 基本分页存储管理和基本分段存储管理的共同点和区别 ⭐共同点 ： 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。 页和段都是离散存储的，两者都是非连续存储管理的方式。但是，每个页和段中的内存是连续的。 区别 ： 页的大小是固定的，由操作系统决定； 而段的大小不固定，取决于我们当前运行的程序。 分页是信息的物理单位，仅仅是为了满足操作系统内存管理的需求，主要目的是为了实现离散分配，提高内存利用率；实现虚拟内存，从而获得更大的地址空间。对用户是不可见的 而段是信息的逻辑单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要，对用户可见，用户编程时需要显示的给出段名。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址 8. 内存空间的扩充方法 覆盖技术：将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘之间的动态调度） 虚拟内存：匀出一部分硬盘空间作为内存使用（详细见下文） 9. 逻辑地址和物理地址逻辑地址是相对地址，物理地址是绝对地址。 我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。 10. 静态/动态重定位操作系统需要提供地址转换功能，负责程序的 逻辑地址 与 物理地址 的转换 为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 将逻辑地址空间重定位到物理地址空间的时机有三种： 程序编译链接时 程序装入内存时 程序执行时 ① 静态重定位 静态重定位是在程序执行之前（编译链接时）进行重定位。对每个程序来说，静态重定位是在装入内存时一次性完成的，在程序运行期间不再进行重定位 优点： 无须硬件支持 缺点： 一是程序重定位之后就不能在内存中搬动了； 二是要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域内。 ② 动态重定位 动态重定位是在程序执行过程中进行地址重定位，更确切地说，是在CPU每次访问内存单元前才进行地址变换。动态重定位一般需要硬件支持。 优点： 目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的； 一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。 缺点： 需要硬件支持 11. CPU 寻址了解吗?为什么需要虚拟地址空间?CPU寻址： 现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。如下图所示： 为什么要有虚拟地址空间呢？ 没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存 。但是这样有什么问题呢？ 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。 总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。 通过虚拟地址访问内存有以下优势： 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。 四、内存管理之虚拟内存 ⭐1. 什么是虚拟内存(Virtual Memory)?我们都知道一个进程是与其他进程共享CPU和内存资源的。正因如此，操作系统需要有一套完善的内存管理机制才能防止进程之间内存泄漏的问题。 为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序拥有超过系统实际物理内存大小的可用内存空间。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等 虚拟内存和交换空间，这两个概念要和操作系统一起说，window下的“虚拟内存”实际上是存在磁盘上的页面文件，和linux的交换空间概念一样，都是物理上实际存在的东西，如果内存够用，没有缺页，你禁掉这两个东西不会影响虚拟存储器；然而撇开操作系统，只谈理论，虚拟内存还是一种技术，它允许执行进程不必完全放在内存中。这两种其实都属于交换技术，交换技术除了因为内存紧张要使用之外，还有在一些操作系统如分时系统中为了改善进程组合(CPU密集型和IO密集型)也要用它进行中期调度。 电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。 虚拟内存在硬盘上其实就是为一个硕大无比的文件，文件名是 PageFile.Sys，所以虚拟内存也称页面文件。 虽然把它当做内存用，可这块空间毕竟是在硬盘，速度肯定不如真的内存，所以说它是虚的。 当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。若计算机运行程序或操作所需的随机存储器（RAM）不足时，则Windows会用虚拟存储器进行补偿。它将计算机的RAM和硬盘上的临时空间组合。 当RAM运行速率缓慢时，它便将数据从RAM移动到称为“分页文件”的空间中。将数据移入分页文件可释放RAM，以便完成工作。一般而言，计算机的RAM容量越大，程序运行得越快。 若计算机的速率由于RAM可用空间匮乏而减缓，则可尝试通过增加虚拟内存来进行补偿。但是，计算机从RAM读取数据的速率要比从硬盘读取数据的速率快，因而扩增RAM容量（可加内存条）是最佳选择。 2. 局部性原理早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。 局部性原理表现在以下两个方面： 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 3. 什么是虚拟存储器虚拟存储器是一种机制，并不是一个实际存在的物理设备，是整个CPU访问内存过程的体现。 基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。 在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。 4. 如何实现虚拟内存技术虚拟内存的实现需要建立在非连续分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式： 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 5. 请求分页存储管理 和 (基本)分页存储管理 的区别请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。 请求分页存储管理不要求将作业全部地址空间同时装入主存。在分页存储管理的基础上增加了请求调页和页面置换的功能，基于这一点，请求分页存储管理可以提供虚存，而分页存储管理不能提供虚拟内存。 6. 页面置换算法有哪些? 最佳置换算法 OPT 被换出的页面将是最长时间内不再被访问的，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 先进先出置换算法 FIFO 选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 最近最久未使用置换算法 LRU 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。 LRU 将最近最久未使用的页面换出。 时钟置换算法 Clock / 最近未用算法 NRU 为每个页面设置一个访问位，当被访问时，访问位置为1。 当发生缺页中断时，NRU 算法只需检查页的访问位，如果是0（未被访问），就将该页换出； 如果是1，就将其置为0，暂不换出，继续检查下一个页面 五、文件管理1. 软链接和硬链接软链接和硬链接是实现文件共享的方法： 硬链接： 硬链接实际上就是为文件建一个别名，链接文件和原文件实际上是同一个文件。 在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode。 硬链接是不会建立 inode 的，他只是在文件原来的 inode 的 link count 域中增加 1 而已，因此硬链接是不可以跨越文件系统的。 硬链接删除的时候，系统调用会检查 inode link count 的数值，如果大于等于 1，那么 inode 就不会被回收，也即文件的内容不会被删除。 软链接： 软链接，其实就是建立一个新的文件，这个文件是专门用来指向别的文件的（和快捷方式类似）。 也就是说，软链接会产生一个新的 inode，不过这个 inode 只是指明源文件的字符串信息，一旦源文件删除了，那么软链接将变得毫无意义。 软链接可以跨越文件系统 。 由于软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此软链接访问共享文件的速度比硬链接要慢 2. 磁盘调度算法 先来先服务 FCFS First Come First Served 按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道时间优先 SSTF Shortest Seek Time First 优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 扫描/电梯算法 SCAN SSTF算法会产生饥饿的原因在于：磁头有可一直在一个小区域内来回移动。为了防止这个问题，可以规定，只有磁头移动道最外层磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法，类似于电梯，电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。因此也称电梯算法 循环扫描算法 C-SCAN SCAN算法对于各个位置磁道的响应频率不平均，而C-Scan算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动到起始端而不处理任何请求 六、设备管理1. 什么是DMA？什么是中断？两者的区别中断：是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。 DMA：是以数据块为单位传输的，在所要求传送的数据块全部传送结束时要求CPU进行中断处理，这样大大减少CPU进行中断处理的次数。 DMA 方式不需CPU干预传送操作，不占用CPU任何资源， 整个数据传输操作在一个称为”DMA控制器”的控制下进行的。CPU除了在数据传输开始和结束时做一点处理外，在传输过程中CPU可以进行其他的工作。这样，在大部分时间里，CPU和输入输出都处于并行操作。因此，使整个计算机系统的效率大大提高。 总结：中断和DMA的最大区别就是DMA不需CPU参与，而中断是需要CPU参与的。 七、链接1. 程序的装入方式有哪些？应用程序从用户编写的源文件到内内存中执行的进程大致分为三个阶段，经过编译程序将源代码编译为若干个目标模块，在通过链接程序将编译好的目标模块以及所需的库函数链接到一起，形成完整的装入模块，最后通过装入程序将这些装入模块装入内存并执行。（编译，链接，装入） 装入方式： ① 绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码， 不适合多道程序设计。 ② 可重定位装入：根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次 完成，之后不再改变，也称静态重定位。当操作系统为程序分配一个以某地址为起始地址的连续主存 区域后，重定位时将程序中指令或操作数的逻辑地址加上这个起始地址就得到了物理地址。 ③ 动态运行装入：允许程序运行时在内存中移动位置，把装入模块装入到内存后的所有地址都是相对地址，在程序执行过程中每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物 理地址。动态重定位的实现要依靠硬件地址变换机构。 2. 程序的链接方式有哪些？ ① 静态链接：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开。 ② 装入时动态链接：将应用程序编译后所得到的一组目标模块在装入内存时采用边装入边链接的链接方式。 ③ 运行时动态链接：知道程序运行过程中需要一些模块时，才对这些模块进行链接","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"设备管理","slug":"操作系统/5-设备管理","date":"2020-02-15T14:02:45.000Z","updated":"2020-09-04T15:47:53.164Z","comments":true,"path":"2020/02/15/操作系统/5-设备管理/","link":"","permalink":"https://aaronyard.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","excerpt":"📠 设备管理 一、I/O设备的分类1. 按使用特性分类 人机交互类外部设备 存储设备 网络通信设备 2. 按传输速率分类 低速设备 中速设备 高速设备","text":"📠 设备管理 一、I/O设备的分类1. 按使用特性分类 人机交互类外部设备 存储设备 网络通信设备 2. 按传输速率分类 低速设备 中速设备 高速设备 3. 按信息交换的单位分类 字符设备 块设备 二、I/O管理的任务和功能 设备分配。按照设备类型和相应的分配算法觉得将I/O设备分配给哪一个进程。 设备处理。设备处理程序用以实现CPU和设备控制器之间的通信。 缓冲管理。设置缓冲区的目的是为了缓和I/O设备与CPU速度不匹配的矛盾。缓冲管理程序负责完成缓冲区的分配、释放及有关的管理工作。 设备独立性。设备独立性又称为设备无关性，是指应用程序独立于物理设备。用户在编程时要尽量避免直接使用实际设备名。若程序中使用了实际设备名，则当该设备没有连续在系统中或者该设备发生故障时，用户程序无法执行，若要运行用户程序，则需要修改程序。如果用户程序不涉及实际设备而使用逻辑设备，那么它所要求的输入输出便与物理设备无关。设备独立性可以提高用户程序的可适应性。 三、I/O控制方式I/O控制方式即什么样的方式来控制I/O设备的数据读/写 1. 程序直接控制方式 key word : 轮询！ 优点：过程简单。 缺点：CPU利用率相当底。由于CPU速度远远快于I/O设备，致使绝大部分时间都在测试I/O设备是否已经完成数据传输，从而造成CPU的极大浪费。 2. 中断驱动方式引入中断机制，由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器向CPU发生中断信号，CPU检测到中断信号，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断，CPU恢复等待I/O的进程的运行环境，然后继续执行。 优点：有了中断硬件的支持后，CPU与I/O设备之间可以并行工作，CPU只需要收到中断后处理即可，大大提高了CPU利用率。 缺点：如果每台设备每输入/输出一个数据，都要求中断CPU，这样在一次数据传送过程中的中断次数太多，从而耗费大量CPU时间。 3. DMA方式（直接存储器存取）1Direct Memory Access 优点：设备和CPU可以并行工作，同时设备与内存的数据交换速度更快，并且不需要CPU干预。 缺点：数据传送的方向、存放输入数据的内存起始地址及传送数据的长度等都由CPU控制，并且每台设备都需要一个DMA控制器，当设备增加时，多个DMA控制器的使用也不经济。 4. 通道控制方式 优点：解决了I/O操作的独立性和各部件工作的并行性。不仅能实现CPU与通道的并行操作，而且通道与通道之间也能实现并行操作，各个通道上的外设也能实现并行操作，从而提高了整个系统效率。 缺点：需要更多硬件（通道处理器），成本较高，常用于大型数据交互的场合。 5. 四种控制方式对比 四、I/O软件层次结构 1. 用户层软件 2. 设备独立性软件设备独立性软件，又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现。 主要实现的功能： 向上层提供统一的调用接口（如 read/wirte系统调用） 设备的保护（I/O设备被当作一种特殊的文件，也有相应的权限控制） 差错处理 设备的分配与回收 数据缓冲区管理 建立逻辑设备名到物理设备名之间的映射关系：根据设备类型选择调用相应的驱动程序 3. 设备驱动程序所有与设备相关的代码全部放在设备驱动程序中，由于设备驱动程序与设备密切相关，因此应为每一类设备配置一个驱动程序。 4. 中断处理程序中断处理是控制I/O**设备和内存与CPU之间的数据传送的主要方式**。中断与硬件相关，I/O设备的中断处理程序的代码与任何进程无关。当I/O完成时，设备便向CPU发送一个中断信号，CPU响应中断后便转入中断处理程序。 五、缓冲区管理1. 什么是缓冲区，有啥作用 缓冲区的引入是为了缓和CPU与设备速度不匹配的矛盾，提高了设备和CPU的并行操作成都，提高了系统吞吐量和设备利用率。 2. 缓冲区分类（按照缓冲区个数）单缓冲当用户进程发出一个I/O请求时，操作系统便在内存中为它分配一个缓冲区。设备与处理器对缓冲区的操作是串行的。 双缓冲可以提高处理器与设备的并行操作程度。当用户进程发出一个I/O请求时，操作系统便在内存中为它分配两个个缓冲区。数据先放入第一个缓冲区进行处理，再来的数据放入第二个缓冲区，当第一个缓冲区中的数据处理完后，若第二个缓冲区已经装满，则处理器又可以处理第二个缓冲区的数据，而输入设备又可以装填第一个缓冲区。 循环缓冲区为了解决设备输入/输出速度与处理器处理数据速度不匹配的情况。循环缓冲包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区的指针指向第一个缓冲区，这样多个缓冲区构成了一个环形。循环缓冲用于输入输出时，还需要有两个指针in和out。 缓冲池目前计算机系统中广泛使用缓冲池，缓冲池由多个缓冲区组成，其中的缓冲区可供多个进程共享，并且既能用于输入又能用于输出。缓冲池中的缓冲区按其使用状况可以形成以下三个队列： 空缓冲队列； 装满输入数据的缓冲队列（输入队列）； 装满输出数据的缓冲队列（输出队列）； 除上述三个队列外，还应具有以下四种工作缓冲区： 用于收容输入数据的工作缓冲区； 用于提取输入数据的工作缓冲区； 用于收容输出数据的工作缓冲区； 用于提取输出数据的工作缓冲区； 当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把其作为收容输入数据的工作缓冲区，然后把数据输入其中，装满后再把它挂到输入队列队尾。 当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入数据的工作缓冲区，计算进程从中提取数据，数据用完后再将其挂到空缓冲队列队尾。 当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出数据的工作缓冲区，当其中装满输出数据后，再将其挂到输出队列队尾。 当输出进程请求输出数据时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出数据的工作缓冲区，当数据提取完后，再将其挂到空缓冲队列的末尾。 3. 高速缓存和缓冲区的区别 两者存放的数据不同。高速缓存存放的是低速设备上的某些数据的备份；而缓冲区中放的则是低速设备传递给高速设备的数据，在低速设备中不一定有备份。 两者的目的不同。引入高速缓存的目的是为了存放低速设备上经常要被访问到的数据的备份；而缓冲区是为了缓和高速设备和低速设备间速度不匹配的矛盾。高速设备每次都会通过缓冲区与低速设备通信，不会直接访问低速设备。 六、设备的分配与回收设备分配时应考虑的因素 设备的固有属性 设备分配算法 设备分配时的安全性 1. 设备的固有属性 独享设备。 共享设备。 虚拟设备。 SPOOLing技术见下文详细介绍 2. 设备的分配算法 先来先服务 优先级高者优先 短任务优先 3. 设备分配时的安全性指在设备分配中应保证不发生进程的死锁。分配方式分为以下两种方式： 静态分配：指用于作业开始执行前，由系统一次性分配该作业所需的所有资源。 动态分配：指在进程执行过程中根据执行需要进行设备分配。在进程需要设备时申请，不需要时释放。 动态分配又分为安全分配和不安全分配。 安全分配方式中，每当进程发出I/O请求后就进入阻塞状态，直到I/O完成才被唤醒。 不安全分配方式中，允许进程在发出I/O请求后仍然执行，且可以继续发出I/O请求，可能 发生死锁，需要安全性检测。 4. 设备分配管理中的数据结构设备、控制器、通道之间的关系： 设备分配管理中的数据结构如下： 设备控制表（DCT）。用于记录设备的特性及I/O控制器的连接情况。 设备控制器控制表（COCT）。用于反应设备控制器的使用状态和通道的连接情况等。 通道控制表（CHCT）。用于反映通道的状态等。 系统设备表（SDT）。整个系统只有一张系统设备表，记录了已经连接到系统中的所有物理设备的情况，每个设备占有一个表目。 5. 设备分配程序（1）单通路I/O系统的设备分配 步骤如下： 分配设备； 分配设备控制器； 分配通道； 在分配时，如遇到对应设备忙的情况，则将进程插入到对应的等待队列中。 （2）多通路I/O系统的设备分配 即一个设备与多个设备控制器相连，设备控制器也与多个通道相连。步骤如下： 根据设备类型，检索系统设备控制表，找到第一个空闲设备，并检测分配的安全性，如安全则分配；反之，插入该类设备的等待队列； 设备分配后，检索设备控制器控制表，找到第一个与已分配设备相连的空闲设备控制器，如无空闲，则返回第一步查找下一个空闲设备； 设备控制器分配后，同样查找于其相连的通道，找到第一个空闲通道，如无空闲通道，则返回第二步查找下一个设备控制器。如有空闲通道，则此次设备分配成功，将相应的设备、设备控制器和通道分配给进程，并启动I/O设备传输信息。 6. 设备的回收当进程使用完对应的I/O设备后，释放所占有的设备、设备控制器及通道，系统进行回收修改对应的数据结构，以便下次分配使用。 七、SPOOLing 假脱机技术1. 概念通过共享设备来虚拟独占设备，将独占设备改造成共享设备，从而提高了设备利用率和系统的效率，该技术称为假脱机（SPOOLing）技术。是低速输入输出设备与主机交换的一种技术。 其核心思想是以联机的方式得到脱机的效果，低速设备经通道和设在主机内存的缓冲存储器与高速设备相连，该高速设备通常是辅存。为了存放从低速设备上输入的信息，在内存中形成缓冲区，在高速设备上形成输入输出井，传递时信息从低速设备传入缓冲区，再传到高速设备的输入井，再从告诉设备的输出井传到缓冲区，再传到低速设备。 2. SPOOLing系统的组成 输入输出井； 输入缓冲区和输出缓冲区； 输入进程和输出进程； 3. SPOOLing实例将一台独享打印机改造成可供多个用户共享打印是SPOOLing技术的典型应用，具体做法为： 系统对于用户的打印输出，并不真正把打印机分配给该用户进程，而是先在输出井中申请一个空闲盘块区，并将要打印的数据送入其中； 然后为用户申请并填写请求打印表，将该表挂到请求打印队列上。 若打印机空闲，输出程序从请求打印队首取表，将要打印的数据从输出井传送到内存缓冲区，再进行打印，直到打印队列为空。 4. SPOOLing技术特点 提高了I/O速度； 设备并没有分配给任何进程； 实现了虚拟设备功能； SPOOLing 除了是一种速度匹配技术外，也是一种虚拟设备技术。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"文件管理","slug":"操作系统/4-文件管理","date":"2020-02-14T14:02:45.000Z","updated":"2020-09-04T15:47:56.045Z","comments":true,"path":"2020/02/14/操作系统/4-文件管理/","link":"","permalink":"https://aaronyard.github.io/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"📃 文件管理 一、引言操作系统作为系统资源的管理者，提供的功能主要有 处理机管理 存储器管理 文件管理 设备管理 计算机中存放了各种各样的文件，一个文件有哪些属性？ 文件内部的数据应该怎样组织起来？ 文件之间又应该又应该怎么组织起来？ 从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？ 从上往下看，文件数据应该怎么存放在外存（磁盘）上？","text":"📃 文件管理 一、引言操作系统作为系统资源的管理者，提供的功能主要有 处理机管理 存储器管理 文件管理 设备管理 计算机中存放了各种各样的文件，一个文件有哪些属性？ 文件内部的数据应该怎样组织起来？ 文件之间又应该又应该怎么组织起来？ 从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？ 从上往下看，文件数据应该怎么存放在外存（磁盘）上？ 二、文件的逻辑结构1. 逻辑结构的概念所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。 而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。 类似于数据结构的“逻辑结构”和“物理结构”。 如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a, b,c,d,e…… “线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表/链表。顺序表的各个元素在逻辑 上相邻，在物理上也相邻； 而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随 机访问”，而“链表”无法实现随机访问。 可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻 辑结构、物理结构都有关） 文件的逻辑结构分为： 无结构文件 有结构文件 顺序文件 索引文件 索引顺序文件 2. 无结构文件无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。 如： Windows操作系统中的.txt 文件。 文件内部的数据其实就是一系 列字符流，没有明显的结构特 性。因此也不用探讨无结构文件的逻辑结构问题。 3. 有结构文件a. 定义有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。 如： 数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID），记录可以是定长的或可变长的 b. 逻辑结构根据有结构文件中的各 条记录在逻辑上如何组 织，可以分为三类 顺序文件 索引文件 索引顺序文件 顺序文件文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。 索引文件对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录， 但是很多应用场景中又必须使用可变长记录。如何解决这个问题？ 建立一张索引表以加快 文件检索速度。每条记录对应一个索引项。 索引顺序文件思考索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。 比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。 索引顺序文件是索引文件和顺序文件思想的 结合。 索引顺序文件中，同样会为文件建立 一张索引表，但不同的是：并不是每个记录 对应一个索引表项，而是一组记录对应一个索引表项。 为了进一步提高检索效率，可以为顺序文件建立多级索引表。 三、文件目录 1. 文件控制块 FCB目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个放在该目录下的文件。 目录文件中的一条记录就是一个 文件控制块FCB FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。 FCB实现了文件名和文件之间的映射。 2. 目录结构 单极目录结构 早期操作系统不支持多级目录，整个系统中只有一张目录表，每个文件占一个目录项目，不允许文件重名 两级目录结构 早期的多用户操作系统，采用两级目录结构，分为 主文件目录 和 用户文件目录 两级目录结构允许不同用户的文件重名，但依然缺乏灵活性，用户不能对自己的文件进行分类 多级目录结构 又称树形目录结构，不同目录下的文件可以重名 树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够有效的对文件进行管理和保护，但树形结构不便于实现文加共享。为此，提出了无环图目录结构 无环图目录结构 可以用不同的文件名指向同一个文件，甚至同一个目录 3. 索引结点—FCB的改进 除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点 目录项中只包含文件名、索引结点指针，每个目录项的长度大幅减小 由于目录项长度减小，因此磁盘中可以存放更多目录项，因此检测文件时磁盘I/O的次数减少了很多 四、文件的物理结构（文件分配方式）1. 定义 文件分配方式：即文件数据应该怎样存放在外存中 连续分配 链接分配 隐式链接 显示链接 索引分配 2. 连续分配连续分配方式要求每个文件在磁盘上占有一组连续的块。 连续分配支持顺序访问 和直接访问（即随机访问） 读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。 优点：连续分配的文件在顺序读/写时速度最快，支持顺序访问和随机访问； 缺点：物理上采用连续分配的文件不方便拓展，存储空间利用率低，会产生难以利用的磁盘碎片。 3. 链接分配链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。 隐式链接除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。 优点：很方便文件拓展，不会有碎片问题，外存利用率高。 缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量 的存储空间。 显示链接把用于链接文件各物理块的指针显 式地存放在一张表中。即 文件分配表（FAT，FileAllocationTable） 注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻 内存。 优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接 来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。 缺点：文件分配表的需要占用一定的存储空间。 4. 索引分配索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间 的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。 可见，索引分配方式可以支持随机访问。 文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可） 但是索引表需要占用一定的存储空间 若文件太大，索引表项太多，可以采取以下三种方法解决： ① 链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。 缺点：若文 件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。 ② 多层索引：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据 文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问 一个数据块只需要K+1次读磁盘操作。 缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。 ③ 混合索引：多种索引分配方式的结合。 例如，一个文件的顶级索引表中，既包含直接地址索引（直接 指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。 优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。 5. 三种文件分配方式总结对比 五、文件共享 1. 基于索引结点的共享方式—硬链接硬链接实际上就是为文件建一个别名，链接文件和原文件实际上是同一个文件。 在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode。 硬链接是不会建立 inode 的，他只是在文件原来的 inode 的 link count 域中增加 1 而已，因此硬链接是不可以跨越文件系统的。 硬链接删除的时候，系统调用会检查 inode link count 的数值，如果大于等于 1，那么 inode 就不会被回收，也即文件的内容不会被删除。 2. 基于符号链的共享方式—软链接软链接，其实就是建立一个新的文件，这个文件是专门用来指向别的文件的（和快捷方式类似）。 也就是说，软链接会产生一个新的 inode，不过这个 inode 只是指明源文件的字符串信息，一旦源文件删除了，那么软链接将变得毫无意义。 软链接可以跨越文件系统 。 由于软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此软链接访问共享文件的速度比硬链接要慢 六、文件保护 1. 口令保护 2. 加密保护 3. 访问控制 七、磁盘1. 磁盘结构磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据 磁盘结构如下： 磁道（Track）：磁盘的盘面被分为一个个磁道。 扇区（Track Sector）：一个磁道又被分成一个个扇区，每个扇区就是一个磁盘块，每个扇区中存放的数据量相同。 扇区是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 盘面（Platter）：一个盘片可能会有多个盘面。所有盘面中相对位置相同大的磁道组成柱面 磁头（Head）：与盘面的距离很近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 2. 如何在磁盘中读写数据需要把磁头移动到想要读写的扇区所在的磁道。磁道会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读写操作 3. 磁盘调度算法读写一个磁盘块的时间的影响因素有： 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 先来先服务 FCFSFirst Come First Served 按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道时间优先 SSTFShortest Seek Time First 优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 扫描/电梯算法 SCANSSTF算法会产生饥饿的原因在于：磁头有可一直在一个小区域内来回移动。为了防止这个问题，可以规定，只有磁头移动道最外层磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法，类似于电梯，电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。因此也称电梯算法 循环扫描算法 C-SCANSCAN算法对于各个位置磁道的响应频率不平均，而C-Scan算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动到起始端而不处理任何请求","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"内存管理","slug":"操作系统/3-内存管理","date":"2020-02-13T14:02:45.000Z","updated":"2020-09-04T15:48:01.035Z","comments":true,"path":"2020/02/13/操作系统/3-内存管理/","link":"","permalink":"https://aaronyard.github.io/2020/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"💽 内存管理 首先需要区分几个概念：内存、磁盘、硬盘 内存：即运行内存，比如手机运行内存4G，断电后内存中数据全部丢失 磁盘：外部存储器，比如手机存储容量64G，断电后磁盘中数据不会丢失，但读取速度远远低于内存。外存中任何数据只有调入内存中才能真正使用 硬盘：磁盘的一种 软盘：磁盘的一种 硬盘也分 固态硬盘 和 机械硬盘： 在读写速度上面，固态硬盘肯定是完胜机械硬盘。 如果把系统装在固态盘和机械盘作比较的话，开机的速度根本不是一个级别的。而且，除了开机速度之外，在游戏的加载上也有很多不同点，相信很多人都遇到开局加载速度奇慢无比的人，这就是硬盘所决定的。","text":"💽 内存管理 首先需要区分几个概念：内存、磁盘、硬盘 内存：即运行内存，比如手机运行内存4G，断电后内存中数据全部丢失 磁盘：外部存储器，比如手机存储容量64G，断电后磁盘中数据不会丢失，但读取速度远远低于内存。外存中任何数据只有调入内存中才能真正使用 硬盘：磁盘的一种 软盘：磁盘的一种 硬盘也分 固态硬盘 和 机械硬盘： 在读写速度上面，固态硬盘肯定是完胜机械硬盘。 如果把系统装在固态盘和机械盘作比较的话，开机的速度根本不是一个级别的。而且，除了开机速度之外，在游戏的加载上也有很多不同点，相信很多人都遇到开局加载速度奇慢无比的人，这就是硬盘所决定的。 一、什么是内存，有何作用内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾 思考：在多道程序环境下，系统中会有多个程序并发执行，也就 是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？ 方案：给内存的存储单元编地址 二、什么是内存管理操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？主要包括以下四个方面： 内存空间的分配与回收 内存空间的扩充 地址转换 存储保护 1. 内存空间的分配与回收（传统存储管理） 传统的存储管理方式有以下两种： a. 连续分配管理方式连续分配：指为用户进程分配的必须是一个连续的内存空间。 单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。 系统区通常位于内存的低地址部分，用于存放操作系统 相关数据； 用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户程序独占整个用户区 空间。 优点：实现简单；无外部碎片；可以采用覆盖技术扩充 内存； 缺点：只能用于单用户、单任务的操作系统中；有 内部碎片（分配给某进程的内存区域 中，如果有些部分没有用上，就是“内部碎片”）；存储器利用率极低。 固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰， 于是将整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。 优点：实现简单，无外部碎片。 缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。 动态分区分配动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。 系统要用什么样的数据结构记录内存的使用情况？ b. 非连续分配管理方式非连续分配：为用户进程分配的可以是一些分散的内存空间。 包括以下三种管理方式：（详细见下文 非连续分配的三种存储管理方式详解） 基本分页存储管理把主存分为大小相等且固定的一页一页的形式，页较小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。页与页之间不连续，但页的内部连续。 基本分段存储管理页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。段与段之间不连续，但段的内部连续。 段页式存储管理段页式管理机制结合了段式管理和页式管理的优点。 简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页. 也就是说 段页式管理机制 中段与段之间以及段的内部的都是不连续的。 2. 内存空间的扩充在传统存储管理方式 的基础上引入了交换 技术、覆盖技术，使得内存利用率有所提 升， 并且能从逻辑上扩充内存容量。 对内存空间的扩充主要有三种方法： a. 覆盖技术将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。 必须由程序员声明覆盖结构，操作系统完成自动覆盖。 缺点：对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。 b. 交换技术内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进 程在内存与磁盘间动态调度） 在上一章学过进程调度（低级调度），中级调度（内存调度）就是使用的交换技术，就是要决定将哪个 处于挂起状态的进程重新调入内存。 c. 虚拟存储技术（虚拟内存）详细见下文 3. 地址转换/重定位操作系统需要提供地址转换功能，负责程序的 逻辑地址 与 物理地址 的转换 为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 将逻辑地址空间重定位到物理地址空间的时机有三种： 程序编译链接时 程序装入内存时 程序执行时 ① 静态重定位静态重定位是在程序执行之前（编译链接时）进行重定位。对每个程序来说，静态重定位是在装入内存时一次性完成的，在程序运行期间不再进行重定位 优点： 无须硬件支持 缺点： 一是程序重定位之后就不能在内存中搬动了； 二是要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域内。 ② 动态重定位动态重定位是在程序执行过程中进行地址重定位，更确切地说，是在CPU每次访问内存单元前才进行地址变换。动态重定位一般需要硬件支持。 优点： 目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的； 一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。 缺点： 需要硬件支持 4. 存储保护操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰 三、非连续分配—基本分页存储管理1. 逻辑地址（相对地址） 物理地址（绝对地址） 比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。 2. 什么是分页存储？将内存空间分为一个个大小相等的分区（比如：每个分区 4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理 块=物理页面）。每个页框有一个编号，即“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），页框号 从 0 开 始 。 将进程的逻辑地址空间也分为 与页框大小相等 的一个个部分， 每个部分称为一个“页”或“页面” 。每个页面也有一个编号， 即“页号”，页号也是从0开始。 操作系统以页框为单位为各个进程分配内存空间。进程的每个 页面分别放入一个页框中。也就是说，进程的页面与内存的页 框有一一对应的关系。 各个页面不必连续存放，可以放到不相邻的各个页框中。 3. 重要的数据结构——页表为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 注：页表通常存在PCB（进程控制块）中 4. 页表管理中重要的两个问题 问题1：逻辑地址到物理地址的转换要快。（快表解决） 问题2：解决逻辑地址空间大，页表也会很大的问题。（多级页表） 4. 快表TLB-解决问题1为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表TLB 来加速虚拟地址到物理地址的转换。 快表，又称联想寄存器（TLB，translation lookaside buffer ），是一种访问速度比内存快很多的 高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。 与此对应，内存中的页表常称为慢表。 若快表命中，就不需要再访问内存了，若快表中没有目标页表项，则需要查询内存中的页表 由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。 使用快表之后的地址转换流程是这样的： 根据逻辑地址中的页号查快表； 如果该页在快表中，直接从快表中读取相应的物理地址； 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中； 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。 5. 两级页表-解决问题2单级页表存在的问题： 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。（多级页表解决） 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。（可以在需要访问页面时才把页面调入内存（虚拟存储技术）；也可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存） 把页表再分页并离散存储，然后再建立一张页表记录页表各个部分 的存放位置，称为页目录表，或称外层页表，或称顶层页表。若分为两级页表后，页表依然很长，则可以采用更多级页表 四、非连续分配—基本分段存储管理与“分页”最大的区别就 是——离散分配时所分配 地址空间的基本单位不同 1. 什么是分段进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言 中，程序员使用段名来编程），每段从0开始编址 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。 分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度 2. 段表程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。 每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称 “基址”）和段的长度。 各个段表项的长度是相同的 3. 分段、分页管理的对比 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率；实现虚拟内存，从而获得更大的地址空间。 分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。 一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。 段的长度不固定，决定于用户编写的程序。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临 界资源），这样的代码是可以共享的。可修改的代码是不能共享的 访问一个逻辑地址需要几次访存？ 分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存 分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存 与分页系统类似，分段系统中也可以引入 快 表 机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。 五、虚拟内存1. 传统存储管理方式的特征、缺点 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题： ①作业很大时，不能全部装入内存，导致大作业无法运行； ②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段 内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的 数据，浪费了宝贵的内存资源。 2. 局部性原理 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环） 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的） 3. 虚拟内存的定义基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行。 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续 执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。（操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。） 4. 虚拟内存的主要特征虚拟内存有一下三个主要特征： 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。 5. 如何实现虚拟内存技术虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。 因此， 虚拟内存的实现需要建立在离散分配（非连续分配）的内存管理方式基础上。 a. 请求分页存储管理请求分页存储管理 与 基本分页存储管理 的主要区别： 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然 后继续执行程序。（操作系统要提供 请求调页功能， 将缺失页面从外 存调入内存 ） 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 （操作系统要提供页面置换（详细见下文 六、请求分页存储-页面置换算法）的功能， 将暂时用不到的页面换出外存） 页表机制 缺页中断机构在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然 后由操作系统的缺页中断处理程序处理中断。 此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。 如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址 A 中的数据复制到逻辑地址 B，而 A、B 属于不同的页面，则有可能产生两次中断） 地址变换机构 首先检查页面是否在内存中； 若页面不在内存中，请求调页（查到页表项时进行判断） 若内存空间不足，页面置换（需要调入页面，但没有空闲内存块时进行） 页面调入内存，需要修改请求页表中新增的表项 b. 请求分段存储管理建立在分段存储管理之上，增加了请求调段功能、分段置换功能。 请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行； 在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段； 当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 c. 请求段页式存储管理六、请求分页存储—页面置换算法1. 最佳置换算法 OPTOptimal replacement algorithm 所选择的被换出的页面将是最长时间内不再被访问的，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 17，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 先进先出置换算法 FIFO选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 3. 最近最久未使用置换算法 LRULeast Recently Used 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。 LRU 将最近最久未使用的页面换出。 举例：一个系统为某进程分配了四个物理块，并有如下页面引用序列： 11, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7 4. 时钟置换算法 Clock / 最近未用算法 NRU 为每个页面设置一个访问位，当被访问时，访问位置为1。 当发生缺页中断时，NRU 算法只需检查页的访问位，如果是0（未被访问），就将该页换出； 如果是1，就将其置为0，暂不换出，继续检查下一个页面","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"进程、线程、死锁","slug":"操作系统/2-进程、线程、死锁","date":"2020-02-12T14:02:45.000Z","updated":"2020-09-04T15:48:03.954Z","comments":true,"path":"2020/02/12/操作系统/2-进程、线程、死锁/","link":"","permalink":"https://aaronyard.github.io/2020/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E6%AD%BB%E9%94%81/","excerpt":"🎉 进程、线程、死锁 一、进程的概念、组成、特征1. 概念进程（Process）：是动态的，是程序的一次执行过程。进程是资源分配的基本单位。 2. 进程的组成 PCB是给操作系统用的。 程序段、数据段是给进程自己用的","text":"🎉 进程、线程、死锁 一、进程的概念、组成、特征1. 概念进程（Process）：是动态的，是程序的一次执行过程。进程是资源分配的基本单位。 2. 进程的组成 PCB是给操作系统用的。 程序段、数据段是给进程自己用的 ① 进程控制块 PCB 当进程被创建时，操作系统会为该进程 分配一个唯一的、不重复的“身份证号”——PID（ProcessID，进程ID） 操作系统要记录PID、进程所属用户ID（UID）（基本的进程描述信息，可以 让操作系统区分各个进程） 还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件） 还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等） 这些信息都被保存在一个数据结构PCB（ProcessControlBlock）中，即 进程控制块 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中 PCB 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其PCB ② 程序段程序的代码（指令序列） 比如： 同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相 同，但程序段的内容都是相同的 （都是运行着相同的QQ程序） ③ 数据段运行过程中产生的各种数据（如：程序中定义的变量） 3. 进程的特征程序是静态的，进程是动态的，相比于程序，进程拥有以下特征： 动态性 ：进程是程序的一次执行过程，是动态的产生，变化和消亡的 动态性是进程最基本的特征 并发性：内存中有多个进程实体，各进程可以并发执行 独立性：进程是能独立运行，独立获得资源，独立接收调度的基本单位 异步性：各进程按照各自独立的，不可预知的速度向前推进。 异步性会导致并发程序 执行结果的不确定性。操作系统要提供进程同步机制来解决异步问题 结构性：每个进程配置一个唯一PCB 二、进程的状态1. 三态模型 运行(running)态：进程占有处理器正在运行。 就绪(ready)态：进程具备运行条件，等待系统分配处理器以便运行。 阻塞态/等待(wait)态：指进程不具备运行条件，正在等待某个事件的完成。 2. 五态模型进程的五种状态： 创建状态(new) ：进程正在被创建，尚未到就绪状态。 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。 运行状态(running) ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。 阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。 结束状态(terminated)：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 三、进程控制（实现进程状态转换）1. 概念进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现 进程状态转换等功能。 简化理解：进程控制就是要实现进程状态转换 2. 如何实现进程控制用 “原语”实现。原语是一种特殊的程序， 它的执行具有原子性。 也就是说，这段程序的 运行必须一气呵成，不可中断 思考：为何进程控制（状态转 换）的过程要“一气呵成”？ 答：如果不能“一气呵成”，就有可能导致操作系 统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作 3. 进程控制相关的原语① 进程的创建 ② 进程的终止 ③ 进程的阻塞和唤醒 ④ 进程的切换 四、进程通信 IPC1. 概念顾名思义，进程通信（ IPC——InterProcess Communication）就是指进程之间的信息交换 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。 为了保证安全，一个进程不能直接访问另一个进程的地址空间。 但是进程之间的信息交换又是必须实现的。 为了保证进程间的安全通信，操作系统提供了一些进程之间通信的方法。 共享存储 消息传递 管道通信 进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 2. 进程通信的方法① 共享存储 (share memory)允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种通信方式 两个进程对共享空间的访问必须是互斥的（这种方式需要依靠某种同步操作，如互斥锁和信号量等）。 ② 管道 / 匿名管道 (Pipes)“管道”是指用于连接读写进程的一个共享文件，又名 pipe 文件。其实就是在内存中开辟 一个大小固定的缓冲区 管道是通过调用 pipe 函数 创建的，fd[0] 用于读，fd[1] 用于写。 1int pipe(int fd[2]); 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置 两个管道。 各进程要互斥地访问管道。 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。 如果没写满，就不允许读。如果没读空，就不允许写。 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情 况。 只能在父子进程或者兄弟进程中使用。 ③ 有名管道 / FIFO (Names Pipes)匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。 有名管道严格遵循 先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信，去除了管道只能在父子进程中使用的限制。 FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 ④ 消息队列 (Message Queuing) 消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。 消息队列允许一个或多个进程向它写入与读取消息. 管道和消息队列的通信数据都是先进先出的原则。 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。比FIFO更有优势。 消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 ⑤ 信号量 semaphore信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 详见 下文 八、信号量机制 Semaphore ⑥ 信号 signalAttention: 信号和信号量是完全不同的两个概念！ 信号：是一种处理异步事件的方式。是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。 信号量：信号量是一个特殊的变量，它的本质是计数器，信号量里面记录了临界资源的数目，有多少数目，信号量的值就为多少，进程对其访问都是原子操作（pv操作，p：占用资源，v：释放资源）。它的作用就是，调协进程对共享资源的访问，让一个临界区同一时间只有一个进程在访问它。 ⑦ 套接字(Sockets)此方法主要用于在客户端和服务器之间通过网络进行通信。 套接字是支持TCP/IP的网络通信的基本操作单元，是应用层和传输层之间的桥梁，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以它可用于不同机器间的进程通信。 五、线程的概念和特征1. 什么是线程线程是独立调度的基本单位。 进程 是资源分配的基本单位 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 2. 为什么要引入线程进程 是资源分配的基本单位，由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。 类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 3. 线程的特征和优点 进程间并发，开销很大。线程间并发，开销更小 引入线程机制后，并发带来的系统开销降低，系统 并发性提升注意：从属于不同进程的 线程间切换，也会导致进程的切换！开销也大！ 从属同一进程的各个线程共享进程拥有的资源。 进程间通信必须请求操作系 统服务（CPU要切换到核心 态），开销大。 同进程下的线程间通信，无 需操作系统干预，开销更小注意：从属于不同进程的线 程间通信，也必须请求操作系统服务！ 引入线程前，进程既是资源 分配的基本单位，也是调度 的基本单位。 引入线程后，进程是资源分配的基本单位，线程是资源调度的基本单位。线程也有运行 态、就绪态、阻塞态 在多CPU环境下，各个线程也可以分派到不同的CPU上并行地执行。 4. 进程和线程的区别 Ⅰ 拥有资源进程是资源分配的基本单位，线程不拥有资源(只拥有很少的资源)，但是线程可以访问隶属进程的资源。 Ⅱ 调度线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 六、处理机调度1. 调度的概念当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理 这些任务的顺序，这就是“调度”研究的问题。 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。 处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程 的并发执行。 2. 调度的三个层次 高级调度（作业调度） 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。 中级调度（内存调度） 就是要决定将哪个处于挂起状态的进程重新调入内存。 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。 暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 低级调度（进程调度） 其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理 机分配给它。 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次 七、进程调度算法1. 先到先服务 FCFS 非抢占式First Come First Serve 先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。 优点：公平、算法实现简单 缺点：排在长作业（进程）后面的短作业需要等待很长时 间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利 2. 短作业优先 SJF 非抢占式Shortest Job First 短作业/进程优先调度算法：每次调度时选择当前 已到达 且 运行时间最短 的作业/进程。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 3. 最短剩余时间优先 SRTN 抢占式shortest remaining time next 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 4. 高响应比优先 HRRN 非抢占式Highest Response Ratio Next 高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的 进程上处理机。 响应比 = (等待时间+要求服务时间) / 要求服务时间 八、信号量机制 Semaphore1. 概念1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制 用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互 斥、进程同步。 信号量其实就是一个变量 ，可以用一个信号量 来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。 一对原语： P操作 wait(Semaphore)：等待一个信号量：该操作会测试这个信号量的值，如果小于等于0，就阻塞。如果大于0，就占用一个资源，信号量 - 1。 V操作 signal(Semaphore)：挂出一个信号量：该操作将信号量的值加1，即使用完资源后归还资源。 123456789101112int S = 1; // 初始化信号量，表示当前系统中可用打印机的数量// 请求占用资源void wait(int S)&#123; while(S&lt;=0); //如果可用资源不够，则一直等待 S = S - 1; //如果有可用资源，则占用一个资源&#125;// 归还资源void signal(ing S)&#123; S =S + 1 ; //使用完资源后，归还资源&#125; 2. 信号量实现进程互斥首先我们需要了解一个概念：临界资源 多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用。一次仅允许一个进程使用的资源称为临界资源。 许多物理设备都属于临界资源，如输入机、打印机、磁带机等。 对临界资源进行访问的那段代码称为临界区。 信号量实现进程互斥的步骤： 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区） 设置互斥信号量 mutex，初值为1 （即代表进入临界区的名额，可用资源数） 在进入区P(mutex)——申请资源 在退出区V(mutex)——释放资源 1234567891011121314151617semaphore mutex = 1; // 初始化互斥信号量// 进程P1P1()&#123; ... P(mutex); //申请资源 临界区代码... V(mutex); //用完后释放资源&#125;// 进程P2P2()&#123; ... P(mutex); //申请资源 临界区代码... V(mutex); //用完后释放资源&#125; P、V操作必须成对出现。缺少 P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。 3. 信号量实现进程同步（一前一后）进程同步：要让各并发进程按要求有序地推进。 比如，P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。 1234567891011P1()&#123; 代码1; 代码2; 代码3;&#125;P2()&#123; 代码4; 代码5; 代码6;&#125; 若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我 们就必须保证“代码4”一定是在“代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。 信号量实现进程同步的步骤： 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码） 设置同步信号量S,初始为0 在“优先级较高操作”之后执行V(S) 释放资源 在“优先级较低操作”之前执行P(S）申请资源 123456789101112131415semaphore S = 0; //表示当前可用资源为0，需要等待P1释放资源P1()&#123; 代码1; 代码2; V(S); //代码2运行完后，释放资源 代码3;&#125;P2()&#123; V(S); //代码4运行前先请求资源，保证代码4一定是在代码2之后执行 代码4; 代码5; 代码6;&#125; 九、经典同步互斥问题1. 生产者-消费者问题 系统中有一组生产者进程和一组消费者进程， 生产者进程每次生产一个产品放入缓冲区，消费者 进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据） 生产者、消费者共享一个初始为空、大小为n的缓冲区。 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 (同步关系) 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 (同步关系) 缓冲区是临界资源，各进程必须互斥地访问。（互斥关系） 1234567891011121314151617181920212223semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问semaphore empty = n; //同步信号量，表示生产者还能生产多少，即还能放入多少产品，该数量小于等于0，则生产者不能进行生产semaphore full = 0; //同步信号量，表示消费者还能取出多少，即当前缓冲区已有产品的数量，该数量小于等于0，则消费者不能进行读取producer()&#123; while(1)&#123; p(empty); //申请一个生产者可用数量，若该信号量小于等于0，则阻塞，不进行生产 p(mutex); //互斥使用缓冲区 把产品放入缓冲区 v(mutex); //释放缓冲区占用 v(full); // 增加一个消费者可用数量 &#125;&#125;consumer()&#123; while(1)&#123; p(full); //申请一个消费者可用数量，若该信号量小于等于0，则阻塞，不进行消费 p(mutex); //互斥使用缓冲区 从缓冲区中取出一个产品 v(mutex); //释放缓冲区占用 v(empty); // 增加一个缓冲区/生产者可用数量 &#125;&#125; 2. 多生产者-多消费者问题桌子上有一只盘子，每次只能向其中放入一个水果。 爸爸专向盘子中放苹果，妈妈专向盘子中放 橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。 只有盘子空时，爸爸或妈妈才 可向盘子中放一个水果。 仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果 互斥关系： 对缓冲区（盘子）的访问要互斥地进行 同步关系（一前一后）： 父亲将苹果放入盘子后，女儿才能取苹果 母亲将橘子放入盘子后，儿子才能取橘子 只有盘子为空时，父亲或母亲才能放入水果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748semaphore mutex = 1; //实现互斥访问盘子（缓冲区） semaphore apple = 0; //盘子中有几个苹果 semaphore orange = 0; //盘子中有几个橘子 semaphore plate = 1; //盘子中还可以放多少个水果dad ()&#123; while(1)&#123; 准备一个苹果; P(plate); P(mutex); 把苹果放入盘子; V(mutex); V(apple); &#125; &#125;mom ()&#123; while(1)&#123; 准备一个橘子; P(plate); P(mutex); 把橘子放入盘子; V(mutex); V(orange); &#125;&#125;daughter ()&#123; while(1)&#123; P(apple); P(mutex); 从盘中取出苹果; V(mutex); V(plate); 吃掉苹果; &#125; &#125;son ()&#123; while(1)&#123; P(orange); P(mutex); 从盘中取出橘子; V(mutex); V(plate); 吃掉橘子; &#125; &#125; 3. 哲学家进餐问题4. 读者-写者问题十、管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 Java中类似于管程的机制 synchronized 十一、进程同步的方法总结一下进程同步的方法： 临界区 信号量 管程 进程的同步离不开死锁问题，下面来详细解释一下死锁的相关概念 十二、死锁1. 什么是死锁死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 2. 死锁产生的必要条件 互斥 只有对必须互斥使用的资源的争抢才会导致死锁。 请求和保持 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进 程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。 不可抢占/不剥夺 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 循环等待 存在一种进程资源的循环等待环路，该环路中的每个进程都在等待下一个进程所占有的资源。 3. 死锁的处理策略死锁的产生必须满足四 个必要条件，只要其中一个或者几 个条件不满足，死锁就不会发生。 3.1 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 3.2 死锁预防 破坏互斥条件如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。 比如: SPOOLing 技术。 操作系统可以采用SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打 印机改造为共享设备… 该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方 还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件 破坏不可抢占条件 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时 再重新申请。 也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。 这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥 夺给优先级更高的进程使用） 该策略的缺点： 实现起来比较复杂。 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态 的资源，如CPU。 反复地申请和释放资源会增加系统开销，降低系统吞吐量。 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程饥饿 破坏请求和保持条件可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源 了。 该策略实现起来简单，但也有明显的缺点： 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造 成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。 破坏循环等待条件可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源， 同类资源（即编号相同的资源）一次申请完。 原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持 有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。 该策略的缺点： 不方便增加新的设备，因为可能 需要重新分配所有的编号； 进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源 浪费； 必须按规定次序申请资源，用户 编程麻烦。 3.3 死锁避免安全序列所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能够完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。 💭 举例如下： 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 银行家算法核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这个请求，让该进程先阻塞等待。 💭 举例： 系统中有5个进程P0-P4，3种资源R0-R2，初始数量为（10，5，7），某一时刻的情况如下所示： 此时总共已分配 (7,2,5)，还剩余 (3,3,2) 3.4 死锁检测和解除如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种 情况下，系统应当提供两个算法： ① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。 ② 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。 死锁检测为了能对系统是否已发生了死锁进行检测，必须： ①用某种数据结构来保存资源的请求和分配信息； ②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。 🚩 检测死锁的算法： 1）在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有 向边对应资源的申请数量小于等于系统中已有空闲资源数量。 如下图中，R1没有空闲资源，R2有 一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中， P1是满足这一条件的进程结点，于是将P1的所有边消去。 2）进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在上图中，P2就满足这样的条件。根据1）中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。 死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁 死锁解除一旦检测出死锁的发生，就应该立即解除死锁。 并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 解除死锁的主要方法有： 资源剥夺法 挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给 其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。 撤销进程法（或称终止进程法）。 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资 源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。 进程回退法 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程 的历史信息，设置还原点。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统概述","slug":"操作系统/1-操作系统概述","date":"2020-02-11T14:02:45.000Z","updated":"2020-09-04T15:47:45.392Z","comments":true,"path":"2020/02/11/操作系统/1-操作系统概述/","link":"","permalink":"https://aaronyard.github.io/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"⛵ 操作系统概述 一、操作系统的概念和功能1. 什么是操作系统 操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。","text":"⛵ 操作系统概述 一、操作系统的概念和功能1. 什么是操作系统 操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 操作系统为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 2. 操作系统的功能和目标 对系统资源的管理 向上层提供接口 给普通用户使用的：GUI图形界面 / 命令接口 给软件/程序员用的：程序接口——系统调用 对下层功能的扩展 没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器 类比汽车： 发动机——只会转；轮胎——只会滚； 在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展 操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件 能够相互协调配合，实现更多更复杂的功能 普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可 二、操作系统的四个特征1. 并发（最基本特征） 并发：并发是指宏观上在一段时间内能同时运行多个程序。这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行 ； 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。 比如Intel的第八代i3处理器就是4核CPU，意味着可以并行地执行4个程序 即使是对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此 并发性 是操作系统一个基本的特性 并行：并行则指同一时刻能运行多个指令，指两个或多个事件在同一时刻同时发生。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 2. 共享（最基本特征）共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 两种共享方式 互斥共享 互斥共享的资源称为临界资源，例如打印机等，虽然可以提供给多个进程使用，但在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。 同时共享系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问 所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享） 实例： 互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的 💖 并发和共享互为存在条件并发性指计算机系统中同时存在着多个运行着的程序。 共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。 通过下述例子来看并发与共享的关系： 使用QQ发送文件A，同时使用微信发送文件B。 两个进程正在并发执行（并发性） 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 需要共享地访问硬盘资源（共享性） 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发 送文件，也就无法并发 同时，没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个基本的特征 3. 虚拟虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。 用一个例子来理解: 我们都知道 一个程序需要放入内存并给它分配CPU才能执行 GTA5需要4GB的运行内存，QQ需要256MB的内存，Chrome需要256MB的内 存，网易云音乐需要256MB的内存…… 电脑：4GB内存 处理器：单核CPU 问题1：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以 在我的电脑上同时运行呢？ 答：这是虚拟存储器技术 (空分复用技术)。实际只有4GB的内存，在用户看来似乎远远大 于4GB 问题2：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术（时分复用技术），微观上处理机在 各个微小的时间段内交替 着为各个进程服务。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务 下面来解释一下上述两种虚拟技术： 时分复用技术 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。 空分复用技术 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性 4. 异步异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性 三、中断和异常1. 用户态和内核态根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别： 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode):可以简单的理解内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。 2. 中断的作用CPU上会运行两种程序，一种是 操作系统内核程序 (是整个系统的管理者)，一种是 应用程序 在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。“中断”是让操作系统内核夺回CPU使用权的唯一途径 如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。没有中断机制，就不可能实现操作系统，不可能实现程序并发 内核态-&gt;用户态：执行一条特权指令 —— 修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权 总结：“中断”会使CPU由用户态 变为 内核态 ，使操作系统重新夺回对CPU的控制权 3. 中断的类型 内中断（也称 异常、例外） 与当前执行的指令有关， 中断信号来源于CPU内部。如非法操作码、地址越界、算术溢出，除数为0等 有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号 执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “系统调用”就是通过陷入指令完成的 外中断 （也称 中断，狭义的中断） 与当前执行的指令无关， 中断信号来源于CPU外部。如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 4. 中断机制的基本原理不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。 四、系统调用1. 什么是系统调用，有何作用操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。 “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 2. 系统调用与库函数的区别有的库函数涉及系统调用，有的不涉及 不涉及系统调用的库函数：如“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数 3. 为什么系统调用是必须的 实例：去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开 始工作。 你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。 思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？ 两个进程并发运行，打印机设备交替地收到WPS和Word 两个进程发来的打印请 求，结果两篇论文的内容混杂在一起了… 解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。 4. 什么功能要用到系统调用应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管。 因此凡是 与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 这些系统调用按功能大致可分为如下几类： 设备管理。完成设备的请求或释放，以及设备启动等功能。 文件管理。完成文件的读、写、创建及删除等功能。 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 进程通信。完成进程之间的消息传递或信号传递等功能。 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 5. 系统调用的过程传递系统调用参数 ——&gt; 执行陷入指令（用户态），引发一个内中断，使CPU进入内核态 ——&gt; 执行相应的请求，内核程序处理系统调用（内核态）——&gt; 返回应用程序 五、操作系统的体系结构操作系统的体系结构可以分为 大内核 + 微内核 内核是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序。 1. 大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 2. 微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 因为需要频繁地在用户态和内核态之间进行切换，所以会有一定的性能损失。 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁地在用户态和内核态之间进行切换，性能低","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://aaronyard.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++面试指南","slug":"Cpp/面试指南","date":"2020-01-30T14:02:45.000Z","updated":"2020-09-04T15:07:47.432Z","comments":true,"path":"2020/01/30/Cpp/面试指南/","link":"","permalink":"https://aaronyard.github.io/2020/01/30/Cpp/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"🚨 本文仅为准备 考研初复试 使用，只包含 C++ 的基础语法，比如继承、多态、重载、模板等，并不包含 STL、异常等内容，但具备完整的知识体系，并不是由网上的面试题随意拼凑而来。","text":"🚨 本文仅为准备 考研初复试 使用，只包含 C++ 的基础语法，比如继承、多态、重载、模板等，并不包含 STL、异常等内容，但具备完整的知识体系，并不是由网上的面试题随意拼凑而来。 一、基本概念1. 简述你对“面向过程”和“面向对象”编程思想的认识与思考面向过程：面向过程的设计思路是自顶向下的，按功能划分称若干个基本模块，形成一个树状结构，各个模块的功能上相对独立。 面向过程的优点主要是： 有效的将一个复杂的程序分解成多个小的、容易处理的子任务，便于维护和开发。 缺点主要是 可重用性差、数据安全性差； 当数据结构改变的时候，所有相关的处理过程都要进行相应的修改； 难以开发图形化界面；把数据和操作数据的过程分离开来。 面向对象：将数据和对数据的操作方法封装在一起，作为一个不可分割的整体——对象。对同类型的对象抽象出它们的共性，形成类。类通过外部接口public，与外部进行交互。 面向的对象的四大特性：抽象、封装、继承、多态。 面向对象的优点主要是： 各个模块之间的关系更见简单，模块之间的独立性、安全性都大大提高； 通过继承和多态，大大提高了程序的可重用性，便于开发和维护 2. 面向对象程序“接口和实现方法分离”有啥优点接口定义了交互的标准。接口的实现细节对用户是隐藏的。 接口和是实现方法分离使得程序更容易修改，只要接口保持不变，接口实现的改变不会影响用户。提高了代码的可维护性，使得代码变得清晰。 3. 简述你对C++中数据类型和ADT的理解数据类型是一组性质相同的具有一定范围的值和集合以及定义在这个集合上的一组操作。C++中既有内部类型：int、char、bool、float、double，又有外部数据类型：枚举类型enum、结构类型struct、联合类型union、数组类型int[]、类类型class。 ADT 即抽象数据类型，是基于已有类型而组成的复合数据类型，类就是抽象数据类型的描述形式。 4 什么是逻辑错误，什么是语法错误语法错误：是对语言规则的违背，当编译器不能正确识别语句的时候，就会导致语法错误（比如句子末尾少个分号），他们都是在编译期间就被检查出来的错误，所以也叫编译错误。逻辑错误：指代码逻辑上的错误，编译能通过，程序可以完成运行，但是不会产生正确的结果（比如死循环） 5. 控制语句有哪几种，请画出他们的流程图三种控制语句： 顺序 循环 选择 6. 什么是else摇摆问题123456if(a&gt;0)&#123; if(b&gt;0) //do somethingelse //do something&#125; 这里的else匹配第二个if 而非第一个 即else匹配最近一个未和else匹配的if 7. enum 枚举类型Enum Week{Mon,Tue,Wed,Thu,Fri,Sat,Sun); 对应0，1，2，3，4，5，6； 枚举是对整数区间的自定义类型，一旦定义则不能改变，常用于代替整数常量，使得代码更加清晰。 8. assert 断言assert 断言，是宏，而非函数。 assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;assert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前。 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); 9. sizeof 基本数据类型 1sizeof(int) = 4 结构体 struct 字节对齐：让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。 1234567891011struct S1 &#123; char a; //sizeof(char) = 1 int b; //sizeof(int) = 4&#125;; sizeof(S1); //值为8，4字节对齐，在char之后会填充3个字节。 struct S3 &#123; &#125;; sizeof(S3); //值为1，空结构体也占内存 联合体 union 结构体在内存组织上是顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的sizeof也就是每个成员sizeof的最大值。 123456789union u &#123; int a; // sizeof(int) = 4 float b; // sizeof(float) = 4 double c; // sizeof(double) = 8 char d; // sizeof(char) = 1&#125;; sizeof(u); //值为8 指针 一个指针的 sizeof 必定是 4 12char *b = \"helloword\";int c = sizeof(b); // c = 4 数组 数组的sizeof值等于数组所占用的内存字节数。 注意： 当字符数组表示字符串时，其sizeof值将 ’/0’ 计算进去。 当数组为形参时，其 sizeof 值相当于指针的sizeof值（4）。 123456789101112131415char a[10]; char n[] = \"abc\"; cout&lt;&lt;sizeof(a)&lt;&lt;endl;//数组的大小为10，值为10 cout&lt;&lt;sizeof(n)&lt;&lt;endl;//字符串数组，将'/0'计算进去，值为4void func(char a[3]) &#123; int c = sizeof(a); //c = 4，因为这里a不在是数组类型，而是指针，相当于char *a。 &#125; void funcN(char b[]) &#123; int cN = sizeof(b); //cN = 4，理由同上。 &#125; 函数 sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。 对函数求值的形式：sizeof(函数名(实参表)) 注意： 不可以对返回值类型为空的函数求值 不可以对函数名求值 对有参数的函数，在用sizeof时，须写上实参表 1234567891011121314151617float FuncP(int a, float b)&#123; return a + b; &#125; int FuncNP()&#123; return 3; &#125; void Func()&#123; &#125; int main()&#123; cout&lt;&lt;sizeof(FuncP(3, 0.4))&lt;&lt;endl; //OK，值为4，相当于sizeof(float) cout&lt;&lt;sizeof(FuncNP())&lt;&lt;endl; //OK，值为4，相当于sizeof(int) /*cout&lt;&lt;sizeof(Func())&lt;&lt;endl; //error，sizeof不能对返回值为空类型的函数求值*/ /*cout&lt;&lt;sizeof(FuncNP)&lt;&lt;endl; //error，sizeof不能对函数名求值*/ &#125; 10. 类型转换 隐式类型转换：赋值运算要求左值与右值的类型相同，若类型不同，编译系统会自动将右值转换为左值的类型。 显示/强制类型转换：比如 123int a = 1;float x = 10.0;x = (float) a + 1; 二、函数1. using① using 声明 一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; ② 构造函数的 using 声明 在 C++11 中，派生类能够重用其直接基类定义的构造函数。 12345class Derived : Base &#123;public: using Base::Base; /* ... */&#125;; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1Derived(parms) : Base(args) &#123; &#125; ③ using 指示 using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; ④ 尽量少使用 using 指示 污染命名空间 🚥 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 尽量少使用 using 指示 1using namespace std; 应该多使用 using 声明 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; 或者 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; 2. inline 内联函数① 特征 相当于把内联函数里面的内容写在调用内联函数处； 编译时在调用处用函数进行替换，节省了参数传递、控制转移等开销。相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 ② 使用123456789101112131415161718192021// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) &#123; /****/&#125;;// 类内定义，隐式内联class A &#123; int doA() &#123; return 0; &#125; // 隐式内联&#125;// 类外定义，需要显式内联class A &#123; int doA();&#125;inline int A::doA() &#123; return 0; &#125; // 需要显式内联 ③ 编译器对内联函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处；即直接把函数体嵌入到代码中，而没有函数调用的出入栈的过程 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 比如： 123456inline int Max(int a, int b)&#123; if(a&gt;b) return a; return b;&#125;K = Max(n1,n2); 等价于 12345if(n1 &gt; n2) tmp = n1;else tmp = n2;K = tmp; ④ 内联函数的优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收、结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 nline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 ⑤ 虚函数可以是内联函数吗 内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译期由编译器决定是否内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 内联虚函数 示例代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base&#123;public: inline virtual void who() &#123; cout &lt;&lt; \"I am Base\\n\"; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123;public: inline void who() // 不写inline时隐式内联 &#123; cout &lt;&lt; \"I am Derived\\n\"; &#125;&#125;;int main()&#123; // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-&gt;who(); // 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(\"pause\"); return 0;&#125; 3. 结构体 struct 和 typedef structC 中 1234// ctypedef struct Student &#123; int age; &#125; S; 等价于 123456// cstruct Student &#123; int age; &#125;;typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 C++ 中 由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 123456// cppstruct Student &#123; int age; &#125;;void f( Student me ); // 正确，\"struct\" 关键字可省略 若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 12345678910111213typedef struct Student &#123; int age; &#125; S;void Student() &#123;&#125; // 正确，定义后 \"Student\" 只代表此函数//void S() &#123;&#125; // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名int main() &#123; Student(); struct Student me; // 或者 \"S me\"; return 0;&#125; 4. C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 5. union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。 1234567union Mark&#123; char grade; bool pass; int percent;&#125;;sizof(Mark) = 4; 联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest &#123; UnionTest() : i(10) &#123;&#125;; int i; double d;&#125;;static union &#123; int i; double d;&#125;;int main() &#123; UnionTest u; union &#123; int i; double d; &#125;; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;&#125; 三、数据的共享和保护1. C++ 中的作用域 函数原型作用域：在函数原型声明时形参的作用范围就是函数原型作用域。即只在形参的小括号内有用，出了小括号就死亡 局部作用域/块作用域：函数形参列表中形参的作用域。从形参的声明处开始，到整个函数体结束为止；函数体内声明的变量，其作用域从声明处开始，到整个函数体结束为止 类作用域 全局作用域/文件作用域：在任何函数外部声明的标识符的作用范围都是文件作用域，从声明标识符开始，到文件末尾结束，这之间的任何函数都可以访问该标识符 2. C++中的存储类型指示符 auto auto标名一个变量具有自动存储周期，该说明符只能用在具有局部作用域的变量声明中。比如一般的局部变量或是在函数原型中的参数 static 使用static声明的局部变量仅被其所声明所在的函数所知，外部无法共享该变量，static局部变量在函数返回后仍保存着变量的值 extern 表明在其他地方定义了该变量（该关键字用于全局变量） register 只能用在具有局部作用域的变量，请求一个变量存储在寄存器中快速使用，但是不能获得该变量的地址。register通常是不必要的 类型 特性 auto 代码块作用域/局部作用域，自动存储期 register 代码块作用域/局部作用域，自动存储期 static 代码块作用域 或者 文件 / 全局作用域，静态存储期 extern 文件/全局作用域，静态存储期 3. 常量 const 常量：const 用于定义常量，const修饰的数据无法被改变，可以用于保护被修饰的变量，防止意外的修改，增强程序的健壮性。 指向常量的指针 / 指针常量：const 可用于修饰指针，分为指向常量的指针（const int * p1：指针指向的内容不能被修改）和指针常量（int * const p2：指针本身不可被修改） 方便记忆可以理解为 * 在 const 前面 则为指针常量 常引用：const 可用于修饰引用，指向常量的引用，用于形参类型，既避免了拷贝、又避免了函数对值的修改 常成员函数：const 可用于修饰成员函数，说明该成员函数内不能修改成员变量 4. 静态 static 静态成员变量：static 声明静态数据成员，具有全局生命周期，不随函数的消亡而消亡，static 修改的数据不属于任何一个对象，该类的所有对象共享。 静态成员函数：static 修饰成员函数，使得不需要对象就能访问该静态成员函数，但是在静态函数内不能访问或修改非静态成员变量或非静态成员函数。 静态普通变量：static 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，具有静态生命周期，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 静态普通函数：static 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 5. 友元 friend友元函数和友元类： 若 B 类是 A 类 的友元，则 B 类可访问 A 类的私有成员 友元机制破坏了数据封装与数据隐藏，建议尽量不使用或少使用友元 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 四、数组与指针1. 指针运算符 * 和 &amp; * 称为指针运算符，也称解析； &amp; 称为取地址运算符； 1234int a = 3; //假设a的地址为1000int *p = &amp;a; //定义一个指针，此处的 * 不作解析cout&lt;&lt;*p&lt;&lt;endl; //输出3cout&lt;&lt;&amp;p&lt;&lt;endl; //输出1000 2. this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 3. 动态内存分配 new同一个程序有可能会处理很大的数据，有时处理很小，若总是以最大的空间内存分配，难免会造成浪费。 在C语言中，用 malloc 进行动态内存分配； 在C++中，用 new 语句 ① new 动态分配动态分配一个变量 123456p = new T; //T代表int,double,float等等//p类型为T*的指针//该语句动态分配了一片大小为 sizeof(T) 字节的内存空间，并将起始地址赋给了pint *pn;pn = new int;*pn = 5; //往刚开辟的空间中写入了数据5 动态分配一个数组 1234567p = new T[N];//动态分配了一片大小为 sizeof(T)*N 字节的内存空间，并将起始地址赋给了pint *pn;int i = 5;pn = new int[i*20]; //100个元素，最大合法下标为99pn[0] = 20;pn[100] = 30; // 编译没问题，运行时数组越界 注：new运算符返回值类型都是 T* ② delete 释放动态分配的内存delete总是和new成对出现 :即动态分配的内存一定要释放掉，否则占用的内存就会越来越多。 delete指针 该指针必须指向new出来的空间 1234int *p = new int;*p = 5;delete p;delete p; //wrong; 同一片空间不能被delete两次 delete [ ]指针 123int *p = new int[20];p[0] = 1;delete []p; //若delete p 则只删除了一部分，没有删干净 4. 深复制和浅复制以下面这个类为例： 123456789101112131415class Point&#123; ...&#125;class ArrayOfPoints&#123; private: Point *points; int size; public: ArrayOfPoints(int size):size(size)&#123; points = new Points[size]; &#125; ~ArrayOfPoints()&#123; delete []points; &#125;&#125;; 浅复制：实现对象间数据元素的一一对应复制，但是指向的仍是同一个地址空间，并没有形成真正的副本，其中一个改变，另一个也会改变。（默认的复制构造函数就是浅复制） 深复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指的对象进行复制 一般深复制需要重写复制构造函数，new一个新的存储空间进行值的复制操作 123456ArrayOfPoints::ArrayOfPoints(const ArrayOfPoints&amp; rhs)&#123; size = rhs.size; points = new Point[size]; for(int i = 0; i &lt; size; i++) points[i] = rhs.points[i];&#125; 5. C++ 中的内存区域C++中的内存区域分为5个区：堆区、栈区、全局/静态存储区、常量存储区、代码程序区 栈（stack）：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限。 堆（heap）：由程序员控制内存的分配和释放的存储区，是不连续的存储空间，堆的分配(new)和释放(delete)有程序员控制，容易造成二次删除和内存泄漏，堆的分配方式类似于链表 123void fun()&#123; int *p = new int[5];&#125; 在上述代码中就包含了堆和栈，看到new，我们就知道分配了一块堆内存，那么指针p呢，它分配的是一块栈内存。即在栈内存中存放了一个指向一块堆内存的指针p 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间 常量存储区（const）：存放常量字符串的存储区，只能读不能写 程序代码区：存放源程序二进制代码 五、类的继承和派生1. 类成员的访问控制 访问控制 功能 public 类外(main()函数)不能访问 private 和 protected 类型，只能访问声明 public 的对外接口 private 类开头若不加访问权限，则默认为private类型① 可被基类的成员函数访问 ② 可被基类的友元函数访问 protect ① 可被基类的成员函数访问② 可被基类的友元函数访问③ 派生类的成员函数可以访问 当前对象 基类的protected成员 2. 三种继承方式 继承方式 功能 public 基类的 public 和 protected 成员访问属性在派生类中保持不变基类的 private 成员，派生类不可直接访问 private 基类的 public 和 protected 成员都以 private 身份出现在派生类中基类的 private 成员，派生类不可直接访问 protect 基类的 public 和 protected 成员都以 protect 身份出现在派生类中基类的 private 成员，派生类不可直接访问 3. 为什么说继承是面向对象的主要特征之一继承是软件重用的一种形式。我们可以通过继承这一方式，从现有的类中吸收数据和方法，并添加现有的类中所没有的新的数据和方法。通过继承这一方式，提高了程序的抽象程度，更加接近人的思维方式，使程序结构清晰并且有利于开发和维护。 4. 成员初始化列表1234567class Student&#123; private: string name; int age; public: Student(string n, int a): name(n),age(a)&#123;&#125;&#125; 使用成员初始化列表的好处： 更高效：初始化列表可以不必调用默认构造函数来初始化，少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员 const ，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 123456class A&#123; private: const int i; public: A(int a): i(a)&#123;&#125; // 常数据成员只能通过构造函数的初始化列表来获得初值&#125; 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 5. :: 范围解析运算符 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）: 用于表示指定类型的作用域范围是具体某个命名空间的 示例： 1234567891011121314151617181920212223int count = 11; // 全局（::）的 countclass A &#123;public: static int count; // 类 A 的 count（A::count）&#125;;int A::count = 21;void fun()&#123; int count = 31; // 初始化局部的 count 为 31 count = 32; // 设置局部的 count 的值为 32&#125;int main() &#123; ::count = 12; // 测试 1：设置全局的 count 的值为 12 A::count = 22; // 测试 2：设置类 A 的 count 为 22 fun(); // 测试 3 return 0;&#125; 6. 多继承时的二义性问题如果某个派生类的部分或全部基类都是从另一个共同的基类派生而来， 在这些直接基类中，从上一级继承而来的成员就拥有相同的名称，因此派生类中就会出现同名现象。 123456789101112131415161718192021class Base&#123; int var0; void fun();&#125;;class Derived1:public Base&#123; int var1;&#125;;class Derived2: public Base&#123; int var2;&#125;;class A: public Derived1,public Derived2&#123; int var3; void fun();&#125;;int main()&#123; Derived d; d.var0 = 3; //二义性 d.Base::var0; //二义性 return 0;&#125; ① 作用域限定1234567891011121314151617181920212223class Base&#123; int var0; void fun();&#125;;class Derived1:public Base&#123; int var1;&#125;;class Derived2: public Base&#123; int var2;&#125;;class A: public Derived1,public Derived2&#123; int var3; void fun();&#125;;int main()&#123; Derived d; d.Derived1::var0 = 2; d.Derived1::fun0(); d.Derived2::var0 = 3; d.Derived2::fun0(); return 0;&#125; 使用作用域限定符，派生类的对象在内存中就同时拥有成员var0的多份同名副本，可赋不同的值，若只需要一个这样的数据副本，使用虚基类 ② 虚继承 / 虚基类虚基类（说虚继承可能更好理解 😂）用于解决多继承（派生类继承多个小基类，这些小基类又都继承同一个大基类）条件下的菱形继承问题（浪费存储空间、存在二义性）。 为最远的派生类提供唯一的基类成员，而不重复产生多次复制 12345678910111213141516class Base&#123; int var;&#125;;class Derived1: virtual public Base&#123; &#125;;class Derived2: virtual public Base&#123; &#125;;class A: public Derived1,public Derived2&#123; &#125;;int main&#123; A a; a.var = 2; //直接访问基类的数据成员&#125; 📣 虚基类的底层实现原理： 底层实现原理与编译器相关，一般通过虚指针和虚表实现（详见下文），每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 ③ 虚基类 和 作用域限定 比较前者只维护一份成员副本，后者在派生类中拥有同名成员的多个副本，可以存放不同的数据。 相比之下，前者使用更为简洁，空间更为节省，后者可以容纳更多的数据 六、多态1. 静态绑定 和 动态绑定 绑定机制： 绑定是将一个标识符名和一个存储地址联系在一起的过程 编译时的多态通过静态绑定实现 绑定工作在程序编译连接阶段运行（比如重载） 运行时的多态通过动态绑定实现 绑定工作在程序运行阶段运行（比如虚函数） 2. C++ 多态的实现多态是指同样的消息被不同类型的对象接收时产生不同的行为，是对类的特定成员函数的再抽象。 C++ 多态的实现： 重载多态：编译期的多态，静态绑定 —— 函数重载、运算符重载； 子类型多态：运行期的多态，动态绑定 —— 虚函数； 参数多态：编译器的多态，静态绑定 —— 函数模板、类模板； 强制多态：编译期或者运行期的多态 —— 强制类型转换、自定义类型转换。 重载（函数重载、运算符重载）和虚函数是多态实现的主要方式。 3. 虚函数 virtual① 如何区别虚函数和纯虚函数？两者都有啥作用12virtual void fun(); //虚函数virtual void fun() = 0; //纯虚函数 虚函数使得基类和派生类的同名函数具有不同的操作，实现多态。 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 有纯虚函数的类称为抽象类。这种类不能直接生成对象，只有被继承，并且纯虚函数在子类中必须给出实现，否则该子类仍是纯虚函数 虚函数在子类里面可以不重写；但纯虚函数必须在子类给出实现才可以实例化子类 ② 虚析构函数的作用析构函数：类的析构函数是为了释放内存资源，析构函数不被调用的话就会造成内存泄漏。 虚析构函数：定义为虚析构函数是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。 但并不是要把所有类的析构函数都写成虚函数。只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。 123456789101112131415161718192021class Shape&#123;public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0；&#125; ③ 虚指针、虚表 虚指针：每个对象有一个指向当前类的虚表的指针。 虚表：每个多态类都有一个虚表，虚表中存放当前类的各个虚函数的入口地址，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 动态绑定的实现： 构造函数中为对象的虚指针赋值； 通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址 通过该地址调用虚函数 4. 重载① 函数重载C++允许功能相近的函数在相同的作用域内，以相同函数名声明，从而形成重载。 函数重载提高了程序的可扩充性。 🚨 注意： 重载函数的 形参个数 或者 形参类型 必须不同； 编译器不以 函数的返回值 或者 形参名 来去区分重载函数。 若只有返回值类型不同，则不叫重载，叫重复定义 ② 运算符重载 operatorⅠ 什么是运算符重载对已有的运算符赋予多重含义，使用一个运算符作用于不同类型的数据时产生不同的行为。 Ⅱ 运算符重载规则重载为类成员函数 双目运算符重载规则（1个参数 对象） 1Complex operator + (const Complex &amp;c2) const; 前置单目运算符重载规则（无参） 1Point &amp;Point::operator++(); //前置++ 后置单目运算符重载规则（1个参数 int) 1Point operator++(int); //后置++ 重载为非成员函数 双目运算符重载规则（2个参数 对象） 1friend Complex operator + (const Complex &amp;c1, const Complex &amp;c2); 前置单目运算符重载规则 (1个参数 对象） 1friend Complex operator ++(Complex &amp;c1); 后置单目运算符重载规则（2个参数 对象，0） 1friend Complex operator ++(Complex &amp;c1, 0); Ⅲ 哪几个运算符必须重载为成员函数 () [ -&gt; = 5. 模板 template 函数模板 1234template&lt;class T&gt;T sum(T a, T b)&#123; return a + b;&#125; 类模板 123456789101112template&lt;class T&gt;class Store&#123; private: T item; //item用于存放任意类型的数据 public: T &amp;getElem(); //提取数据&#125;;template&lt;class T&gt;T&amp; Store&lt;T&gt;::getElem()&#123; return item;&#125; ① 函数模板 和 函数重载 的区别和联系 函数模板：若一个函数的功能是对任意类型的数据做同样的处理，比如一个加法函数可以处理float、int、char等多种类型，则将所处理的数据类型说明为参数，就可以把这个函数声明为模板&lt;template&gt; 。函数模板代表的是具有相同功能的一类函数，函数模板的参数都是抽象的。 函数重载：同一函数名定义多个函数，这些函数的参数个数，参数类型不同，这就是函数重载（不以返回值判定是否是重载）。函数重载的参数都是具体的。 ② 函数模板 和 模板函数 的区别与联系函数模板：函数模板就是数据类型参数化的函数定义，是一类函数。当编译系统发现用指定数据调用函数模板的时候，就创建了一个模板函数，模板函数就是函数模板实例化的结果。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"文件和输入输出流","slug":"Cpp/9.文件和输入输出流","date":"2020-01-29T14:02:45.000Z","updated":"2020-09-04T15:07:43.780Z","comments":true,"path":"2020/01/29/Cpp/9.文件和输入输出流/","link":"","permalink":"https://aaronyard.github.io/2020/01/29/Cpp/9.%E6%96%87%E4%BB%B6%E5%92%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/","excerpt":"C++的 I/O是以一连串的字节流的方式进行的，在输入操作中，字节从设备（键盘，磁盘驱动器等）流向内存。在输出操作中，字节从内存流向设备（显示屏，打印机等） C++将每个文件看成是字节序列流。 一、关于流的头文件绝大多数的C++程序都包含了&lt; iostream &gt;头文件，该头文件中声明了所有I/O流操作的所需的基础服务。&lt; iostream &gt;头文件定义了 cin 标准输入流、cout 标准输出流、cerr 标准错误流 和 clog 有缓冲的标准错误流（流输出内容存入缓冲区，直到缓冲区填满或是被清空才会输出）&lt; iomanip &gt; 头文件声明了对于带有参数化流运算符（例如 setw 和 setprecision）的格式化I/O有用的服务&lt;fstream&gt; 头文件声明了用户控制的文件处理服务 二、文件打开模式","text":"C++的 I/O是以一连串的字节流的方式进行的，在输入操作中，字节从设备（键盘，磁盘驱动器等）流向内存。在输出操作中，字节从内存流向设备（显示屏，打印机等） C++将每个文件看成是字节序列流。 一、关于流的头文件绝大多数的C++程序都包含了&lt; iostream &gt;头文件，该头文件中声明了所有I/O流操作的所需的基础服务。&lt; iostream &gt;头文件定义了 cin 标准输入流、cout 标准输出流、cerr 标准错误流 和 clog 有缓冲的标准错误流（流输出内容存入缓冲区，直到缓冲区填满或是被清空才会输出）&lt; iomanip &gt; 头文件声明了对于带有参数化流运算符（例如 setw 和 setprecision）的格式化I/O有用的服务&lt;fstream&gt; 头文件声明了用户控制的文件处理服务 二、文件打开模式 三、输出流输出功能包括 流插入运算符 &lt;&lt; put成员函数进行字符输出 write成员函数进行非格式化的输出 十进制、八进制、十六进制格式的整数输出 不同精确度的浮点数的输出 指定宽度数据的输出 。。。。。。 1. 构造输出流对象打开文件——用于修改默认输出流文件打开模式是 ios::out当不需要文件时显示的将其关闭，可以减少资源占用 file.close();举例：使用I/O流以文本方式建立一个文件test.txt，并写入字符！ 12345ofstream file1(\"E:\\\\Codes\\\\TestInfo\\\\test.txt\");cout &lt;&lt; \"the file is writing......\" &lt;&lt; endl;file1&lt;&lt;\"successful input!\";file1.close();cout&lt;&lt;\"done!\"&lt;&lt;endl; 2. 文件输出流成员函数put 成员函数cout.put(&#39;A&#39;); 显示单个字符。put也可级联使用cout.put(&#39;A&#39;).put(&#39;\\n&#39;); cout.put(‘A’); 效果基本等同于 cout&lt;&lt;’A’;cout.put(‘AAAA’); //错误，只能输出单个字符warning: overflow in implicit constant conversion [-Woverflow] write 成员函数将内存中的一块内容写到一个文件输出流中从字符数组中输出字节到文件中去 四、输入流1. 构造输入流对象打开文件——用于读取文件输入流的默认打开模式 ios::in 2. 输入流相关函数get成员函数功能和 &gt;&gt; 很像，主要的不同点在于 get函数在读入数据时包括空白字符get函数在遇到文件尾的时候返回 EOF getline 成员/非成员函数读取多行字符，每读一行存储一次，可定义行分割符 非成员函数函数原型 template&lt;&gt; std::istream &amp;std::getline&lt;...&gt;(std::istream &amp;__is, std::string &amp;__str, char __delim)第一个参数传入输入流，第二个参数传入string字符串，第三个参数为自定义行分割符，getline读取到行分割符就结束本次读取，并将自定义的行分割符从流中删除 举例：分行读取文件中的内容 文件中的内容123456789 12345678910111213#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; string line1; string line2; string line3; ifstream ifile(\"E:\\\\Codes\\\\Program-c++\\\\Zhenli_Book_Code\\\\11-7.txt\"); getline(ifile, line1); getline(ifile, line2,'5'); getline(ifile, line3); cout&lt;&lt;line1&lt;&lt;endl&lt;&lt;line2&lt;&lt;endl&lt;&lt;line3&lt;&lt;endl;&#125; 读取结果 12346 成员函数 成员函数只能将读取到内容存储在字符数组中 char[ ]函数原型 template&lt;&gt; std::istream &amp;std::istream::getline(char *__s, std::streamsize __n, char __delim)第一个参数时字符数组，第二个参数是读取的字节数，第三个参数为自定义行分割符读取的字节数已满或者已到自定义的行分割符，则getline都会结束本次读取，并将自定义的行分割符从流中删除 1234567891011int main()&#123; char buf1[10]; char buf2[10]; char buf3[10]; ifstream ifile(\"E:\\\\Codes\\\\Program-c++\\\\Zhenli_Book_Code\\\\11-7.txt\"); ifile.getline(buf1,10,'2'); ifile.getline(buf2, 10); ifile.getline(buf3, 10); cout&lt;&lt;buf1&lt;&lt;endl&lt;&lt;buf2&lt;&lt;endl&lt;&lt;buf3&lt;&lt;endl;&#125; 输出结果 13456 read 成员函数从文件中读取内容输入到字符数组中由长度参数确定要读的字节数","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"函数模板和类模板","slug":"Cpp/8.函数模板和类模板","date":"2020-01-28T14:02:45.000Z","updated":"2020-09-04T15:07:36.751Z","comments":true,"path":"2020/01/28/Cpp/8.函数模板和类模板/","link":"","permalink":"https://aaronyard.github.io/2020/01/28/Cpp/8.%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF/","excerpt":"一、函数模板 二、类模板直接上示例类模板示例","text":"一、函数模板 二、类模板直接上示例类模板示例 123456789101112131415161718192021222324252627282930313233343536373839404142template&lt;class T&gt;class Store&#123; private: T item; //item用于存放任意类型的数据 bool haveValue; //标记item是否已经被存入内容 public: T &amp;getElem(); //提取数据 void putElem(const T&amp; x); //存入数据 Store();&#125;;template&lt;class T&gt;Store&lt;T&gt;::Store():haveValue(false)&#123; &#125;template&lt;class T&gt;T&amp; Store&lt;T&gt;::getElem()&#123; if(!haveValue)&#123; cout&lt;&lt;\"no data!\"&lt;&lt;endl; exit(1); //使程序完全退出，返回操作系统 &#125; return item;&#125;template&lt;class T&gt;void Store&lt;T&gt;::putElem(const T&amp; x)&#123; item = x; haveValue = true;&#125;struct student&#123; int id; float gpa;&#125;;int main()&#123; Store&lt;int&gt;s1; s1.putElem(4); cout&lt;&lt;s1.getElem()&lt;&lt;endl; student s= &#123;1001,98.2&#125;; Store&lt;student&gt; s2; s2.putElem(s); cout&lt;&lt;s2.getElem().id&lt;&lt;\" \"&lt;&lt;s2.getElem().gpa&lt;&lt;endl; &#125; 三、自定义动态数组类模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105template &lt;class T&gt;class Array&#123;private: T *list; //T类型指针，存放动态分配的数组首地址 int size; //数组大小public: Array(int sz = 50); Array(const Array&lt;T&gt; &amp;a); //复制构造 ~Array(); Array&lt;T&gt; &amp;operator=(const Array&lt;T&gt; &amp;rhs); T &amp;operator[](int i); //重载下标运算符 可被改变 a[3] = 5 const T &amp;operator[](int i) const; //重载下标运算符 常函数 operator T *(); //重载隐式转换，将对象重载为T*类型 operator const T *() const; int getSize() const; //获取数组大小 void reSize(int sz); //修改数组大小&#125;;//构造函数template &lt;class T&gt;Array&lt;T&gt;::Array(int sz)&#123; assert(sz &gt;= 0); size = sz; list = new T[size]; //动态分配数组空间&#125;//拷贝构造（深层复制）template &lt;class T&gt;Array&lt;T&gt;::Array(const Array&lt;T&gt; &amp;a)&#123; size = a.size; list = new T[size]; for (int i = 0; i &lt; size; i++) list[i] = a.list[i];&#125;//析构函数template &lt;class T&gt;Array&lt;T&gt;::~Array()&#123; delete[] list;&#125;//重载=template &lt;class T&gt;Array&lt;T&gt; &amp;Array&lt;T&gt;::operator=(const Array&lt;T&gt; &amp;rhs)&#123; if (this != &amp;rhs) &#123; //避免自身复制 if (size != rhs.size) &#123; //如果两个数组的大小不同，则需要重新分配内存空间 delete[] list; size = rhs.size; list = new T[size]; &#125; for (int i = 0; i &lt; size; i++) list[i] = rhs.list[i]; &#125; return *this; //返回当前对象的引用&#125;//重载下标运算符[ ]，实现与普通数组一样通过下标访问元素，具有越界检查功能 template &lt;class T&gt;T &amp;Array&lt;T&gt;::operator[](int i)&#123; assert(i &gt;= 0 &amp;&amp; i &lt; size); return list[i]; //return *(list+i);&#125;//重载[ ]常函数template &lt;class T&gt;const T &amp;Array&lt;T&gt;::operator[](int i) const&#123; assert(i &gt;= 0 &amp;&amp; i &lt; size); return list[i]; //return *(list+i);&#125;//重载到T*类型的转换template &lt;class T&gt;Array&lt;T&gt;::operator T *()&#123; return list; //返回当前对象私有数组的首地址&#125;//重载到T*类型的转换 常函数template &lt;class T&gt;Array&lt;T&gt;::operator const T *() const&#123; return list;&#125;template &lt;class T&gt;int Array&lt;T&gt;::getSize() const&#123; return size;&#125;template &lt;class T&gt;void Array&lt;T&gt;::reSize(int sz)&#123; assert(sz &gt;= 0); if (sz == size) return; T *newlist = new T[sz]; //申请新的数组内存 int n = (sz &lt; size ? sz : size); //将较小值赋给n for (int i = 0; i &lt; n; i++) newlist[i] = list[i]; delete[] list; //删除原数组 list = newlist; //使list指向新数组 size = sz; //更新size&#125; 其中 operator T * ()； 重载隐式转换的作用","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"多态性","slug":"Cpp/7.多态性","date":"2020-01-27T14:02:45.000Z","updated":"2020-09-04T15:07:33.377Z","comments":true,"path":"2020/01/27/Cpp/7.多态性/","link":"","permalink":"https://aaronyard.github.io/2020/01/27/Cpp/7.%E5%A4%9A%E6%80%81%E6%80%A7/","excerpt":"一、多态的实现 绑定机制：绑定是将一个标识符名和一个存储地址联系在一起的过程 编译时的多态通过静态绑定实现绑定工作在程序编译连接阶段运行 运行时的多态通过动态绑定实现绑定工作在程序运行阶段运行","text":"一、多态的实现 绑定机制：绑定是将一个标识符名和一个存储地址联系在一起的过程 编译时的多态通过静态绑定实现绑定工作在程序编译连接阶段运行 运行时的多态通过动态绑定实现绑定工作在程序运行阶段运行 二、运算符重载（静态绑定）函数重载同样也是静态绑定 1. 重载为类成员函数123函数类型 operator 运算符（形参） &#123; ...... &#125; 参数个数=原操作数个数-1 （后置++，– 除外） 双目运算符重载规则 （1个参数 对象）重载B为类成员函数，使之能够实现 oprd1 B oprd2;以 + 举例经重载后，表达式 a + b 相当于 a.operator +(b) 12345Complex operator + (const Complex &amp;c2) const;Complex Complex::operator+(const Complex &amp;c2)&#123; //创建一个临时无名对象作为返回值 return Complex(real + c2.real, imag + c2.imag); 前置单目运算符重载规则（无参）重载B为类成员函数，使之能实现 B oprd，无形参以 前置++ 为例：经重载后，++ a 相当于 a.operaotr ++() 12345678Point &amp;operator++(); //前置++Point &amp;Point::operator++()&#123; x++; y++; //++a = b; =&gt; 左边的值先增加再做运算，所以返回修改后的值 return *this;&#125; 后置单目运算符++和–重载规则 （1个参数 int)如果要重载 ++ 或者 – 为类成员函数，使之能够实现表达式 oprd ++ 或 oprd –，其中oprd为A类对象，则 ++ Huon – 应该被重载为A类的成员函数，且具有一个 int 形参以 后置++ 为例： 经重载后，a ++ 相当于 a.operaotr ++(0) 12345678910Point operator++(int); //后置++//后置运算符不能作为左值 a++ = b得到的a的值为a++的结果Point Point::operator++(int)&#123; Point temp = *this; ++*this; //调用前置++ //a++ = b; =&gt; 左边的值先做运算再增加，所以返回增加前的值（本身） return temp;&#125; 2. 重载为非成员函数参数个数=原操作数个数（后置++，– 除外） 双目运算符重载规则（2个参数 对象）两个操作数都是类的引用 1friend Complex operator + (const Complex &amp;c1, const Complex &amp;c2); 前置单目运算符重载规则 (1个参数 对象）1friend Complex operator ++(Complex &amp;c1); 后置单目运算符++和–重载规则 （2个参数 对象，0）1friend Complex operator ++(Complex &amp;c1, 0); 三、运算符重载实例① 对Point类重载++（自增）、–（自减）运算符，同时重载前缀和后缀形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Point &#123; private: int x, y; public: Point(int a, int b) &#123; x = a; y = b; &#125; Point &amp;operator++(); //前置++ Point operator++(int); //后置++ Point &amp;operator--(); //前置-- Point operator--(int); //后置-- int getx() &#123; return x; &#125; int gety() &#123; return y; &#125; &#125;; Point &amp;Point::operator++() &#123; x++; y++; //++a = b; =&gt; 左边的值先增加再做运算，所以返回修改后的值 return *this; &#125; //后置运算符不能作为左值 a++ = b得到的a的值为a++的结果 Point Point::operator++(int) &#123; Point temp = *this; ++*this; //调用前置++ //a++ = b; =&gt; 左边的值先做运算再增加，所以返回增加前的值（本身） return temp; &#125; Point &amp;Point::operator--() &#123; x--; y--; return *this; &#125; Point Point::operator--(int) &#123; Point temp = *this; --*this; //调用前置-- return temp; &#125; ② 高精度算法：定义HugeInt类能处理20亿以上的整数并重载+和&lt;&lt; 32位整数的机器所能表示的整数范围大概是-20亿~20亿 思路：将大数存入数组，再对数组进行逐位操作 代码实现：👇 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;using std::ostream;class HugeInt&#123;public: HugeInt(long val = 0); // long型数转换构造为HugeInt型 HugeInt(const char *s); // 字符存储的大数转换构造为HugeInt型 HugeInt operator +(HugeInt &amp;rhs); // +重载 friend ostream &amp;operator &lt;&lt;(ostream &amp;os, HugeInt &amp;rhs); // &lt;&lt;重载private: short integer[30];&#125;;// 转换构造函数HugeInt::HugeInt(long val)&#123; for (int i = 0; i &lt;= 29; i++) integer[i] = 0; // 将数组初始化为0 for (int i = 29; val != 0 &amp;&amp; i &gt;= 0; i --) &#123;//从后往前依次填入数组，不满30位的前面补0 integer[i] = val % 10; val /= 10; &#125;&#125;HugeInt::HugeInt(const char *s)&#123; for (int i = 0; i &lt;= 29; i++) integer[i] = 0; for (int i = 30 - strlen(s), j = 0; i &lt;= 29; i++, j++) integer[i] = s[j]-'0';&#125;// 巨型整数相加HugeInt HugeInt::operator +(HugeInt &amp;op2)&#123; HugeInt temp; int carry = 0; //进位 for (int i = 29; i &gt;= 0; i--) &#123; temp.integer[i] = integer[i] + op2.integer[i] + carry; if (temp.integer[i] &gt; 9) &#123; temp.integer[i] %= 10; carry = 1; &#125; else carry = 0; &#125; return temp;&#125;ostream &amp;operator &lt;&lt;(ostream &amp;output, HugeInt &amp;num)&#123; int i = 0; for (; (num.integer[i] == 0) &amp;&amp; (i &lt;= 29); i++) ; // 跳过前导0 if (i == 30) output &lt;&lt; 0; else for (; i &lt;= 29; i++) output &lt;&lt; num.integer[i]; return output;&#125;int main()&#123; using std::cout; using std::endl; HugeInt n1(7654321),n2(1234567); //测试long型 HugeInt n3(\"12345678987654321\"), n4(\"12345678987654321\"); //测试字符串型 cout &lt;&lt; \"n1 is \" &lt;&lt; n1 &lt;&lt; \"\\nn2 is \" &lt;&lt; n2 &lt;&lt; \"\\nn3 is \" &lt;&lt; n3 &lt;&lt; \"\\nn4 is \" &lt;&lt; n4 &lt;&lt;endl; HugeInt n5 = n1+n2; HugeInt n6 = n3+n4; HugeInt n7 = n3 + n1; cout&lt;&lt; \"n1+n2=\"&lt;&lt;n5&lt;&lt;endl; //测试long型大数相加 cout&lt;&lt; \"n3+n4=\"&lt;&lt;n6&lt;&lt;endl; //测试字符串型大数相加 cout&lt;&lt; \"n1+n3=\" &lt;&lt; n7 &lt;&lt; endl; //测试long型和字符串型相加&#125; 四、虚函数（动态绑定）初始虚函数多态是不同对象对同一消息有不同的行为特性，虚函数作为运行过程中多态的基础，主要是针对对象的，而构造函数是在对象产生之前运行的，因此虚构造函数没有意义。 一般虚函数成员 virtual 关键字 虚表与动态绑定 虚函数实例定义一个基类BaseClass，从它派生出类DerivedClass，BaseClass有成员函数fn1()、fn2()，fn1()是虚函数，DerivedClass也有成员函数fn1()、fn2()，在主程序中定义一个DerivedClass的对象，分别用BaseClass和DerivedClass的指针来调用fn1()、fn2()，观察运行结果。 1234567891011121314151617181920212223242526272829303132333435363738class BaseClass&#123;public: virtual void fn1(); void fn2();&#125;;void BaseClass::fn1()&#123; cout &lt;&lt; \"调用基类的虚函数fn1()\" &lt;&lt; endl;&#125;void BaseClass::fn2()&#123; cout &lt;&lt; \"调用基类的非虚函数fn2()\" &lt;&lt; endl;&#125;class DerivedClass : public BaseClass&#123;public: void fn1(); void fn2();&#125;;void DerivedClass::fn1()&#123; cout &lt;&lt; \"调用派生类的函数fn1()\" &lt;&lt; endl;&#125;void DerivedClass::fn2()&#123; cout &lt;&lt; \"调用派生类的函数fn2()\" &lt;&lt; endl;&#125;int main()&#123; DerivedClass aDerivedClass; DerivedClass *pDerivedClass = &amp;aDerivedClass; BaseClass *pBaseClass = &amp;aDerivedClass; pBaseClass-&gt;fn1(); pBaseClass-&gt;fn2(); pDerivedClass-&gt;fn1(); pDerivedClass-&gt;fn2();&#125; 五、纯虚函数与抽象类","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"类的继承与派生","slug":"Cpp/6.类的继承与派生","date":"2020-01-26T14:02:45.000Z","updated":"2020-09-04T15:07:27.553Z","comments":true,"path":"2020/01/26/Cpp/6.类的继承与派生/","link":"","permalink":"https://aaronyard.github.io/2020/01/26/Cpp/6.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","excerpt":"一、三种继承方式1. public 2. private","text":"一、三种继承方式1. public 2. private 同名隐藏如果派生类声明一个和某基类成员同名的新成员（如果是成员函数，则参数表也要相同，参数不同的情况属于重载），派生的新成员就隐藏了外层（基类）同名成员，称为同名隐藏 3. protected 二、 类型兼容规则（类型转换）公有派生类对象可以被当作基类的对象使用，反之则不可。 派生类的对象可以隐含转换为基类对象； 1234class A;class B:public AA a1; B b1;a1 = b1; 派生类的对象可以初始化基类的引用； 1A &amp;a = b1; 派生类对象的地址可以隐含转换为基类的指 针。 12A *ra ; ra = &amp;b1; 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。 例如： 虽然根据类型兼容规则，可以将派生类对象的地址赋值给基类Base1的指针， 但是通过这个基类的指针（或者对象名）只能访问从基类继承的成员。 所以运行结果是： Base1 :: display( ) Base1 :: display( ) Base1 :: display( ) 可以使用 虚函数 解决这个问题（详细解析见后续文章） 三、派生类的构造函数 按照 Base2，Base1，Base3的顺序调用基类的构造函数进行初始化， 按照 Base1，Base2，Base3的顺序初始化成员对象 析构函数的调用顺序和构造函数的调用顺序正好相反 四、访问从基类继承的成员1. 二义性问题 如果某个派生类的部分或全部基类都是从另一个共同的基类派生而来， 在这些直接基类中，从上一级继承而来的成员就拥有相同的名称，因此派生类中就会出现同名现象。 多继承时的二义性和冗余性问题： 使用作用域限定符，派生类的对象在内存中就同时拥有成员var0的多份同名副本，可赋不同的值，若只需要一个这样的数据副本，使用虚基类 2. 作用域限定当派生类与基类中有相同成员时： 若未特别限定，则通过派生对象使用的是派生类中的同名成员（同名隐藏） 如果要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符 ：： 来限定 使用作用域限定符，通过直接基类名来确定要访问的成员，这种情况下， 派生类的对象在内存中就同时拥有成员var0的两份同名副本（Base1和Base2的）可赋不同的值 可以使用类名限定解决多继承时的二义性问题 3. 虚基类解决多继承（派生类继承多个小基类，这些小基类又都继承同一个大基类）时的二义性和冗余性问题 举例： 4. 虚基类和作用域分辨符比较前者只维护一份成员副本，后者在派生类中拥有同名成员的多个副本，可以存放不同的数据。 相比之下，前者使用更为简洁，空间更为节省，后者可以容纳更多的数据","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"数组与指针","slug":"Cpp/5.数组与指针","date":"2020-01-25T14:02:45.000Z","updated":"2020-09-04T15:07:24.940Z","comments":true,"path":"2020/01/25/Cpp/5.数组与指针/","link":"","permalink":"https://aaronyard.github.io/2020/01/25/Cpp/5.%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/","excerpt":"一、数组1. 数组的存储与初始化一维数组 二维数组","text":"一、数组1. 数组的存储与初始化一维数组 二维数组 2. 数组作为函数参数 3. 对象数组对象数组——线性回归方程实例 123456789101112131415161718192021222324252627282930313233class Point&#123; public: Point(float xx = 0,float yy = 0):x(xx),y(yy)&#123; &#125; float getX() const &#123;return x;&#125; float getY() const &#123;return y;&#125; private: float x,y;&#125;;//直线线性拟合，number为点数float lineFit(const Point points[], int number)&#123; float avgx = 0, avgy = 0; float lxx = 0,lyy = 0, lxy = 0; for(int i =0;i&lt;number;i++)&#123; avgx += points[i].getX()/number; avgy += points[i].getY()/number; &#125; for(int i = 0;i&lt;number;i++)&#123; lxy += (points[i].getX() - avgx) * (points[i].getY() - avgy); lyy += (points[i].getY() - avgy) * (points[i].getY() - avgy); lxx += (points[i].getX() - avgx) * (points[i].getX() - avgx); &#125; cout&lt;&lt;\"This line can be fitted by y=ax+b.\"&lt;&lt;endl; //输出回归系数a,b cout&lt;&lt;\"a = \"&lt;&lt;lxy/lxx&lt;&lt;\" \"&lt;&lt;\"b = \"&lt;&lt;avgy-lxy*avgx/lxx&lt;&lt;endl; return (float)(lxy/sqrt(lxx*lyy)); //线性相关的密切程度&#125;int main()&#123; Point points[10] = &#123;Point(6,10),Point(14,20),Point(26,30),Point(33,40), Point(46,50),Point(54,60),Point(67,70),Point(75,80), Point(84,90),Point(100,100)&#125;; float r = lineFit(points,10); cout&lt;&lt;\"Line coefficient r = \"&lt;&lt;r&lt;&lt;endl;&#125; 二、指针1. 指针运算符 * 和 &amp; * 称为指针运算符，也称解析； &amp; 称为取地址运算符； 2. 指针变量的赋值运算 3. 指针的类型指向常量的指针 const int * p* 在const的右边 指针类型的常量 int * const p* 在const的左边 4. 指针的算法运算、关系运算 5. 用指针访问数组元素 6. 指针数组 Point *p[2] 7. 指针与函数指针作为函数参数为什么需要用指针做参数？ 需要数据双向传递时（引用也可以达到此效果）；用指针作为函数的参数，可以使被调函数通过形参指针存取主调函数中实参指针指向的数据，实现数据的双向传递 需要传递一组数据，只传首地址运行效率比较高 ；实参是数组名时，形参可以是指针 引用和指针有何区别？何时只能用指针而不能使用引用 引用是一个别名，不能为空，不能被重新分配；指针是一个存放地址的变量。 当需要对变量重新赋以另外的地址或赋值为NULL时只能使用指针 指针类型的函数若函数的返回值是指针，该函数就是指针类型的函数 12int * function()&#123;&#125; 函数类型的指针即指向函数的指针 定义：数据类型 （* 函数指针名）(形参表) int (*func)(int, int) 含义：函数指针指向的是程序代码存储区。 ) 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int compute(int a, int b, int (*func)(int, int))&#123; return func(a, b);&#125;int max(int a, int b) // 求最大值&#123;11 return ((a &gt; b) ? a : b);&#125;int min(int a, int b) // 求最小值&#123; return ((a &lt; b) ? a : b);&#125;int sum(int a, int b) // 求和&#123; return a + b;&#125;int main()&#123; int a, b, res; cout &lt;&lt; \"请输入整数a：\"; cin &gt;&gt; a; cout &lt;&lt; \"请输入整数b：\"; cin &gt;&gt; b; res = compute(a, b, &amp;max); cout &lt;&lt; \"Max of \" &lt;&lt; a &lt;&lt; \" and \" &lt;&lt; b &lt;&lt; \" is \" &lt;&lt; res &lt;&lt; endl; res = compute(a, b, &amp;min); cout &lt;&lt; \"Min of \" &lt;&lt; a &lt;&lt; \" and \" &lt;&lt; b &lt;&lt; \" is \" &lt;&lt; res &lt;&lt; endl; res = compute(a, b, &amp;sum); cout &lt;&lt; \"Sum of \" &lt;&lt; a &lt;&lt; \" and \" &lt;&lt; b &lt;&lt; \" is \" &lt;&lt; res &lt;&lt; endl;&#125; 8. 对象指针定义形式：类名 *对象指针名 123Point *ptr;Point a(5,10);ptr = &amp;a; 对象指针通过 -&gt; 访问对象成员 ptr-&gt;getx() 相当于 (*ptr).getx(); 9. this 指针 10. 动态内存分配 首先我们需要分清几个概念int *point = new int(5); //用5初始化int *point = new int(); //用0初始化int *point = new int; //不分配初值int *point = new int[5] //表示为该指针分配包含十个元素的地址空间 同一个程序有可能会处理很大的数据，有时处理很小，若总是以最大的空间内存分配，难免会造成浪费。 在C语言中，用 malloc 进行动态内存分配； 在C++中，用 new 语句 new 动态分配动态分配一个变量 123456p = new T; //T代表int,double,float等等//p类型为T*的指针//该语句动态分配了一片大小为 sizeof(T) 字节的内存空间，并将起始地址赋给了pint *pn;pn = new int;*pn = 5; //往刚开辟的空间中写入了数据5 动态分配一个数组 1234567p = new T[N];//动态分配了一片大小为 sizeof(T)*N 字节的内存空间，并将起始地址赋给了pint *pn;int i = 5;pn = new int[i*20]; //100个元素，最大合法下标为99pn[0] = 20;pn[100] = 30; // 编译没问题，运行时数组越界 注：new运算符返回值类型都是 T* delete 释放动态分配的内存delete总是和new成对出现 :即动态分配的内存一定要释放掉，否则占用的内存就会越来越多。 delete指针 该指针必须指向new出来的空间 1234int *p = new int;*p = 5;delete p;delete p; //wrong; 同一片空间不能被delete两次 delete [ ]指针 123int *p = new int[20];p[0] = 1;delete []p; //若delete p 则只删除了一部分，没有删干净 三、自定义动态数组类 ArrofPoints将数组的建立和删除过程封装起来，数组下标越界检查 四、Vector类模板（C++标准库中的）为什么需要vector 封装任何类型的动态数组，自动创建和删除 数组下标越界检查 vector对象的定义vector&lt;元素类型&gt; 数组对象名(数组长度) vector&lt;int&gt; arr(5) 建立大小为5的int数组 vector&lt;int&gt; arr(5,2) 大小为5的int类型数组，所有元素用2初始化 vector对象的使用 对数组元素的引用 ：与普通数组具有相同形式： vector对象名 [ 下标表达式 ] vector数组对象名不表示数组首地址 ，因为数组对象不是数组，而是封装了数组的对象 获得数组长度 ：用size函数 数组对象名.size() vector应用举例： 五、深复制与浅复制 以上面的自定义动态数组类 ArrayOfPoints 为例 浅复制ArrayOfPoints pointsArray2(pointsArray1); //创建副本 pointsArray1和pointsArray2有相同的值，表面上好像完成了复制，但是指向的是同一个内存空间，并没有形成真正的副本，当程序中改变pointsArray1时也会改变pointsArray2。 而且，在程序结束之前，pointsArray1和pointsArray2的析构函数会自动调用，动态分配的内存空间被释放，由于两个对象给公用了同一块内存空间，因此该空间被释放两次，导致运行错误。 深复制（重新编写复制构造函数）核心思想：重新new一个存储空间进行值的复制操作 六、字符串详见第一章 【C++复习总结回顾】—— 【一】基础知识+字符串/string类 七、手撸String类设计一个字符串类MyString，具有构造函数、析构函数、复制构造函数、并重载运算符 +、=、+=、[ ]，尽可能的完善它，使之能满足各种需要。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Mystring&#123; private: char* mystring; //字符指针 int len; //字符串长度 Mystring(int clen)&#123; //私有构造，防止其他类进行调用创建实例，只使用一次（在+重载） mystring = new char[clen + 1]; for (int i = 0; i &lt; clen; i++) mystring[i] = '\\0'; len = clen; &#125; public: Mystring(); //无参构造 Mystring(const char* const cmystring); //带参构造 Mystring(const Mystring&amp; rhs); //复制构造 ~Mystring(); //析构 int getLen() const&#123; //获取长度 return this-&gt;len; &#125; const char *GetMyString() const&#123; //获取字符串 return mystring; &#125; char &amp; operator[](int offset); //重载下标运算符，作为左值可被修改，需返回引用 char operator [](int offset) const; //重载下标运算符，作为右值仅能访问 Mystring operator +(const Mystring&amp; rhs); //a+b a的值并不会被修改，不需要返回引用 void operator +=(const Mystring&amp; rhs); //a+=b 无返回值 Mystring&amp; operator =(const Mystring&amp; rhs); //a=b a的值会被修改，需要返回引用&#125;;//无参构造Mystring::Mystring()&#123; mystring = new char[1]; mystring[0] = '\\0'; len = 0;&#125;//带参构造Mystring::Mystring(const char* const cmystring)&#123; len = strlen(cmystring); mystring = new char[len+1]; for(int i = 0; i&lt;len; i++) mystring[i] = cmystring[i]; mystring[len] = '\\0';&#125;//复制构造Mystring::Mystring(const Mystring&amp; rhs)&#123; len = rhs.getLen(); mystring = new char[len+1]; for(int i = 0; i&lt;len;i++) mystring[i] = rhs[i]; mystring[len] = '\\0';&#125;//析构 Mystring::~Mystring()&#123; delete[] mystring; len = 0;&#125;char&amp; Mystring::operator[](int offset)&#123; if(offset&gt;len) //若超出最大长度，返回最后一位字符 return mystring[len-1]; else return mystring[offset];&#125;char Mystring::operator[](int offset) const&#123; if (offset &gt; len) //若超出最大长度，返回最后一位字符 return mystring[len - 1]; else return mystring[offset];&#125;//字符串连接+重载Mystring Mystring :: operator +(const Mystring&amp; rhs)&#123; int totallen = len + rhs.getLen(); Mystring str(totallen); int i = 0; for(;i&lt;len;i++) str[i] = mystring[i]; for(int j = 0;j&lt;rhs.getLen();i++,j++) str[i] = rhs[j]; str[totallen] = '\\0'; return str;&#125;void Mystring::operator+=(const Mystring&amp; rhs)&#123; int totallen = len + rhs.getLen(); Mystring str(totallen); int i = 0; for(;i&lt;len;i++) str[i] = mystring[i]; for (int j = 0; j &lt; rhs.getLen(); i++, j++) str[i] = rhs[j]; str[totallen] = '\\0'; *this = str;&#125;Mystring &amp;Mystring ::operator=(const Mystring &amp;rhs)&#123; delete[] mystring; len = rhs.getLen(); mystring = new char[len + 1]; for (int i = 0; i &lt; len; i++) mystring[i] = rhs[i]; mystring[len] = '\\0'; return *this;&#125; 测试： 12345678910111213141516171819202122232425int main() &#123; Mystring s1(\"initial test\"); cout &lt;&lt; \"S1:\\t\" &lt;&lt; s1.GetMyString() &lt;&lt; endl; char *temp = \"Hello World\"; s1 = temp; cout &lt;&lt; \"Now,S1 is replaced by Hello World\" &lt;&lt; endl; cout &lt;&lt; \"S1:\\t\" &lt;&lt; s1.GetMyString() &lt;&lt; endl; char s2[20]; strcpy(s2, \"; I like you!\"); cout &lt;&lt; \"S2:\\t\" &lt;&lt; s2 &lt;&lt; endl; s1 += s2; cout &lt;&lt; \"S1+S2:\\t\" &lt;&lt; s1.GetMyString() &lt;&lt; endl; cout &lt;&lt; \"S1[4]:\\t\" &lt;&lt; s1[4] &lt;&lt; endl; s1[4] = 'x'; cout&lt;&lt;\"now s1[4] is repalced by x\"&lt;&lt;endl; cout &lt;&lt; \"S1:\\t\" &lt;&lt; s1.GetMyString() &lt;&lt; endl; cout &lt;&lt; \"S1[999]:\\t\" &lt;&lt; s1[999] &lt;&lt; endl; Mystring s3(\" Another myString\"); cout &lt;&lt; \"S3:\\t\" &lt;&lt; s3.GetMyString() &lt;&lt; endl; Mystring s4; s4 = s1 + s3; cout &lt;&lt; \"S1+S3:\\t\" &lt;&lt; s4.GetMyString() &lt;&lt; endl; return 0; &#125;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"数据的共享与保护","slug":"Cpp/4.数据的共享与保护","date":"2020-01-24T14:02:45.000Z","updated":"2020-09-04T15:07:21.545Z","comments":true,"path":"2020/01/24/Cpp/4.数据的共享与保护/","link":"","permalink":"https://aaronyard.github.io/2020/01/24/Cpp/4.%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/","excerpt":"一、标识符的作用域与可见性 二、对象的生存期1. 静态生存期 这种生存期与程序的运行期相同。 在文件作用域中声明的对象具有这种生存期。 在函数内部声明静态生存期对象，要冠以关键字 static 。","text":"一、标识符的作用域与可见性 二、对象的生存期1. 静态生存期 这种生存期与程序的运行期相同。 在文件作用域中声明的对象具有这种生存期。 在函数内部声明静态生存期对象，要冠以关键字 static 。 2. 动态生存期 块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。 三、变量的生存期与可见性综合示例思考：在函数内部定义的普通局部变量和静态局部变量在功能上有何不同？计算机底层对这两类变量做了怎样的不同处理？ 局部作用域中的静态变量： 不会随着每次函数的调用而产生一个副本，也不会随着函数的返回而失效，定义时未指定初值的会被以0初始化 局部作用域中的全局变量：诞生于声明点，结束于声明所在块执行完毕之时，并且不指定初值意味着初值不确定 四、类的静态成员 static静态成员函数/变量本质上是全局函数/变量，哪怕一个对象都不存在，类的静态成员都还是存在的。那为什么还要设置静态成员而不直接设置成全局函数/变量呢？ 是为了将和某些类紧密相关的全局变量和函数写到类里面，使其看上去像一个整体，便于维护和理解。 注：私有的静态成员在类外依然不能访问 1. 静态成员变量 12345class A&#123; int n; static int s;&#125;int A :: s = 2; //类外初始化 所有对象共享，维护同一个副本，即对象 n1 修改其值，对象 n2 中的值也会改变。 sizeof(A) = 4；sizeof不会计算静态成员变量 静态成员变量必须在类外进行一次说明或初始化，否则编译能通过但链接不能通过 2. 静态成员函数普通成员函数必须具体作用于某个对象（即通过 对象名. 访问），而静态成员函数并不具体作用于某个对象，不需要通过对象就能访问。静态成员函数的访问方式： 类名::成员名（无须对象，直接通过类名访问） 1Point::showCount(); 对象名.成员名 12A a; a.s( ); 但并不意味着只作用于a上面 指针-&gt;成员名 12A *p; p-&gt;s( ); 但并不意味着只作用于a上面 引用.成员名 12A &amp;q = a; q.s( ); 但并不意味着只作用于a上面 注：静态成员函数要访问非静态成员变量必须通过对象名. 12345678910class A&#123; int x;public: static void func(A a) &#123; cout &lt;&lt; x; //ERROR!!! cout &lt;&lt; a.x; &#125;&#125; 五、类的友元 friend 1. 友元函数 2. 友元类特别注意：友元关系不能继承；不能传递；单向 ！ 六、共享数据的保护 (const） Java 中没有 const 关键字，与之替代的是 final 1. 常对象用 const 修饰的对象 常量对象的值不可被修改 常量对象不能执行非常量成员函数，因为非常量成员函数有可能对成员变量进行修改； 常量对象可以执行常量成员函数 例： 1234567891011class A&#123; public: A(int i, int j)&#123; x = i; y = j; &#125; private: int x, y;&#125;;A const a(3,4); //常对象a,不能被更新 2. 常成员用 const 修饰的对象成员 常成员函数例：常成员函数执行期间不应该修改其所作用的对象，即 在常量成员函数中不能修改成员变量的值(静态成员变量除外） 也不能调用同类的非常量成员函数（静态成员函数除外） 例： 1234567891011121314class A&#123; public: int value; void setValue() const; void func();&#125;void A :: setValue()&#123; value = 0; //wrong 常量成员函数中不能修改成员变量的值 func(); //wrong 常量成员函数中不能调用同类的非常量成员函数&#125; const A a;a.value = 100; //wrong 常量对象的值不可被修改a.func(); //wrong 常量对象不能执行非常量成员函数a.setValue(); //right 常量对象可以执行常量成员函数 常数据成员使用 const 说明的数据成员 常数据成员 const 只能通过构造函数的初始化列表来获得初值 静态常数据成员 static const 在类外进行说明和初始化 例： 3. 常引用当需要对象作为参数时，生成该参数需要调用复制构造函数，效率比较低，用指针做参数，代码会比较不好看，所以用对象的引用做参数void func(A &amp;a)使用对象引用作参数有一定的风险性，若函数中修改了形参a，则实参也跟着变，有时候这可能不是开发者想要的。若不想要对象发生改变，则使用const限定：void func(const A &amp;a)例：","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"类与对象","slug":"Cpp/3.类与对象","date":"2020-01-23T14:02:45.000Z","updated":"2020-09-04T15:07:58.968Z","comments":true,"path":"2020/01/23/Cpp/3.类与对象/","link":"","permalink":"https://aaronyard.github.io/2020/01/23/Cpp/3.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"一、面向对象程序设计的基本特点 二、类成员的访问控制public类外(main()函数)不能访问 private 和 protected 类型，只能访问声明 public 的对外接口 private类开头若不加访问权限，则默认为private类型 可被基类的成员函数访问 可被基类的友元函数访问","text":"一、面向对象程序设计的基本特点 二、类成员的访问控制public类外(main()函数)不能访问 private 和 protected 类型，只能访问声明 public 的对外接口 private类开头若不加访问权限，则默认为private类型 可被基类的成员函数访问 可被基类的友元函数访问 protected 可被基类的成员函数访问 可被基类的友元函数访问 派生类的成员函数可以访问 当前对象 基类的protected成员 举例如下： 1234567891011121314151617181920212223242526class A&#123; public: int c; private: int b; protected: int a;&#125;;class B: public A&#123; void func()&#123; c = 1; //right b = 1; //wrong a = 1; //right B f; f.a = 1 //wrong f是新构造的对象，不是func()面向的当前对象 &#125;&#125;int main()&#123; B boo; A aoo; aoo.b = 1 ; //worng aoo.a = 1; //wrong boo.b = 1; //wrong boo.a = 1; //wrong aoo.c = 1; //right boo.c = 1; //right return 0;&#125; 三、构造函数/析构函数/复制构造函数1. 构造函数：构造函数的作用：在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。 1234567class Complex&#123; public: Complex(double r, double i = 0);&#125;;Complex c1; //错误，缺乏不带参数的构造函数//若Complex(double r = 0, double i = 0);则可以执行，即缺省函数Complex(2,1); //right 可以有多个构造函数（参数类型/个数不同),但只能有一个析构函数（可把delete语句放在析构函数中，先被构造的对象最后被析构掉）。 1234Test *pArray[3] = &#123;new Test(4), new Test(1,2)&#125;;//new Test()返回 Test* 类型，即用地址初始化指针数组；//只生成两个对象，调用两个构造函数//若无new,则不会调用相应的构造函数，指针不会引发对象生成 🚩 注 ： 构造函数 不能被派生类继承 2. 析构函数: 析构函数和构造函数的调用顺序遵循原则：先被构造的函数后被析构掉 1234567891011121314151617181920212223242526272829303132333435class Demo&#123; int id;public: Demo(int i) &#123; id = i; cout &lt;&lt; \"id=\" &lt;&lt; id &lt;&lt; \" Constructor\" &lt;&lt; endl; &#125; ~Demo() &#123; cout &lt;&lt; \"id=\" &lt;&lt; id &lt;&lt; \" Destructor\" &lt;&lt; endl; &#125;&#125;;Demo d1(1); //率先创建void Func()&#123; static Demo d2(2); Demo d3(3); cout &lt;&lt; \"Func\" &lt;&lt; endl;&#125;int main()&#123; Demo d4(4); d4 = 6; //6被自动转换成一个Demo的*临时对象*，同时调用构造函数和析构函数 cout &lt;&lt; \"main\" &lt;&lt; endl; &#123; Demo d5(5); &#125; //作用域 Func(); cout &lt;&lt; \"main ends\" &lt;&lt; endl; return 0;&#125; 运行结果： id=1 Constructorid=4 Constructorid=6 Constructorid=6 Destructor //d4 = 6临时对象的消亡mainid=5 Constructorid=5 Destructorid=2 Constructorid=3 ConstructorFuncid=3 Destructormain endsid=6 Destructor //Demo d4对象的消亡id=2 Destructorid=1 Destructor 3. 复制构造函数：复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。 复制构造函数被调用的三种情况： 用类的一个对象取初始化另一个对象时； 函数的返回值是类的对象，函数执行完成返回调用者时； 123456789Point g()&#123; Point a(1,2); return a; &#125;int main()&#123; Point b; b = g(); return 0;&#125; a是g( )的局部对象，离开g( )之后就消亡了，不可能再返回主函数后继续生存。所以这种情况下系统会创建一个临时无名对象，该临时对象的生存期只存在于函数调用所处的表达式中，即 b = g( )中。执行语句 return a ，实际上是调用复制构造函数将a的值复制到临时对象中，函数g( )运行结束时对象a消亡，但临时对象会存在于表达式 b = g( ) 中，计算完这个表达式，临时对象也就自动消亡了。 函数的形参是类的对象，调用函数进行形参和实参结合时； **举例如下：** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Point&#123; //Point 类的定义public: Point(int xx = 0, int yy = 0) //构造函数，内联 &#123; x = xx; y = yy; &#125; Point(const Point &amp;p); //复制构造函数 void setX(int xx) &#123; x = xx; &#125; void setY(int yy) &#123; y = yy; &#125; int getX() const &#123; return x; &#125; //常函数（第5章） int getY() const &#123; return y; &#125; //常函数（第5章）private: int x, y; //私有数据&#125;;//复制构造函数的实现Point::Point(const Point &amp;p)&#123; x = p.x; y = p.y; cout &lt;&lt; \"Calling the copy constructor \" &lt;&lt; endl;&#125;//形参为Point类对象void fun1(Point p)&#123; cout &lt;&lt; p.getX() &lt;&lt; endl;&#125;//返回值为Point类对象Point fun2()&#123; Point a(1, 2); return a;&#125;int main()&#123; Point a(4, 5); Point b(a); //用a初始化b。 cout &lt;&lt; b.getX() &lt;&lt; endl; fun1(b); //对象b作为fun1的实参 b = fun2(); //函数的返回值是类对象 cout &lt;&lt; b.getX() &lt;&lt; endl; return 0;&#125; 拷贝构造函数和赋值运算符（=）有啥不同？ 赋值运算符作用于一个已存在的对象； 拷贝构造函数会创建一个新对象。 四、类的组合注意以下代码的构造函数和复制构造函数的调用顺序（原则：内嵌类先构造） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Point&#123; //Point类定义public: Point(int xx = 0, int yy = 0) &#123; x = xx; y = yy; cout&lt;&lt;\"constructor of Point!\"&lt;&lt;endl; &#125; Point(Point &amp;p); int getX() &#123; return x; &#125; //用于让其他类获得私有成员的值 int getY() &#123; return y; &#125;private: int x, y;&#125;;//复制构造函数的实现Point::Point(Point &amp;p)&#123; x = p.x; y = p.y; cout &lt;&lt; \"Calling the copy constructor of Point\" &lt;&lt; endl;&#125;//类的组合class Line&#123; //Line类的定义public: //外部接口 Line(Point xp1, Point xp2); Line(Line &amp;l); double getLen() &#123; return len; &#125;private: //私有数据成员 Point p1, p2; //按照此顺序调用构造函数 double len;&#125;;//组合类的构造函数Line::Line(Point xp1, Point xp2) : p2(xp2), p1(xp1) //仍然按照p1,p2的顺序调用构造函数&#123; cout &lt;&lt; \"Calling constructor of Line\" &lt;&lt; endl; double x = static_cast&lt;double&gt;(p1.getX() - p2.getX()); double y = static_cast&lt;double&gt;(p1.getY() - p2.getY()); len = sqrt(x * x + y * y);&#125;//组合类的复制构造函数Line::Line(Line &amp;l) : p1(l.p1), p2(l.p2)&#123; cout &lt;&lt; \"Calling the copy constructor of Line\" &lt;&lt; endl; len = l.len;&#125;//主函数int main()&#123; Point myp1(1, 1), myp2(4, 5); //建立Point类的对象 Line line(myp1, myp2); //建立Line类的对象 Line line2(line); //利用复制构造函数建立一个新对象 cout &lt;&lt; \"The length of the line is: \"; cout &lt;&lt; line.getLen() &lt;&lt; endl; cout &lt;&lt; \"The length of the line2 is: \"; cout &lt;&lt; line2.getLen() &lt;&lt; endl; return 0;&#125; 五、结构体和联合体struct union例如：使用联合体保存成绩信息，并且输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class ExamInfo&#123;private: string name; //课程名称 enum &#123; GRADE, PASS, PERCENTAGE &#125; mode; //计分方式 union &#123; char grade; //等级制的成绩 bool pass; //只记是否通过课程的成绩 int percent; //百分制的成绩 &#125;;public: //三种构造函数，分别用等级、是否通过和百分初始化 ExamInfo(string name, char grade) : name(name), mode(GRADE), grade(grade) &#123;&#125; ExamInfo(string name, bool pass) : name(name), mode(PASS), pass(pass) &#123;&#125; ExamInfo(string name, int percent) : name(name), mode(PERCENTAGE), percent(percent) &#123;&#125; void show();&#125;;void ExamInfo::show()&#123; cout &lt;&lt; name &lt;&lt; \": \"; switch (mode) &#123; case GRADE: cout &lt;&lt; grade; break; case PASS: cout &lt;&lt; (pass ? \"PASS\" : \"FAIL\"); break; case PERCENTAGE: cout &lt;&lt; percent; break; &#125; cout &lt;&lt; endl;&#125;int main()&#123; ExamInfo course1(\"English\", 'B'); ExamInfo course2(\"Calculus\", true); ExamInfo course3(\"C++ Programming\", 85); course1.show(); course2.show(); course3.show(); return 0;&#125; 六、C++中的 . 操作符与 -&gt; 操作符1234567891011121314struct Person&#123; String name; String born; double money;&#125;;Person A;Person *B = new Person;A.name = \"Dr.nothing\";B-&gt;name = \"Dr.something\"; //B-&gt;name = (*B).nameA.money = 300.0;(*B).money = 30; 若是使用到 -&gt; 操作符则左边的变量必须是指针变量； 若是使用到 . 操作符那么左边的变量不能为指针，指针变量需要使用 * 操作符访问到该地址的内容","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"函数","slug":"Cpp/2.函数","date":"2020-01-22T14:02:45.000Z","updated":"2020-09-04T15:07:55.415Z","comments":true,"path":"2020/01/22/Cpp/2.函数/","link":"","permalink":"https://aaronyard.github.io/2020/01/22/Cpp/2.%E5%87%BD%E6%95%B0/","excerpt":"一、函数定义和调用 二、函数的递归调用1. Hanoi 问题从经典的 汉诺塔Hanoi 问题入手 思路如下：","text":"一、函数定义和调用 二、函数的递归调用1. Hanoi 问题从经典的 汉诺塔Hanoi 问题入手 思路如下： 1234567891011void hanoi(int n, char A, char B, char C)&#123; if (n == 1) move(A, C); else &#123; hanoi(n - 1, A, C, B); //将上面的n-1个借助C从A移动到B move(A, C); //将最下面一个从A移到C hanoi(n - 1, B, A, C); //将n-1个从B借助A移动到C &#125;&#125; 具体代码： 1234567891011121314151617181920212223242526//将src针的最上面一个盘子移动到dest针上void move(char src, char dest) &#123; cout &lt;&lt; src &lt;&lt; \" --&gt; \" &lt;&lt; dest &lt;&lt; endl; &#125; //将n个盘子从src针移动到dest针，以medium针作为中转void hanoi(int n, char src, char medium, char dest)&#123; if (n == 1) move(src, dest); else &#123; hanoi(n - 1, src, dest, medium); move(src, dest); hanoi(n - 1, medium, src, dest); &#125;&#125;int main()&#123; int m; cout &lt;&lt; \"Enter the number of diskes: \"; cin &gt;&gt; m; cout &lt;&lt; \"the steps to moving \" &lt;&lt; m &lt;&lt; \" diskes:\" &lt;&lt; endl; hanoi(m, 'A', 'B', 'C'); return 0;&#125; 当函数发生递归调用时，同一个局部变量在不同递归深度上可以同时存在不同的取值，这在底层是如何做到的？答：对同一个函数的多次不同调用中，编译器会为函数的形参和局部变量分配不同的空间，他们互不影响。 2. 递归练习① 递归逆序打印字符串1234567891011// function to reverse a stringvoid stringReverse( string stringToReverse, int startSubscript )&#123; // return when null character is encountered if ( startSubscript == stringToReverse.length() ) return; // recursively call stringReverse with new substring stringReverse( stringToReverse, startSubscript + 1 ); cout &lt;&lt; stringToReverse[ startSubscript ]; // output character&#125; // end function stringReverse ② 递归查询最小元素12345678910111213141516// function to recursively find minimum array elementconst int MAXRANGE = 1000;int recursiveMinimum( const int array[], int low, int high )&#123; static int smallest = MAXRANGE; // if first element of array is smallest so far // set smallest equal to that element if ( array[ low ] &lt; smallest ) smallest = array[ low ]; // if only one element in array, return smallest // else recursively call recursiveMinimum with new subarray return low == high ? smallest : recursiveMinimum( array, low + 1, high );&#125; 三、函数的参数传递 在函数被调用时才给形参分配存储单元 实参可以是常量、变量或表达式 实参类型必须和形参类型相符 值传递是传递参数值，形参的改变不会引起实参的改变，即单向传递 引用传递可以实现双向传递 常引用作参数可以保障实参数据的安全 1. 值传递传递参数值，单向传递 2. 引用传递（需要修改形参值的时候使用）我们常用的交换函数就需要用到引用传递，实现双向传递，修改传进来的形参值 1234void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp; 学习 引用传递 需详细掌握以下 引用 的知识 ① 变量的引用123456789int &amp;r = n;某个变量的引用，等价于这个变量（即同一个人，不管谁发生改变，另一个也会随之改变）int n = 7;int &amp;r = n; //定义引用时一定要将其初始化引用某个*变量*r = 4;cout&lt;&lt;r; //4cout&lt;&lt;n; //4n = 5;cout&lt;&lt;r; //5 123456int a = 4;int b = 5;int &amp;r1 = a;int &amp;r2 = r1; //等价于 int &amp;r2 = a; r2也引用ar2 = 10;cout&lt;&lt;a; //10 一旦一个引用被初始化后，就不能改为指向其他对象 123456int a = 4;int b = 5;int &amp;r1 = a;//*一个引用是从一而终的*，该语句并不表示r1引用了b，而是b的值赋给了r1r1 = b; cout&lt;&lt;a; //5 ② 引用作为函数的返回值12345678int n = 4;int &amp;setValue()&#123; //返回了n的引用 return n;&#125;int main()&#123; setValue() = 40; //函数返回的是n的引用，所以可以作为左值被赋值 cout&lt;&lt;n; //给n的引用赋值40 等价于 给n赋值40&#125; ③ 常引用const int &amp;r = n; 不能通过常引用去修改其引用的内容 1234int n = 100;const int &amp;r = n;r = 50; //wrongn = 49; //right n的引用r的值也随之改变 三、内联函数 声明时使用关键字 inline 编译时在调用处用函数进行替换，节省了参数传递、控制转移等开销 注意：内联函数体内不能有循环语句和 switch 语句 内联函数的调用过程： 12345inline int Max(int a, int b)&#123; if(a&gt;b) return a; return b;&#125; 假如主函数中有如下语句 1K = Max(n1,n2); 等价于 12345if(n1 &gt; n2) tmp = n1;else tmp = n2;K = tmp; 即直接把函数体嵌入到代码中，而没有函数调用的出入栈的过程。 编译器并不承诺将inline修饰的函数作为内联，而在现代编译器中，没有inline修饰的函数也可能被编译为内联 四、带默认形参值的函数（缺省函数） 在相同的作用域内，不允许在同一个函数的多个声明中对同一个参数的默认值重复定义，即使前后定义的值相同也不行。 五、函数重载（形参个数/类型不同）函数重载提高了程序的可扩充性。 (C语言中不允许同名函数，即没有重载的概念) 注：编译器不以形参名和返回值来区分重载。 若只有返回值类型不同，则不叫重载，叫重复定义 12double func(int a, string var)&#123; &#125;;int func（int x, string b)&#123; &#125;; 六、典型例题1. 数制转换 1234567891011121314151617181920double power(double x, int n); //x的n次方int main()&#123; int value = 0; cout&lt;&lt;\"please enter 8 bit binary number:\"; for(int i = 7; i&gt;=0; i--)&#123; //从高位往低位读入二进制数 char ch; cin&gt;&gt;ch; //以字符形式读取 if(ch == '1') //强转 value += static_cast&lt;int&gt;(power(2,i)); //value += (int)(power(2,i)); &#125; cout&lt;&lt;\"decimal value is \"&lt;&lt;value&lt;&lt;endl; return 0;&#125;double power(double x, int n)&#123; double sum = 1.0; while(n--) sum = sum*x; return sum;&#125; 或者用数学方式处理 1234567//以int形式读入的数学方式处理 while ( binary != 0 ) &#123; decimal += binary % 10 * bit; binary /= 10; bit *= 2; &#125; 2. 编写程序求 π 的值 12345678910111213141516171819202122232425double arctanx(double x)&#123; double sqr = x * x; //x每次都乘以x2 double e = x; //保存x的次方，分子 double sum = 0; //保存最终结果 int i = 1; //分母 int flag = 1; while (e / i &gt; 1e-15) &#123; double f = flag * e / i; sum += f; e = e * sqr; i += 2; flag = -flag; &#125; return sum;&#125;int main()&#123; //注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0 double a = 16.0 * arctanx(1 / 5.0); double b = 4.0 * arctanx(1 / 239.0); cout &lt;&lt; \"PI = \" &lt;&lt; a - b &lt;&lt; endl; return 0;&#125; 3. 掷骰子 每个骰子有六面，点数分别为1、2、3、4、5、6。游戏者在程序开始时输入一个无 符号整数，作为产生随机数的种子。 每轮投两次骰子，第一轮如果和数为7或11则为胜，游戏结束；和数为2、3或12 则为负，游戏结束；和数为其它值则将此值作为自己的点数，继续第二轮、第三轮…直到 某轮的和数等于点数则取胜，若在此前出现和数为7则为负。 此处需要用到 rand 函数,rand产生的是伪随机数，即每次运行产生的是同一串随机数序列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//投骰子、计算和数、输出和数int rollDice()&#123; int die1 = 1 + rand() % 6; int die2 = 1 + rand() % 6; int sum = die1 + die2; cout &lt;&lt; \"player rolled \" &lt;&lt; die1 &lt;&lt; \" + \" &lt;&lt; die2 &lt;&lt; \" = \" &lt;&lt; sum &lt;&lt; endl; return sum;&#125;enum GameStatus&#123; WIN, LOSE, PLAYING&#125;;int main()&#123; int sum, myPoint; GameStatus status; unsigned seed; cout &lt;&lt; \"Please enter an unsigned integer: \"; cin &gt;&gt; seed; //输入随机数种子 srand(seed); //将种子传递给rand() sum = rollDice(); //第一轮投骰子、计算和数 switch (sum) &#123; case 7: //如果和数为7或11则为胜,状态为WIN case 11: status = WIN; break; case 2: //和数为2、3或12则为负,状态为LOSE case 3: case 12: status = LOSE; break; default: //其它情况，尚无结果，状态为 PLAYING，记下点数 status = PLAYING; myPoint = sum; cout &lt;&lt; \"point is \" &lt;&lt; myPoint &lt;&lt; endl; break; &#125; while (status == PLAYING) &#123; //只要状态为PLAYING，继续 sum = rollDice(); if (sum == myPoint) //某轮的和数等于点数则取胜 status = WIN; else if (sum == 7) //出现和数为7则为负 status = LOSE; &#125; //当状态不为PLAYING时循环结束，输出游戏结果 if (status == WIN) cout &lt;&lt; \"player wins\" &lt;&lt; endl; else cout &lt;&lt; \"player loses\" &lt;&lt; endl; return 0;&#125; 4. 递归计算从n个人中选k个人不同组合数。 123456789int comm(int n, int k)&#123; if (k &gt; n) return 0; else if (n == k || k == 0) return 1; else return comm(n - 1, k) + comm(n - 1, k - 1);&#125; 5. 递归实现 getPower 计算 x的y次方此处需要考虑两种情况，x是整数 和 x是小数 ，利用重载编写两个做同样运算的函数 getPower","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"基础知识+字符串string类","slug":"Cpp/1.基础知识+字符串string类","date":"2020-01-21T14:02:45.000Z","updated":"2020-09-04T15:07:51.192Z","comments":true,"path":"2020/01/21/Cpp/1.基础知识+字符串string类/","link":"","permalink":"https://aaronyard.github.io/2020/01/21/Cpp/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86+%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%B1%BB/","excerpt":"一、面向对象/过程 1. 面向过程过程 优点： 有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护","text":"一、面向对象/过程 1. 面向过程过程 优点： 有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护 缺点： 可重用性差、数据安全性差、难以开发图形界面的应用 把数据和处理数据的过程分离为相互独立的实体。 当数据结构改变时，所有相关的处理过程都要进行相应的修改。 每一种相对于老问题的新方法都要带来额外的开销。 图形用户界面的应用，很难用过程来描述和实现，开发和维护都很困难。 2. 面向对象编程 面向对象的基本概念 对象 抽象与分类 封装 继承 多态 优点： 程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障。 通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便。 二、C++语言基础1. 信息的存储单位 2. 命名空间 若没有using namespace std 则： cout &lt;&lt; 改为 std :: cout &lt;&lt; 3. 基本数据类型 + 字符串C++的基本数据类型 bool char(字符类型) int float double 注： 基本数据类型中没有字符串类型（string） 一对 “ ” 括起来的字符序列表示 字符串（在末尾添加’\\0’作为结尾标记）， ‘ &#39; 括起来的表示 单个字符 字符串处理C++基本数据类型中没有字符串变量，存储和处理方法有两种如下： 用字符数组来存放字符串；（C风格字符串） 标准C++库预定义 string 类 4. string 类详解string类是一个模板类，它的定义如下： 1typedef basic_string string 4.1 string类的初始化• string s1(&quot;Hello&quot;); //一个参数的构造函数，用Hello初始化 • sting s2(5,&#39;x&#39;); //两个参数的构造函数，5代表x出现的次数 • string month = &quot;March&quot;; 不提供以字符和整数为参数的构造函数 string error1 = &#39;c&#39;; //error string error2 = (&#39;u&#39;); //error string error3 = 22; //error string error4(8); //error 可以将字符赋值给string对象 12string s;s = 'n'; 4.2 string 的赋值和连接① 赋值 用 = 赋值 12string s1(\"cat\"), s2;s2 = s1; 用 assign 成员函数复制 12string s1(&quot;cat&quot;),s2;s2.assign(s1); //s1赋值给s2 用assign成员函数部分复制 12string s1(\"cat\"),s2;s2.assign(s1,1,3); //从s1的下标为1的字符开始复制3个字符给s2 单个字符复制 1s2[4] = s1[3]; 使用 at 成员函数逐个访问 string 对象中的字符 123string s1 = &quot;hello&quot;;for(int i = 0; i&lt;s1.length();i++) cout&lt;&lt; s1.at(i) &lt;&lt;endl; 🚥 注：成员函数 at 会做下标范围检查，若果超出范围会抛出 out_of_range 异常，而下标运算符不做范围检查 ② 连接 用 + 连接字符串 123string s1(\"good\"),s2(\"morning!\");s1 += s2;cout&lt;&lt;s1; 用成员函数 append 连接 12345s1.append(s2);s2.append(s1,3,s1.size()); //s1.size() s1的字符数//从s1的下标3开始，连接s1.size()个的字符//若字符串内没有足够字符，则复制到s1的末尾就停止 4.3 常用方法长度 length() / size()构造的string太长无法表达 -&gt; 会抛出 length error 异常 1s.length() / s.size() 子串 substr()成员函数 substr() 1s2 = s1.substr(3,2); //下标3开始2个字符 寻找字符 find() 成员函数 find() 123456s1.find(\"lo\");//从s1中从前往后找lo第一次出现的位置，返回l所在的位置下标//若没有找到，返回string::npos（string中定义的静态常量）s1.rfind(\"lo\");//从后往前查找，返回l的位置s1.find(\"a\",2); //从下标2开始查找“a\" 成员函数 find_first_of() 查找字符第一次出现的下标 成员函数 find_last_of() 查找字符最后一次出现的地方 消除 erase()1s1.erase(3); //返回 消除下标3及以后的字符串 替换 replace()12s1.replace(2,3,\"hala\",1,2);//将s1中下标从2开始的3个字符 替换成 \"hala\"中从下标1开始的2个字符 插入 insert()12s1.insert(4,s2); //将s2插入s1下标为4的位置s1. insert(2,s2,5,3) //将s2中下标5开始的3个字符插入s1下标为2的位置 转换成C语言形式char*字符串 c_str()123s1.c_str();//返回传统的const char*类型字符串//且该字符串以'\\0'结尾 5. 运算此处就不详细解释了，就挑出了一些容易混淆的地方 当 / 用于两个整型数据相除时，其结果取商的整数部分，小数部分被自动舍弃。 int a = 1/2 —-&gt; a = 0; 逗号运算1a=3*5, a*4; —-&gt;结果为第二个表达式的值60 逻辑运算&amp;&amp; 和 || 具有短路特性。 对于&amp;&amp;，如果第一个表达式为false，则不再对第二个表达式求值； （因为无论第二个表达式为多少最后结果都为false） 对于||，如果第一个表达式为true,则不再对第二个表达式求值； (a==b) || (++c == 1) 这个表达式中c的自增只有在a!=b的时候才会执行 位运算 sizeof 运算 6. 类型转换隐含类型转换 赋值运算要求左值与右值的类型相同，若类型不同，编译系统会自动将右值转换为左值的类型。 ex: 1234float fval;double dval;unsigned long ulval;dval = ulval + fval; //ulval被转换为float类型,加法运算的最终结果被转化为double 显示类型转换 float z;强制类型转换int(z)只是将float类型变量z临时取出来转换为int型， 这时变量z所在的内存单元中的值并未真正改变。 三、算法的基本控制结构 if语句 （选择结构） switch语句（选择结构） while语句（循环结构） do while语句（循环结构） for语句（循环结构） 其他控制语句 四、enum 枚举类型语法形式： enum 枚举类型名 {变量值列表}; 例：enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}; 默认情况下 SUN=0，MON=1，TUE=2，……，SAT=6 ex： 口袋中有红、黄、蓝、白、黑五种颜色的球若干个。每次从口袋中取出3个不同颜色的球，问有多少种取法。 分析： 由于球只能是五种颜色之一，故可用枚举类型表示球的颜色。 设取出的球为 i、j、k，根据题意，i、j、k分别可以有五种取值，且i≠j≠k。 可以用穷举法，逐个检验每一种可能的组合，从中找出符合要求的组合并输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int main()&#123; enum color&#123;red,yellow,blue,white,black&#125;; color pri; //enum color pri; int n = 0; //一共有多少种情况 for (int i = red; i &lt;= black; i++) for (int j = red; j &lt;= black; j++) if (i != j) &#123; //前两个球颜色不同 for (int k = red; k &lt;= black; k++) if (k != i &amp;&amp; k != j) &#123; n = n + 1; cout.width(4); cout &lt;&lt; n; //以下代码为输出所有组合，解题核心是上面的三层嵌套循环 for (int loop = 1; loop &lt;= 3; loop++) &#123; switch (loop) &#123; case 1: pri = color(i); // (enum color) i break; case 2: pri = color(j); break; case 3: pri = color(k); break; default: break; &#125; switch (pri) &#123; case red: cout &lt;&lt; \" red\"; break; case yellow: cout &lt;&lt; \" yellow\"; break; case blue: cout &lt;&lt; \" blue\"; break; case white: cout &lt;&lt; \" white\"; break; case black: cout &lt;&lt; \" black\"; break; default: break; &#125; &#125; cout &lt;&lt; endl; &#125; &#125; cout &lt;&lt; n; return 0;&#125;","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://aaronyard.github.io/tags/C/"}]},{"title":"GameChangeClothe","slug":"GameChangeClothe","date":"2019-12-05T05:29:09.000Z","updated":"2020-04-13T12:58:08.515Z","comments":true,"path":"2019/12/05/GameChangeClothe/","link":"","permalink":"https://aaronyard.github.io/2019/12/05/GameChangeClothe/","excerpt":"","text":"换装系统游戏项目中一般都会有玩家人物的换装系统，玩家也愿意为好看的时装皮肤付款。但在我眼中时装皮肤就是一串数据，所以不会为这串数据流而花钱，接下来就解密换装系统的奥秘。 时装换装系统换的是什么？时装。 时装的别名也可叫皮肤，那他们的本质是什么呢？ 首先介绍一下玩家在游戏中所操控的玩家人物，在大部分MMORPG游戏中，玩家人物亦是一个人物对象。所谓换汤不换药，如果把一个玩家拆分一下，即可分为骨骼以及蒙皮模型。也就是说一套骨骼可以对应多个服装模型。换装实际上就是将相应的身体部分进行更换，比如要换一套衣服，就是将新的服装与身体上除了服装覆盖的模型再进行一次网格合并，换句话说，更换身体的某一个部位就是更新了整个角色模型。","categories":[],"tags":[]},{"title":"游戏项目中的热更新机制","slug":"GameUpdate","date":"2019-11-30T13:51:31.000Z","updated":"2020-04-05T12:18:12.934Z","comments":true,"path":"2019/11/30/GameUpdate/","link":"","permalink":"https://aaronyard.github.io/2019/11/30/GameUpdate/","excerpt":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。","text":"项目中的热更新机制热更新技术是指可以在不关闭游戏客户端的情况下，动态的更新游戏本身的资源。类似的服务器硬盘的“热插拔”。 目前市面上的绝大部分游戏客户端都启用了热更新技术，热更新的好处是玩家不必重新下载完整的安装包也能体验到官方的新版本资料片，减少了用户流失。 项目中安卓系统与苹果系统在热更新的机制上有一个明显的差异：苹果系统不能热更C#代码。 同样都可以进行热更新的是：AssetBundle（prefab预制体和UI界面图集等）、Table（文本，项目中的excel表格转成的二进制文件）、Lua（Lua脚本语言）、Mapfile（场景地图文件，关卡编辑器生成，项目中独有的）。 通过校验本地文件的MD5与拉取到的MD5是否一样来进行热更。 代码热更新实现方式： 1、使用Lua脚本编写游戏的UI或者其他逻辑，Lua是一个精悍小巧的脚本语言，可以跨平台运行解析，而且不需要编译过程。（热更lua） 2、使用C#Light（热更L#） 3、使用C#反射技术（热更DLL） 热更C#代码（DLL）针对C#代码热更新的机制做一个简单的概述，在安卓上可以通过C#的语言特性——反射机制实现动态代码加载从而实现热更新。 具体做法是：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。注：将这部分dll改个名字放在安卓包体中，可以防止一些别有用心的人做一些别有用心的事情。 但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。 关于C#在苹果系统上热更新的思考可以参考此处。 Lua热更新项目中使用的是ulua更新框架，不仅支持热更lua，还支持热更C#Light（L#），之所以把这两者放在一起讲是因为他们都支持安卓与苹果系统的热更新。 Lua热更新的原理：在客户端可以编写Lua的解析器，通过这个解析器，可以运行最新的Lua脚本，后期可以把控制游戏逻辑的代码都写成Lua脚本。 C#和lua中的类型可以一一对应。 Lua 和 C#中类型的对应nil null String System.String number System.Double boolean System.Boolean table Lualnterface.LuaTable function LuaInterface.LuaTable Lua中通过表来实现面向对象的一个小例子123456789101112131415161718192021222324252627282930Enemy = &#123;&#125; --申明对象loacal this = Enemy --申明this关键字代表当前对象--定义并声明对象中的属性Enemy.hp=100Enemy.speed=12--定义并声明对象中的方法Enemy.Move = function() print(\"移动\")endfunction Enemy.Attact() print(this.hp,\"攻击\") this.Move()end--执行Enemy.Attact() Lua解析器示例在C#中执行访问Lua代码12345678910111213Lua lua = new Lua(); //创建Lua解析器lua[\"num\"] = 5; //定义一个 numlua[\"str\"] = \"a string\"; //定义一个字符串lua.newTable(\"tab\"); //创建一个表 tab=&#123;&#125;//取得Lua环境中的变量double num = (double)lua[\"num\"];string str = (string)lua[\"str\"]; 在C#脚本中执行Lua脚本文件，或者脚本字符串1234567lua.DoFile(\"script.lua\");//执行script.lua脚本lua.DoString(\"num = 2\");//执行lua代码lua.DoString(\"str = 'a string'\");object[] retVals = lua.DoString(\"return num,str\"); 在热更新中，只需要写好解析Lua脚本的代码，然后C#代码不需要变动，只需要修改lua脚本就好，通过lua脚本控制游戏逻辑。 把一个C#方法注册进Lua的一个全局方法1234567891011//把一个类中的普通方法注册进去Lua.RegisterFunction(\"NormalMethod\",obj,obj.GetType().GetMethod(\"NormalMethod\"))lua.DoString(\"NormalMethod()\") //把一个类的静态方法注册进去lua.RegisterFunction(\"StaticMethod\",null,typeof(ClassName).GetMethod(\"StaticMethod\"))lua.DoString(\"StaticMethod()\") 在Lua中使用C#脚本123456789101112131415require \"luanet\" --引入库，相当于 import--加载CLR的类型、实例化CLR对象luanet.load_assembly(\"System.Windows.Forms\")luanet.load_assembly(\"System.Drawing\") --表示加载了一个dll，理解为加载了system.drawing的命名空间Form = luanet.import_type(\"System.Windows.Forms.Form\") --表示引入了System.Windows.Forms下的一个类FormStartPosition = luanet.import_type(\"System.Windows.Forms.FormStartPosition\")print(Form)print(StartPosition) 在Lua中使用C#中的类创建对象的时候，会自动匹配最合适的构造方法。 在Lua中访问C#中的属性和方法Lua代码中，访问C#对象的属性的方法和访问table的键索引一样，比如obj.name 或者 obj[“name”] Lua代码中，访问C#对象的普通函数的方式和调用table的函数一样，如：obj:method() 注：在Lua中访问C#中的方法 - 特殊情况 当函数中有out或者ref参数时，out参数和ref参数和函数的返回值一起返回，并且调用的时候，out参数不需要传参。 AssetBundle热更新AssetBundle是一个特定于平台的资产压缩包，资产包括Models、Textures、Prefabs、Audio clips等，每个不同的平台打包出来的AssetBundle不同。AssetBundle的热更新是unity官方支持的。 选择需要打包的资源，在inspector视图底部，找到AssetBundle选项，默认是None，选项卡选择NEW，输入自定义的AssetBundle名称，后面第二个选项卡是AssetBundle的后缀名，可选可不选，如果你使用了后缀，那么加载AssetBundle的时候需要带上后缀名。如果创建的标签是window标签，那么所有window标签的资源会打到一起window AssetBundle。也就是说，Unity会自动把相同标签的资源打包成一个整体。 使用官方提供的API打AB以及加载AB，BuildPipeline.BuildAssetBundles这个API，参数一是打包后AssetBundle的存放路径，参数二是压缩方式，参数三是打包的平台。 1public static AssetBundleManifest BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform); 本地加载，如果你设置的AssertBundle有后缀名，比如后缀是unity3d，则AssertBundle名需要加后缀，如Capsule.unity3d 1234AssetBundle ab = AssetBundle.LoadFromFile(\"Assets/AssetBundles/Android/cube\");if(ab != null)&#123; Instantiate(ab.LoadAsset&lt;GameObject&gt;(cube))&#125; 网络加载 1234567891011IEnumerator InstantiateObject()&#123; string uri = \"file:///\" + Application.dataPath + \"/AssetBundles/\" + assetBundleName; UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); yield return request.Send(); AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(\"Cube\"); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(\"Sprite\"); Instantiate(cube); Instantiate(sprite);&#125; 动态load资源的几种途径： 通过Resources模块，调用它的load函数：可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不关有没有场景引用，都会将其全部打入到安装包中。 通过bundle的形式：即将资源打成 AssetBundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object。（AssetBundle热更的前提和基础） 通过AssetDatabase.loadasset ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。 关于AssetBundle的分组，有必要仔细思考一下，在这里分享下之前公司经历过的一个项目的真实案例。在项目开发的前期，没有注意AssetBundle的分组策略，采用的是一个UI界面一个AssetBundle，在项目的后期却怎么也打不出来包，折腾了一两天之后才终于发现这是unity官方的bug，AssetBundle包有一个数量上的限制，不能突破这个限制，于是我们修改了AssetBundle的分组策略，改为了所有UI界面一个包才最终规避了这个问题。 可以参考官方提供的分组策略： 逻辑实体分组： 一个UI界面或者所有UI界面一个包； 一个角色或者所有角色一个包； 所有场景所共享的部分一个包。 类型分组：比如Models一个包、Audio clips一个包等。 使用分组： 把在某一时间内使用的所有资源打成一个包； 把同一关卡的所有资源打成一个包； 一个场景一个包。 原则 经常更新的资源与不经常更新的资源拆分离为两个包； 把需要同时加载的资源放在同一个包； 把其他包共享的资源放在一个单独的包里面； 把一些需要同时加载的小资源打包成一个包； 如果对于同一个资源有两个版本，可以考虑通过后缀来区分。 热更文本（项目中的表格、json文件等）一般的项目中，为了方便配置控制游戏中的数值以及文本，会使用excel表格填写数据，利用python脚本将其转换成json或者二进制文件供客户端读取。文本不需要编译过程，如果遇到了相关数据的改动，更新相关文件即可。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Client","slug":"3D-Client","permalink":"https://aaronyard.github.io/tags/3D-Client/"}]},{"title":"上帝掷骰子吗？（一）","slug":"History-of-quantum-physics-1","date":"2019-11-28T14:53:10.000Z","updated":"2019-11-28T15:38:21.052Z","comments":true,"path":"2019/11/28/History-of-quantum-physics-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/History-of-quantum-physics-1/","excerpt":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。","text":"回归到搭建这篇博客的初衷，我要开始写下一些关于量子物理的有趣的事情。 物理学的黄金时代一些关于在确立量子物理这个时代主题之前的事情，这个“之前”，就要从19世纪末说起了。那是物理学的黄金时代，那时还在争论光的本质到底是什么、一个科学与神共存的时代。 在那个时代，关于光的本质的问题，物理学上的大佬们喋喋不休的争论了前后几百年。两个主要派系分别主导着这场没有硝烟的战争：微粒派和波动派。 在微粒派和波动派彻底成形之前，远古以来，对于光的猜测一直没有停歇。 最初，人们猜想，光是一种从我们的眼睛里发射出去的东西，当它到达某样事物的时候，这样事物就被我们所“看见”了。恩培多克勒（Empedocles）就认为世界是由水、火、气、土四大元素组成的，而人的眼睛是女神阿芙罗狄忒（Aphrodite）用火点燃的，当火元素（也就是光。古时候往往光、火不分）从人的眼睛里喷出到达物体时，我们就得以看见事物。 到了罗马时代，学者卢克莱修（Lucretius）在《物性论》中提出，光是从光源直接到达人的眼睛的。不过当时的人们并不相信，直到公元1000多年，小孔成像的实验最终证明了这个说法是对的。 欧几里德（Euclid）、托勒密（Ptolemy）、哈桑和开普勒（Johannes Kepler）都参与研究光的性质，于是在前人的基础上，荷兰物理学家斯涅耳（W.Snell）总结出了光的折射定律了。 最后，“业余数学之王”费尔马（Pierre de Fermat）总结为“光总是走最短的路线”。 光学终于作为一门物理学科被正式确立起来，微粒派和波动派开始了无硝烟的战争。 微粒说：光是由一粒粒非常小的“光原子”所组成的，从直观上看来是很有道理的，首先它就可以很好地解释为什么光总是沿着直线前进，为什么会严格而经典地反射，甚至折射现象也可以由粒子流在不同介质里的速度变化而得到解释。 波动说：光不是一种物质粒子，而是由于介质的振动而产生的一种波。光的波动说容易解释投影里的明暗条纹，也容易解释光束可以互相穿过互不干扰。关于直线传播和反射的问题，人们很快就认识到光的波长是很短的，在大多数情况下，光的行为就犹同经典粒子一样。而衍射实验则更加证明了这一点。 但他们也有各自的缺点 微粒说很难说清为什么两道光束相互碰撞的时候不会互相弹开，人们也无法得知，这些细小的光粒子在点上灯火之前是隐藏在何处的，它们的数量是不是可以无限多，等等。 波动说有一个基本的难题，那就是任何波动都需要有介质才能够传递，那星光是怎么穿过太空的呢？于是波动说假设了一种看不见摸不着的介质“以太”（Aether）来实现光的传播。 小故事“业余数学之王”费尔马”业余玩家可以挑战职业选手吗?在数学王国,费马先生给出了答案. 费马被誉为“业余数学之王”,因为他的本职工作是一名律师,数学只是他的业余爱好.但是他在数学上的成就一点也不比职业数学家差,也远远超过了他作为律师的影响力.他当初是不是选错行了呢? 费马出生在一个富裕的家庭,家境殷实.费马的爹是一名大皮革商,为费马提供了富裕舒适的成长环境,从小就有两个家庭教师教学这种高端配置,一点也不用担心落下功课!也许正是这两位无名的家庭教师,让费马对数学有了强烈的兴趣. 数学有许许多多的分支,不可能全部都研究,费马选定了自己的主要研究方向——数论.数论是数学上一个非常坑的分支,研究的是看起来非常简单的整数.前辈们在这个领域留下了一个个精彩的猜想,任何了解整数基本运算的人都可以理解,但是要证明这些猜想却非常困难,只要证明一个就能名垂青史.这让无数有雄心壮志的人跳进了数论这个大坑,可是只有费马一个人从坑里爬了出来。 以太亚里士多德所谓的“第五元素”，他认为日月星辰围绕着地球运转，但其组成却不同与地上的四大元素水火气土。天上的事物应该是完美无缺的，它们只能由一种更为纯洁的元素所构成—以太。 未完待续。。。","categories":[{"name":"日常阅读","slug":"日常阅读","permalink":"https://aaronyard.github.io/categories/%E6%97%A5%E5%B8%B8%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"量子物理史话","slug":"量子物理史话","permalink":"https://aaronyard.github.io/tags/%E9%87%8F%E5%AD%90%E7%89%A9%E7%90%86%E5%8F%B2%E8%AF%9D/"}]},{"title":"3D游戏引擎初探（三）","slug":"3D-Engine-3","date":"2019-11-28T14:11:31.000Z","updated":"2019-11-28T14:14:25.908Z","comments":true,"path":"2019/11/28/3D-Engine-3/","link":"","permalink":"https://aaronyard.github.io/2019/11/28/3D-Engine-3/","excerpt":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。","text":"数学相关知识在3D游戏引擎中会涉及到数学的相关知识，具体可以划分到线性代数：向量、矩阵、齐次坐标系、四元数。 向量假设大家都已经对向量最基本的加法、减法、点乘、叉乘、单位化都是有了解的，简单介绍一下这些基础计算在游戏引擎中是如何应用的。 向量的加法在最开始学向量的时候大家已经知道，向量的加法遵循三角形法则和平行四边形法则，在构建游戏世界的过程中用到了向量加法的几何意义。比如游戏中怪物追击玩家的AI中，怪物知道玩家的位置，需要时时刻刻朝向玩家移动，就会在每帧运用向量的加法向玩家移动。 向量的减法向量的减法作为加法的你逆运算，集合意义也是可以用在方向的计算上，另外它还能判断两个物体之间的距离。比如游戏中怪物的追击机制有一个判断条件，那就是距离玩家大于一定的距离后才会进行追击，小于一定距离之后就不再朝向玩家移动，这是就用到了向量的减法。 向量的点乘点乘主要用在了角度的计算和材质的渲染， 判断目标在自己的前后方位 。还是以怪物追击玩家为例子，刚刚只说了追击过程中的位置移动，但是怪物和玩家都是有正面朝向的，不然玩家看到怪物背对着玩家人物进行追击会觉得怪怪的，这时就需要怪物将自己的正面转向玩家。转的角度是多少呢？此时就需要用到向量的点乘进行计算了。 也能用来判断两个向量是否垂直、计算一个向量在另一个向量上的投影分量大小 。再说材质的光照渲染，通俗意义上讲就是光线照射后的明暗效果。现实世界中不规则的材质表面接受光线照射后是有不同的表现的，从数学的几何角度上来解释就是：在shader中，当材质表面的顶点法向量与光线向量的角度（即两个向量的点积）大于90度时就不接受光线的渲染，反之亦然。 向量的叉乘1、叉乘可以用来判断两个向量是否平行或相交。返回值为0，则平行。 2、用于求平面法线（叉乘的几何意义：absinθ） 3、计算两个物体之间形成四边形的面积（|a||b|sinθ） 4、 判断目标在自己的左右方位 关于向量的点乘和叉乘容易混淆的问题，可以这么理解： 点乘判断角度，叉乘判断方向。 向量的单位化向量的单位化计算的是物体间的距离，这个就不必多做介绍了。 矩阵未完待续。。。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（二）","slug":"3D-Engine-2","date":"2019-11-27T14:29:36.000Z","updated":"2019-11-27T14:47:21.966Z","comments":true,"path":"2019/11/27/3D-Engine-2/","link":"","permalink":"https://aaronyard.github.io/2019/11/27/3D-Engine-2/","excerpt":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。","text":"3D游戏引擎架构最底层渲染模块的图形库接口。目前游戏引擎最常用的渲染模块是微软的DirectX库或者开源跨平台的OPENGL和OPENGLES图形库。项目中使用的是Windows的GDI接口，只针对Windows操作系统。 中间层封装好的3D游戏引擎，可以理解为功能的控制模块。可细分为：声音模块、渲染模块、图形系统、UI系统、特效系统、管理系统、物理系统、数据系统、输入系统、内存管理。 最上层游戏开发人员所用到的游戏逻辑，一般情况下是调用引擎封装好的接口编写游戏所需要的逻辑。 各层关系最底层的图形库接口关系到了整个游戏将可以在哪个平台下运行，GDI是专用于Windows平台的图形库，故而只适合在Windows中运行游戏。若想在其它平台中运行，则需要对底层的渲染模块的图形库接口做兼容。 中间层的3D游戏引擎和上层的游戏逻辑其实是相辅相成的，游戏引实质是从游戏逻辑中提取出来的共用的功能。比如unity3D、虚幻4引擎、第一家入职公司自主开发的小胖引擎等等，都是把游戏最基础的图形图像光照处理等游戏逻辑提取了出来，方便开发人员编写游戏时调用，不必在开发新游戏的前期大费周章的再次编写这些底层逻辑。从而把游戏开发的重点转移到了游戏逻辑上，大大提高的开发新游戏的效率，降低了开发新游戏所需要的周期。 由此来看，自主开发的引擎或者说开源的引擎有一个优点，在游戏逻辑开发的过程中如果发现有什么需要新加或者优化的逻辑，可以直接写在引擎中，提供给游戏逻辑层一个调用的接口即可。从根本上尽量避免代码重复，代码遵循统一的风格。所以可以说：游戏引擎为游戏逻辑的开发提供了方便，游戏逻辑的开发优化了游戏引擎的完整性。 所需条件开发一款游戏需要什么条件呢？一共有四条。 语言掌握一门主流的开发语言，本项目使用的是C++语言。 这里不得不说一下C++语言的优势了 1、 C++实现了面向对象程序设计。在高级语言当中，处理运行速度是最快的，大部分的游戏软件，系统都是由C++来编写的。 2、 C++语言非常灵活，功能非常强大。如果说C语言的优点是指针，那么C++的优点就是性能和类层次结构的设计。 3、C++非常严谨、精确和数理化，标准定义很细致。 4、 C++语言的语法思路层次分明、相呼应;语法结构是显式的、明确的。 当然，这只是C++的一部分优势，在运用过程中，我们会逐渐发现C++语言之美。 线性代数在开发引擎的过程中，数学同样很重要。线性代数在游戏的开发过程中可以灵活的解决3D固定流水线中的大部分操作，物体的移动。旋转、缩放、光照等都运用到了数学原理。 GPU编程语言3D游戏引擎的核心功能就是对游戏的场景渲染和物体的材质渲染，对材质中有Alpha通道的要做特殊处理（Alpha通道是材质有透明的部分）。移动端为了减少透明材质的消耗，会通过GPU编程在shader中处理，比如unity项目中一般会把有Alpha通道的图片切割为无Alpha通道和有Alpha通道的图片，通过shader编程将其再合在一起，还有场景渲染使用的后处理效果，模型的选中效果等，都是与GPU编程息息相关的，至少需要了解和使用GPU编程语言中的一种，目前有GLSL、HLSL、CG等。 图形学算法逼真的效果需要适合的图形学算法，比如水的波纹的模拟中用到的波动方程，刚体碰撞效果等，都会用到图形学算法。 先后顺序会从最基础最底层的知识开始学习了解： 数学知识游戏世界所运用到的线性代数的相关知识，领略数学之美。 材质和光照我们就是游戏中创造万物的造物主，首先创造什么？当然是光啦！ 固定流水线晶体管中的二进制数据是如何渲染到屏幕上供我们所观看呢？固定流水线会为你解密这一切。 游戏引擎架构将功能模块进行细分，分步实现，为下一步的整合做好前期准备。 3D游戏引擎的底层架构和封装用计算机语言实现每个功能模块，享受制作引擎工具的乐趣，这就是你手中的模板，用它就能创造一个又一个不同的游戏世界。 游戏逻辑引擎已经搭建完毕了，那么下一步就是进一步搭建可以与玩家互动的游戏世界啦。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"3D游戏引擎初探（一）","slug":"3D-Engine-1","date":"2019-11-24T15:52:45.000Z","updated":"2019-11-27T14:47:36.167Z","comments":true,"path":"2019/11/24/3D-Engine-1/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/3D-Engine-1/","excerpt":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。","text":"前阵子，我用C++编写的3D游戏引擎成功的运行了一个小游戏demo，在此将会分享我的学习与搭建历程。 该3D引擎是跟着书籍《手把手教你架构3D游戏引擎》学习搭建的，由浅入深的讲解以及范例，令我受益匪浅。 介绍底层运用c++编写，图形接口为GDI（windows下的图形接口，不可跨平台。），模型材质运用的3D max制作，用通用的shader语法解析模型，渲染管线的一些列流程利用了矩阵的数学知识。 项目结构分为三部分：ECore核心模块，EEngine功能模块，EGame游戏模块。 本地化操作书籍中的编辑器是VS2013版，而我在学习的时候使用的是最新版的VS2019，跟着作者学习编写了所有代码，亲测可用，大家可以放心的编写学习啦。 材质地形编辑器书籍中对于材质地形编辑器的描述相当的少，我会在后期详细的描述材质地形是如何编辑的。 个人提升写本博客是必不可少的会重新过一遍书籍以及整合自身所学知识，算是对自己的再一次沉淀和查漏补缺。 收获对数据结构的理解上升了，图形学算法也有查找资料与编写demo的过程中有所了解和应用，学会了进行场景渲染以及物体的材质渲染，对于渲染管线以及传说中的shader不再陌生，也因此具备了宏观上的一些架构能力，对游戏的整体架构有了一定的认识。最重要的是也因此对我自身工作中所用的unity引擎有了更深层次的了解。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"3D Engine","slug":"3D-Engine","permalink":"https://aaronyard.github.io/tags/3D-Engine/"}]},{"title":"博客建站","slug":"Hexo-blog","date":"2019-11-24T05:44:07.000Z","updated":"2019-11-24T11:20:46.195Z","comments":true,"path":"2019/11/24/Hexo-blog/","link":"","permalink":"https://aaronyard.github.io/2019/11/24/Hexo-blog/","excerpt":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏","text":"特别鸣谢匠心零度：看了匠心零度的博客，我才下定决心要做一个自己的博客，理由太充分了。 小茗同学：博客的建立，基础的工作都是按照小茗同学的教程来做的，很详细。 徐靖峰：最终的博客主题确定为徐靖峰的博客主题，联系上后告知了相关主题以及主题出处。 最终效果AaronYard：https://aaronyard.github.io/ 欢迎各位来到我的博客考察~👏👏👏 准备工作 在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 配置好了相关的环境变量。 本文所使用的环境： Windows 10 node.js @12.13.1 Github Desktop @2.2.3 hexo @4.0.0 新建Github仓库在Github中新建一个名为 你的用户名.github.io 的仓库，例如你的GitHub用户名为example，则仓库名为 example.github.io ，这样，将来你的网站访问地址就是 http://example.github.io 了。 配置SSH keySSH key解决了本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git命令行。不要着急，按照如下指令做。 1$ ssh-keygen -t rsa -C \"Github注册邮箱\" 接着连续3次回车后，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的GitHub主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，title随意填写，将刚刚复制的内容粘贴到key中。 验证是否配置成功 1$ ssh -T git@github.com // 注意邮箱地址不用改 在弹出的 Are you sure you want to continue connecting (yes/no)? 后输入yes。 若显示 Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access. 则表明SSH配置成功。 接着输入如下指令 12$ git config --global user.name \"xxx\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@xxx.com\"// 填写你的github注册邮箱 如果遇到git非内外部指令的情况，则说明你没有为git配置环境变量，GitHub Destop的环境变量路径可参考： 1C:\\Users\\AaronEN\\AppData\\Local\\GitHubDesktop\\app-2.2.3\\resources\\app\\git\\cmd Hexo类型：静态网页 特点：速度快、部署简单、免费、结合github pages、支持markdown、内容布局自定义功能强. Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章！我的个人博客就是基于hexo生成的。很多网友对hexo的最深刻印象就是速度快和部署简单了。一个个人博客最核心的功能支持的非常好，你可以专心的写一些技术文章部署到上面了。 安装1$ npm install -g hexo 初始化找个目录存放你的项目代码，例如我的是 D:\\AaronYard 。 12$ cd /d/AaronYard/$ hexo init 初始化后的项目会自带一个主题，此时可以生成一个可以预览的网站。 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中输入 http://localhost:4000/，就可以浏览你的网站了。 主题当然啦，我们并不满足于官方提供的主题，此时就可以去寻觅自己喜欢的主题啦。 官方提供的主题网站：https://hexo.io/themes/ 我的网站的主题是hexo-theme-icarus 接下来就是下载主题的时刻啦！ 12$ cd /d/AaronYard/$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/hexo-theme-icarus 下载的主题会放在themes目录下，修改根目录下_config.yml中的theme: landscape改为theme: hexo-theme-icarus，然后重新执行hexo g来重新生成。 注意主题中的_config.yml也是需要修改的，对此有点基础的摸索片刻后就会修改了。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 提交GitHub在辛苦并快乐着的搭建工作之后，就可以愉快的将博客提交到GitHub中了。 配置根目录下_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:example/example.github.io.git branch: master 安装一个插件 1$ npm install hexo-deployer-git --save 提交本次改动的代码 1$ hexo d 至此，个人博客的框架搭建完成，还需要内容的扩充。 写博客定位到项目的根目录，输入命令 1$ hexo new \"hello-world\" hexo会帮我们在_posts目录下生成相关md文件md文件的目录结构一般如下 12345678---title: postName #文章页面上的显示名称，一般是中文date: 2019-11-24 13:44:07 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格---以下是正文 编写md文件后执行hexo g与hexo s即可浏览博客，若满意就可以hexo d愉快的提交博客啦。 写博客的工具关于写博客的工具，我用的是markdown editor，非常好用，左侧编写，右侧实时展现效果。编写的语法可参见hexo官方写作Wiki。 Hexo常用命令1234567891011121314151617hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本#缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy#组合命令hexo s -g #生成并本地预览hexo d -g #生成并上传 题外话我博客右下方有一只unitychan，很有趣吧，是基于live2d技术做的，感兴趣的可以点击此处学习搭建。","categories":[{"name":"技术探索","slug":"技术探索","permalink":"https://aaronyard.github.io/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"博客建站","slug":"博客建站","permalink":"https://aaronyard.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"}]},{"title":"我的个人博客开通啦","slug":"MyHexo","date":"2019-11-23T14:44:14.000Z","updated":"2020-04-07T04:22:38.921Z","comments":true,"path":"2019/11/23/MyHexo/","link":"","permalink":"https://aaronyard.github.io/2019/11/23/MyHexo/","excerpt":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。","text":"欢迎您来到我的 个人博客！点击此处进入我的GitHub个人账户。 虽说大学期间有为学院写过一个学院网站，但是懵懵懂懂，并不知道从搭建一个网站到可以外网访问的完整流程。所以从某种意义上来讲，这是我第一次搭建完成一个完整的网站，我将它作为我的个人博客（容我小得瑟一下，嘻嘻），此博客是基于Hexo与Git生成的网站，之后有时间了我会写一篇详细的搭建教程供各位参考。 关于我毕业于师范大学数学系，大学期间，我发现对于计算机的兴趣远大于数学带给我的快感，所以像老师申请了计算机实验室，在其中学习成长。在学院老师和同学的帮助下，我成立了团工委网络部，申请了微信公众号，从此开始了我的计算机探索之旅。 承蒙老师厚爱，我在北京实习参加工作，大三暑期开始在完美世界旗下子公司实习游戏客户端岗位，毕业后成功转正。因想稳定下来，目前回到家中，进入了另一家游戏公司继续成长。 三年的工作时间，令我从一个什么都不懂的毛头小子蜕变成了一个敢想敢干的小程序猿。为了弄明白3D游戏的原理，通过查资料以及实践，用C++编写了一个基于GDI的简易的完整3D引擎，并且为这个引擎写了一个游戏小demo，游戏成功运行的那一刻，我终于明白了什么是实践出真知。今天，这个小程序猿，又开始了想象之旅。 建站灵感 一开始没有想过要搭建一个网站啦，早上的时候看了知乎的一篇文章，里面介绍了一些让我很感兴趣的读物，我想从其中的一本书《上帝掷骰子吗？─量子物理史话》开始阅读，并且写下我的读书心得。 于是，我下载了这本书的电子版本当我阅读后想写读书心得时，突然意识到没有一个合适的网站供我书写。也许搭建一个个人博客是个不错的选择呢！毕竟我可以学习怎么搭建嘛，于是对互联网有一些了解的我，开始了漫长的建站之旅。 不断尝试通过对互联网服务器的一些了解，我将自己的笔记本当作服务器，运行了Tomcat，利用花生壳的内网穿透功能，捣鼓了一波家中的路由器，成功的在外网访问到了内网的网站。 但是这远远不够，我还需要一个适合我的网站管理系统，最终我找到了这个hexo，简直神器，完全不需要我进行内网穿透嘛！！而且基于git管理，网站管理方便，支持MarkDown编写，简直满足了我的一切需求。 今日心得新技能Get√ 终于把个人博客有模有样的捣鼓出来了，我可以在以后的日子里专心的写读书心得啦。","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://aaronyard.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"新技能Get√","slug":"新技能Get√","permalink":"https://aaronyard.github.io/tags/%E6%96%B0%E6%8A%80%E8%83%BDGet%E2%88%9A/"}]}]}